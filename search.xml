<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>RxSwift-UIKit-UIApplication-01</title>
      <link href="/2018/05/22/Swift/RxSwift/UIKit/UIApplication-01/"/>
      <url>/2018/05/22/Swift/RxSwift/UIKit/UIApplication-01/</url>
      <content type="html"><![CDATA[<h1 id="isNetworkActivityIndicatorVisible-状态栏显示菊花"><a href="#isNetworkActivityIndicatorVisible-状态栏显示菊花" class="headerlink" title="isNetworkActivityIndicatorVisible 状态栏显示菊花"></a>isNetworkActivityIndicatorVisible 状态栏显示菊花</h1><blockquote><p>dispaseBag</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dispaseBag = <span class="type">DisposeBag</span>()</span><br></pre></td></tr></table></figure><blockquote><p>开关</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> mySwitch: <span class="type">UISwitch</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> mySwitch = <span class="type">UISwitch</span>()</span><br><span class="line">    mySwitch.frame = <span class="type">CGRect</span>(x: <span class="number">20</span>, y: <span class="number">60</span>, width: <span class="number">40</span>, height: <span class="number">30</span>)</span><br><span class="line">    <span class="keyword">return</span> mySwitch</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><blockquote><p>add UI</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.view.addSubview(mySwitch)</span><br></pre></td></tr></table></figure><blockquote><p>状态栏里显示 菊花</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mySwitch.rx</span><br><span class="line">      .isOn</span><br><span class="line">      .bind(to: <span class="type">UIApplication</span>.shared.rx.isNetworkActivityIndicatorVisible)</span><br><span class="line">      .disposed(by: dispaseBag)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UIKit </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-UIKit-UISegmentedControl-响应式扩展-01</title>
      <link href="/2018/05/22/Swift/RxSwift/UIKit/UISegmentedControl-01/"/>
      <url>/2018/05/22/Swift/RxSwift/UIKit/UISegmentedControl-01/</url>
      <content type="html"><![CDATA[<h1 id="UISegmentedControl"><a href="#UISegmentedControl" class="headerlink" title="UISegmentedControl"></a>UISegmentedControl</h1><blockquote><p>disposeBag</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br></pre></td></tr></table></figure><blockquote><p>分段选择控件</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> segmentedCtl: <span class="type">UISegmentedControl</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> segmentedCtl = <span class="type">UISegmentedControl</span>(items: [<span class="string">"1"</span>,<span class="string">"22"</span>])</span><br><span class="line">    segmentedCtl.frame = <span class="type">CGRect</span>(x: <span class="number">20</span>, y: <span class="number">20</span>, width: <span class="number">200</span>, height: <span class="number">30</span>)</span><br><span class="line">    <span class="comment">//当前选中下标</span></span><br><span class="line">    segmentedCtl.selectedSegmentIndex = <span class="number">0</span></span><br><span class="line">    <span class="comment">//segmentedCtl.backgroundColor = UIColor.red</span></span><br><span class="line">    <span class="keyword">return</span> segmentedCtl</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><blockquote><p>显示图片</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fileprivate lazy var showImgView: UIImageView = &#123;</span><br><span class="line">    let showImgView = UIImageView()</span><br><span class="line">    showImgView.frame = CGRect(x: 30, y: 60, width: 180, height: 180)</span><br><span class="line">    return showImgView</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><blockquote><p>add UI</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.view.addSubview(<span class="keyword">self</span>.segmentedCtl)</span><br><span class="line">       <span class="keyword">self</span>.view.addSubview(<span class="keyword">self</span>.showImgView)</span><br></pre></td></tr></table></figure><blockquote><p>实现当 UISegmentedControl 选中项改变时，输出当前选中项索引值</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">segmentedCtl.rx.selectedSegmentIndex.asObservable().subscribe(onNext:&#123;</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">"当前项：<span class="subst">\($<span class="number">0</span>)</span>"</span>)</span><br><span class="line">       &#125;).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><blockquote><p>创建一个当前需要显示的图片的可观察序列</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>  segmentedsquence: <span class="type">Observable</span>&lt;<span class="type">UIImage</span>&gt; = segmentedCtl.rx</span><br><span class="line">              .selectedSegmentIndex</span><br><span class="line">              .asObservable()</span><br><span class="line">              .<span class="built_in">map</span>&#123;</span><br><span class="line">                         <span class="keyword">let</span> imgDatas = [<span class="string">"1"</span>,<span class="string">"2"</span>]</span><br><span class="line">                         <span class="keyword">return</span> <span class="type">UIImage</span>(named: imgDatas[$<span class="number">0</span>])!</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure><blockquote><p>把需要显示的图片绑定到 imageView 上</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">segmentedsquence.bind(to: showImgView.rx.image)</span><br><span class="line">                .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UIKit </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-UIKit-UIActivityIndicatorView状态指示器-响应式扩展-01</title>
      <link href="/2018/05/22/Swift/RxSwift/UIKit/UIActivityIndicatorView-01/"/>
      <url>/2018/05/22/Swift/RxSwift/UIKit/UIActivityIndicatorView-01/</url>
      <content type="html"><![CDATA[<h1 id="UIActivityIndicatorView"><a href="#UIActivityIndicatorView" class="headerlink" title="UIActivityIndicatorView"></a>UIActivityIndicatorView</h1><ul><li>UIActivityIndicatorView 状态/活动指示器，它会通过一个旋转的“菊花”来表示当前的活动状态</li></ul><blockquote><p>disposeBag</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br></pre></td></tr></table></figure><blockquote><p>UI:开关</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> mySwitch: <span class="type">UISwitch</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> mySwitch = <span class="type">UISwitch</span>()</span><br><span class="line">    mySwitch.frame = <span class="type">CGRect</span>(x: <span class="number">10</span>, y: <span class="number">64</span>, width: <span class="number">40</span>, height: <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">return</span> mySwitch</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><blockquote><p>活动指示器</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> myActivityIndicatorView: <span class="type">UIActivityIndicatorView</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> myActivityIndicatorView = <span class="type">UIActivityIndicatorView</span>()</span><br><span class="line">    myActivityIndicatorView.frame = <span class="type">CGRect</span>(x: <span class="number">80</span>, y: <span class="number">64</span>, width: <span class="number">40</span>, height: <span class="number">20</span>)</span><br><span class="line">    myActivityIndicatorView.color = <span class="type">UIColor</span>.red</span><br><span class="line">    <span class="keyword">return</span> myActivityIndicatorView</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><blockquote><p>add UI</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.view.addSubview(<span class="keyword">self</span>.mySwitch)</span><br><span class="line">      <span class="keyword">self</span>.view.addSubview(<span class="keyword">self</span>.myActivityIndicatorView)</span><br></pre></td></tr></table></figure><blockquote><p>开关控制 菊花开启</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mySwitch.rx</span><br><span class="line">         .isOn</span><br><span class="line">         .bind(to: myActivityIndicatorView.rx.isAnimating)</span><br><span class="line">         .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UIKit </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-UIKit-UISwitch-响应式扩展-01</title>
      <link href="/2018/05/22/Swift/RxSwift/UIKit/UISwitch-01/"/>
      <url>/2018/05/22/Swift/RxSwift/UIKit/UISwitch-01/</url>
      <content type="html"><![CDATA[<h1 id="btn响应"><a href="#btn响应" class="headerlink" title="btn响应"></a>btn响应</h1><blockquote><p>disposeBag</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br></pre></td></tr></table></figure><blockquote><p>UI</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> mySwitch: <span class="type">UISwitch</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> mySwitch = <span class="type">UISwitch</span>()</span><br><span class="line">    mySwitch.frame = <span class="type">CGRect</span>(x: <span class="number">20</span>, y: <span class="number">80</span>, width: <span class="number">80</span>, height: <span class="number">30</span>)</span><br><span class="line">    <span class="keyword">return</span> mySwitch</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> switchshowBtn: <span class="type">UIButton</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> switchshowBtn = <span class="type">UIButton</span>()</span><br><span class="line">        switchshowBtn.frame = <span class="type">CGRect</span>(x: <span class="number">120</span>, y: <span class="number">80</span>, width: <span class="number">200</span>, height: <span class="number">30</span>)</span><br><span class="line">        switchshowBtn.setTitleColor(<span class="type">UIColor</span>.gray, <span class="keyword">for</span>: <span class="type">UIControlState</span>.normal)</span><br><span class="line">        switchshowBtn.setTitleColor(<span class="type">UIColor</span>.red, <span class="keyword">for</span>: <span class="type">UIControlState</span>.selected)</span><br><span class="line">        switchshowBtn.setTitle(<span class="string">"show switch select"</span>, <span class="keyword">for</span>: <span class="type">UIControlState</span>.normal)</span><br><span class="line">        <span class="keyword">return</span> switchshowBtn</span><br><span class="line">    &#125;()</span><br></pre></td></tr></table></figure><blockquote><p>当 switch 开关状态改变时，输出当前值</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mySwitch.rx</span><br><span class="line">        .isOn.asObservable()</span><br><span class="line">        .subscribe(onNext: &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"当前开关状态：<span class="subst">\($<span class="number">0</span>)</span>"</span>)</span><br><span class="line">           &#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><blockquote><p>切换 switch 开关时，button 会在可用和不可用的状态间切换</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mySwitch.rx</span><br><span class="line">        .isOn</span><br><span class="line">        .bind(to: switchshowBtn.rx.isSelected)</span><br><span class="line">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UIKit </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-UIKit-UIButton-响应式扩展-01</title>
      <link href="/2018/05/22/Swift/RxSwift/UIKit/UIButton-01/"/>
      <url>/2018/05/22/Swift/RxSwift/UIKit/UIButton-01/</url>
      <content type="html"><![CDATA[<h1 id="btn响应"><a href="#btn响应" class="headerlink" title="btn响应"></a>btn响应</h1><blockquote><p>创建btn</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> myBtn: <span class="type">UIButton</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> myBtn = <span class="type">UIButton</span>(frame: <span class="type">CGRect</span>(x: <span class="number">100</span>,</span><br><span class="line">         y: <span class="number">100</span>, </span><br><span class="line">        width: <span class="number">200</span>, </span><br><span class="line">        height: <span class="number">60</span>))</span><br><span class="line">    myBtn.backgroundColor = <span class="type">UIColor</span>.red</span><br><span class="line">    <span class="keyword">return</span> myBtn</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><blockquote><p>添加btn</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.view.addSubview(<span class="keyword">self</span>.myBtn)</span><br></pre></td></tr></table></figure><blockquote><p>写法1</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">myBtn.rx</span><br><span class="line">     .tap</span><br><span class="line">     .subscribe(onNext:&#123;</span><br><span class="line">          [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>?.showMsg(<span class="string">"click one btn"</span>)</span><br><span class="line">       &#125;)</span><br><span class="line">     .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><blockquote><p>写法2</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">myBtn.rx</span><br><span class="line">    .tap</span><br><span class="line">    .bind&#123;</span><br><span class="line">        [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>?.showMsg(<span class="string">"click one btn"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><blockquote><p>点击btn后的提示 alertCtl</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showMsg</span><span class="params">(<span class="number">_</span> titleStr: String)</span></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> alertCtl = <span class="type">UIAlertController</span>(title: titleStr,</span><br><span class="line">                                     message: <span class="literal">nil</span>,</span><br><span class="line">                                     preferredStyle: <span class="type">UIAlertControllerStyle</span>.alert)</span><br><span class="line">    <span class="keyword">let</span> cancelAction = <span class="type">UIAlertAction</span>(title: <span class="string">"YES"</span>,</span><br><span class="line">                                     style: <span class="type">UIAlertActionStyle</span>.cancel,</span><br><span class="line">                                     handler: <span class="literal">nil</span>)</span><br><span class="line">    alertCtl.addAction(cancelAction)</span><br><span class="line">    <span class="keyword">self</span>.present(alertCtl, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="按钮标题（title）的绑定"><a href="#按钮标题（title）的绑定" class="headerlink" title="按钮标题（title）的绑定"></a>按钮标题（title）的绑定</h1><blockquote><p>创建一个计时器（每1秒发送一个索引数）</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timerSquence = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.interval(<span class="number">1</span>, scheduler: <span class="type">MainScheduler</span>.instance)</span><br></pre></td></tr></table></figure><blockquote><p>根据索引数拼接最新的标题，并绑定到button上</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">timerSquence.<span class="built_in">map</span>&#123;</span><br><span class="line">        <span class="string">"count:<span class="subst">\($<span class="number">0</span>)</span>"</span></span><br><span class="line">        &#125;</span><br><span class="line">        .bind(to: myBtn.rx.title(<span class="keyword">for</span>: <span class="type">UIControlState</span>.normal))</span><br><span class="line">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h1 id="按钮富文本标题（attributedTitle）的绑定"><a href="#按钮富文本标题（attributedTitle）的绑定" class="headerlink" title="按钮富文本标题（attributedTitle）的绑定"></a>按钮富文本标题（attributedTitle）的绑定</h1><blockquote><p>创建btn</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> attributedBtn: <span class="type">UIButton</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> attributedBtn = <span class="type">UIButton</span>(frame: <span class="type">CGRect</span>(x: <span class="number">100</span>, </span><br><span class="line">           y: <span class="number">200</span>, </span><br><span class="line">       width: <span class="number">200</span>, </span><br><span class="line">      height: <span class="number">60</span>))</span><br><span class="line">    attributedBtn.backgroundColor = <span class="type">UIColor</span>.gray</span><br><span class="line">    <span class="keyword">return</span> attributedBtn</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><blockquote><p>添加btn</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.view.addSubview(<span class="keyword">self</span>.attributedBtn)</span><br></pre></td></tr></table></figure><blockquote><p>按钮富文本标题（attributedTitle）的绑定</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">timerSquence.<span class="built_in">map</span>(formatTimeInterval)</span><br><span class="line">    .bind(to: attributedBtn.rx.attributedTitle())</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><blockquote><p>将数字转成对应的富文本</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatTimeInterval</span><span class="params">(ms: NSInteger)</span></span> -&gt; <span class="type">NSMutableAttributedString</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="type">String</span>(format: <span class="string">"%0.2d:%0.2d:%0.2d"</span>,</span><br><span class="line">                     arguments:[(ms / <span class="number">600</span>) % <span class="number">600</span>, (ms % <span class="number">600</span> ) / <span class="number">10</span>, ms % <span class="number">10</span>] )</span><br><span class="line">    <span class="comment">//富文本设置</span></span><br><span class="line">    <span class="keyword">let</span> attributeStr = <span class="type">NSMutableAttributedString</span>(string: str)</span><br><span class="line">    <span class="comment">////从文本0开始6个字符字体HelveticaNeue-Bold,16号</span></span><br><span class="line">    attributeStr.addAttribute(<span class="type">NSAttributedStringKey</span>.font,</span><br><span class="line">                              value: <span class="type">UIFont</span>(name: <span class="string">"HelveticaNeue-Bold"</span>, size: <span class="number">16</span>)!,</span><br><span class="line">                              range: <span class="type">NSMakeRange</span>(<span class="number">0</span>, <span class="number">5</span>))</span><br><span class="line">    <span class="comment">//设置字体颜色</span></span><br><span class="line">    attributeStr.addAttribute(<span class="type">NSAttributedStringKey</span>.foregroundColor,</span><br><span class="line">                              value: <span class="type">UIColor</span>.white,</span><br><span class="line">                              range: <span class="type">NSMakeRange</span>(<span class="number">0</span>, <span class="number">5</span>))</span><br><span class="line">    <span class="comment">//设置文字背景颜色</span></span><br><span class="line">    attributeStr.addAttribute(<span class="type">NSAttributedStringKey</span>.backgroundColor,</span><br><span class="line">                              value: <span class="type">UIColor</span>.orange,</span><br><span class="line">                              range: <span class="type">NSMakeRange</span>(<span class="number">0</span>, <span class="number">5</span>))</span><br><span class="line">    <span class="keyword">return</span> attributeStr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">    <span class="comment">// Dispose of any resources that can be recreated.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图标（image）的绑定"><a href="#图标（image）的绑定" class="headerlink" title="图标（image）的绑定"></a>图标（image）的绑定</h1><h2 id="按钮图标（image）的绑定"><a href="#按钮图标（image）的绑定" class="headerlink" title="按钮图标（image）的绑定"></a>按钮图标（image）的绑定</h2><blockquote><p>rx.image 为 setImage(_:for:) 的封装<br>根据索引数选择对应的按钮图标，并绑定到button上</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">timerSquence.<span class="built_in">map</span>(&#123;</span><br><span class="line">                <span class="keyword">let</span> nameStr = $<span class="number">0</span>%<span class="number">2</span> == <span class="number">0</span> ? <span class="string">"back"</span> : <span class="string">"forward"</span></span><br><span class="line">                <span class="keyword">return</span>  <span class="type">UIImage</span>(named: nameStr)!</span><br><span class="line">               &#125;)</span><br><span class="line">      .bind(to: myBtn.rx.image())</span><br><span class="line">      .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h2 id="按钮背景图片（backgroundImage）的绑定"><a href="#按钮背景图片（backgroundImage）的绑定" class="headerlink" title="按钮背景图片（backgroundImage）的绑定"></a>按钮背景图片（backgroundImage）的绑定</h2><blockquote><p>当程序启动时就开始计数，根据奇偶数选择相应的图片作为 button 的背景<br>其中 rx.backgroundImage 为 setBackgroundImage(_:for:) 的封装<br>根据索引数选择对应的按钮背景图，并绑定到button上</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">timerSquence.<span class="built_in">map</span>&#123;</span><br><span class="line">               <span class="type">UIImage</span>(named: <span class="string">"<span class="subst">\($<span class="number">0</span>%<span class="number">2</span>)</span>"</span>)!</span><br><span class="line">               &#125;</span><br><span class="line">           .bind(to: myBtn.rx.backgroundImage())</span><br><span class="line">           .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h1 id="按钮是否可用（isEnabled）的绑定"><a href="#按钮是否可用（isEnabled）的绑定" class="headerlink" title="按钮是否可用（isEnabled）的绑定"></a>按钮是否可用（isEnabled）的绑定</h1><blockquote><p>创建 switch</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> mySwitch: <span class="type">UISwitch</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> mySwitch = <span class="type">UISwitch</span>(frame: <span class="type">CGRect</span>(x: <span class="number">100</span>, y: <span class="number">300</span>, width: <span class="number">60</span>, height: <span class="number">60</span>))</span><br><span class="line">    <span class="keyword">return</span> mySwitch</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><blockquote><p>switch控制btn交互性</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mySwitch.rx</span><br><span class="line">    .isOn</span><br><span class="line">    .bind(to: myBtn.rx.isEnabled)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h1 id="按钮是否选中（isSelected）的绑定"><a href="#按钮是否选中（isSelected）的绑定" class="headerlink" title="按钮是否选中（isSelected）的绑定"></a>按钮是否选中（isSelected）的绑定</h1><blockquote><p>创建btn</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> selectOneBtn: <span class="type">UIButton</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> selectOneBtn = <span class="type">UIButton</span>(frame: <span class="type">CGRect</span>(x: <span class="number">100</span>, y: <span class="number">400</span>, width: <span class="number">200</span>, height: <span class="number">60</span>))</span><br><span class="line">    selectOneBtn.setTitle(<span class="string">"one"</span>, <span class="keyword">for</span>: <span class="type">UIControlState</span>.normal)</span><br><span class="line">    selectOneBtn.setTitleColor(<span class="type">UIColor</span>.gray, <span class="keyword">for</span>: <span class="type">UIControlState</span>.normal)</span><br><span class="line">    selectOneBtn.setTitleColor(<span class="type">UIColor</span>.green, <span class="keyword">for</span>: <span class="type">UIControlState</span>.selected)</span><br><span class="line">    <span class="keyword">return</span> selectOneBtn</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> selectSecondBtn: <span class="type">UIButton</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> selectSecondBtn = <span class="type">UIButton</span>(frame: <span class="type">CGRect</span>(x: <span class="number">100</span>, y: <span class="number">500</span>, width: <span class="number">200</span>, height: <span class="number">60</span>))</span><br><span class="line">    selectSecondBtn.setTitle(<span class="string">"second"</span>, <span class="keyword">for</span>: <span class="type">UIControlState</span>.normal)</span><br><span class="line">    selectSecondBtn.setTitleColor(<span class="type">UIColor</span>.gray, <span class="keyword">for</span>: <span class="type">UIControlState</span>.normal)</span><br><span class="line">    selectSecondBtn.setTitleColor(<span class="type">UIColor</span>.green, <span class="keyword">for</span>: <span class="type">UIControlState</span>.selected)</span><br><span class="line">    <span class="keyword">return</span> selectSecondBtn</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><blockquote><p>add </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.view.addSubview(selectOneBtn)</span><br><span class="line"><span class="keyword">self</span>.view.addSubview(selectSecondBtn)</span><br></pre></td></tr></table></figure><blockquote><p>默认选择第一个按钮</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">selectOneBtn.isSelected = <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>强制解包，避免后面还需要处理可选类型</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btnArray = [selectOneBtn,selectSecondBtn].<span class="built_in">map</span>&#123;$<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>创建一个可观察序列，它可以发送最后一次点击的按钮（也就是我们需要选中的按钮）</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> selectSquence = <span class="type">Observable</span>.from(btnArray.<span class="built_in">map</span>&#123;</span><br><span class="line">         btn <span class="keyword">in</span></span><br><span class="line">         btn.rx.tap.<span class="built_in">map</span> &#123;btn&#125;</span><br><span class="line">       &#125;)</span><br><span class="line">    .merge()</span><br></pre></td></tr></table></figure><blockquote><p>对于每一个按钮都对selectedButton进行订阅，根据它是否是当前选中的按钮绑定isSelected属性</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> oneBtn <span class="keyword">in</span> btnArray&#123;</span><br><span class="line">    selectSquence.<span class="built_in">map</span> &#123;</span><br><span class="line">            $<span class="number">0</span> == oneBtn</span><br><span class="line">           &#125;</span><br><span class="line">       .bind(to: oneBtn.rx.isSelected)</span><br><span class="line">       .disposed(by: disposeBag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UIKit </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-UIKit-UISlider-01</title>
      <link href="/2018/05/22/Swift/RxSwift/UIKit/UISlider-01/"/>
      <url>/2018/05/22/Swift/RxSwift/UIKit/UISlider-01/</url>
      <content type="html"><![CDATA[<h1 id="UISlider"><a href="#UISlider" class="headerlink" title="UISlider"></a>UISlider</h1><blockquote><p>disposeBag</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br></pre></td></tr></table></figure><blockquote><p>滑块mySlider</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> mySlider: <span class="type">UISlider</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> mySlider = <span class="type">UISlider</span>()</span><br><span class="line">    mySlider.frame = <span class="type">CGRect</span>(x: <span class="number">60</span>, y: <span class="number">100</span>, width: <span class="number">300</span>, height: <span class="number">30</span>)</span><br><span class="line">    <span class="keyword">return</span> mySlider</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><blockquote><p>add UI</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.view.addSubview(<span class="keyword">self</span>.mySlider)</span><br></pre></td></tr></table></figure><blockquote><p>输出滑动值</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mySlider.rx</span><br><span class="line">        .value</span><br><span class="line">        .asObservable()</span><br><span class="line">        .subscribe(&#123;</span><br><span class="line">                   <span class="built_in">print</span>(<span class="string">"当前值为：<span class="subst">\($<span class="number">0</span>)</span>"</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-Grammar-ControlEvent</title>
      <link href="/2018/05/20/Swift/RxSwift/Grammar/ControlEvent/"/>
      <url>/2018/05/20/Swift/RxSwift/Grammar/ControlEvent/</url>
      <content type="html"><![CDATA[<h1 id="ControlEvent"><a href="#ControlEvent" class="headerlink" title="ControlEvent"></a>ControlEvent</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>ControlEvent 是专门用于描述 UI 所产生的事件，拥有该类型的属性都是被观察者（Observable）<br>ControlEvent 和 ControlProperty 一样，都具有以下特征</p></blockquote><ul><li>不会产生 error 事件</li><li>一定在 MainScheduler 订阅（主线程订阅）</li><li>一定在 MainScheduler 监听（主线程监听）</li><li>共享状态变化</li></ul><h2 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h2><blockquote><p>同样地，在 RxCocoa 下许多 UI 控件的事件方法都是被观察者（可观察序列）。比如我们查看源码（UIButton+Rx.swift），可以发现 UIButton 的 rx.tap 方法类型便是 ControlEvent<void>：</void></p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UIButton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> tap: <span class="type">ControlEvent</span>&lt;<span class="type">Void</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> controlEvent(.touchUpInside)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>那么我们如果想实现当一个 button 被点击时，在控制台输出一段文字。即前者作为被观察者，后者作为观察者。可以这么写： </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> RxCocoa</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> button: <span class="type">UIButton</span>!</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//订阅按钮点击事件</span></span><br><span class="line">        button.rx.tap</span><br><span class="line">            .subscribe(onNext: &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"欢迎访问hangge.com"</span>)</span><br><span class="line">            &#125;).disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Grammar </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-Grammar-ControlProperty</title>
      <link href="/2018/05/20/Swift/RxSwift/Grammar/ControlProperty/"/>
      <url>/2018/05/20/Swift/RxSwift/Grammar/ControlProperty/</url>
      <content type="html"><![CDATA[<h1 id="Schedulers调度器"><a href="#Schedulers调度器" class="headerlink" title="Schedulers调度器"></a>Schedulers调度器</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>ControlProperty 是专门用来描述 UI 控件属性，拥有该类型的属性都是被观察者（Observable）<br>ControlProperty 具有以下特征</p></blockquote><ul><li>不会产生 error 事件</li><li>一定在 MainScheduler 订阅（主线程订阅）</li><li>一定在 MainScheduler 监听（主线程监听）</li><li>共享状态变化</li></ul><h2 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h2><blockquote><p>其实在 RxCocoa 下许多 UI 控件属性都是被观察者（可观察序列）<br>比如我们查看源码（UITextField+Rx.swift），可以发现 UITextField 的 rx.text 属性类型便是 ControlProperty&lt;String?&gt;：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UITextField</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> text: <span class="type">ControlProperty</span>&lt;<span class="type">String</span>?&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> value: <span class="type">ControlProperty</span>&lt;<span class="type">String</span>?&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> base.rx.controlPropertyWithDefaultEvents(</span><br><span class="line">            getter: &#123; textField <span class="keyword">in</span></span><br><span class="line">                textField.text</span><br><span class="line">        &#125;,</span><br><span class="line">            setter: &#123; textField, value <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> textField.text != value &#123;</span><br><span class="line">                    textField.text = value</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="那么我们如果想让一个-textField-里输入内容实时地显示在另一个-label-上，即前者作为被观察者，后者作为观察者。可以这么写："><a href="#那么我们如果想让一个-textField-里输入内容实时地显示在另一个-label-上，即前者作为被观察者，后者作为观察者。可以这么写：" class="headerlink" title="那么我们如果想让一个 textField 里输入内容实时地显示在另一个 label 上，即前者作为被观察者，后者作为观察者。可以这么写："></a>那么我们如果想让一个 textField 里输入内容实时地显示在另一个 label 上，即前者作为被观察者，后者作为观察者。可以这么写：</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> RxCocoa</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> textField: <span class="type">UITextField</span>!</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> label: <span class="type">UILabel</span>!</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//将textField输入的文字绑定到label上</span></span><br><span class="line">        textField.rx.text</span><br><span class="line">            .bind(to: label.rx.text)</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UILabel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> fontSize: <span class="type">Binder</span>&lt;<span class="type">CGFloat</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Binder</span>(<span class="keyword">self</span>) &#123; label, fontSize <span class="keyword">in</span></span><br><span class="line">            label.font = <span class="type">UIFont</span>.systemFont(ofSize: fontSize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Grammar </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-Grammar-Schedulers调度器</title>
      <link href="/2018/05/20/Swift/RxSwift/Grammar/Schedulers%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
      <url>/2018/05/20/Swift/RxSwift/Grammar/Schedulers%E8%B0%83%E5%BA%A6%E5%99%A8/</url>
      <content type="html"><![CDATA[<h1 id="Schedulers调度器"><a href="#Schedulers调度器" class="headerlink" title="Schedulers调度器"></a>Schedulers调度器</h1><blockquote><p>调度器（Schedulers）是 RxSwift 实现多线程的核心模块，它主要用于控制任务在哪个线程或队列运行</p></blockquote><h2 id="RxSwift-内置了如下几种-Scheduler"><a href="#RxSwift-内置了如下几种-Scheduler" class="headerlink" title="RxSwift 内置了如下几种 Scheduler"></a>RxSwift 内置了如下几种 Scheduler</h2><blockquote><p>CurrentThreadScheduler</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">表示当前线程 <span class="type">Scheduler</span>。（默认使用这个）</span><br></pre></td></tr></table></figure><blockquote><p>MainScheduler</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">表示主线程。如果我们需要执行一些和 <span class="type">UI</span> 相关的任务，就需要切换到该 <span class="type">Scheduler</span> 运行</span><br></pre></td></tr></table></figure><blockquote><p>SerialDispatchQueueScheduler</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">封装了 <span class="type">GCD</span> 的串行队列。如果我们需要执行一些串行任务，可以切换到这个 <span class="type">Scheduler</span> 运行</span><br></pre></td></tr></table></figure><blockquote><p>ConcurrentDispatchQueueScheduler</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">封装了 <span class="type">GCD</span> 的并行队列。如果我们需要执行一些并发任务，可以切换到这个 <span class="type">Scheduler</span> 运行</span><br></pre></td></tr></table></figure><blockquote><p>OperationQueueScheduler</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">封装了 <span class="type">NSOperationQueue</span></span><br></pre></td></tr></table></figure><h2 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h2><blockquote><p>以请求网络数据并显示为例。我们在后台发起网络请求，然后解析数据，最后在主线程刷新页面</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">subscribeon ---&gt;<span class="type">Data</span>---&gt; observeon---&gt; 主  <span class="type">Scheduler</span></span><br><span class="line">                                  ---&gt; 后台 <span class="type">Scheduler</span></span><br></pre></td></tr></table></figure><blockquote><p>过去我们使用 GCD 来实现，代码大概是这样的</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//现在后台获取数据</span></span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .userInitiated).async &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">try</span>? <span class="type">Data</span>(contentsOf: url)</span><br><span class="line">    <span class="comment">//再到主线程显示结果</span></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="keyword">self</span>.data = data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果使用 RxSwift 来实现，代码大概是这样的</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rxData: <span class="type">Observable</span>&lt;<span class="type">Data</span>&gt; = ...</span><br><span class="line"> </span><br><span class="line">rxData.subscribeOn(<span class="type">ConcurrentDispatchQueueScheduler</span>(qos: .userInitiated)) <span class="comment">//后台构建序列</span></span><br><span class="line">      .observeOn(<span class="type">MainScheduler</span>.instance)  <span class="comment">//主线程监听并处理序列结果</span></span><br><span class="line">      .subscribe(onNext: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] data <span class="keyword">in</span></span><br><span class="line">           <span class="keyword">self</span>?.data = data</span><br><span class="line">          &#125;)</span><br><span class="line">      .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h2 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn()"></a>subscribeOn()</h2><blockquote><p>该方法决定数据序列的构建函数在哪个 Scheduler 上运行。<br>比如上面样例，由于获取数据、解析数据需要花费一段时间的时间，所以通过 subscribeOn 将其切换到后台 Scheduler 来执行。这样可以避免主线程被阻塞。</p></blockquote><h2 id="observeOn"><a href="#observeOn" class="headerlink" title="observeOn()"></a>observeOn()</h2><blockquote><p>该方法决定在哪个 Scheduler 上监听这个数据序列。<br>比如上面样例，我们获取并解析完毕数据后又通过 observeOn 方法切换到主线程来监听并且处理结果</p></blockquote>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Grammar </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-UIKit-UITableViewCell-Event订阅UITableViewCell里的按钮点击事件</title>
      <link href="/2018/05/20/Swift/RxSwift/UIKit/UITableViewCell-Event/"/>
      <url>/2018/05/20/Swift/RxSwift/UIKit/UITableViewCell-Event/</url>
      <content type="html"><![CDATA[<h1 id="订阅UITableViewCell里的按钮点击事件"><a href="#订阅UITableViewCell里的按钮点击事件" class="headerlink" title="订阅UITableViewCell里的按钮点击事件"></a>订阅UITableViewCell里的按钮点击事件</h1><blockquote><p>通过订阅 tableView 的 itemSelected 或 modelSelected 这两个 Rx 扩展方法，可以对单元格的点击事件进行响应，并执行相关的业务代码。<br>但有时并不需要整个 cell 都能进行点击响应，可能是点击单元格内的按钮时才触发相关的操作，下面通过样例演示这个功能的实现</p></blockquote><h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p><img src="http://ot0mms4k8.bkt.clouddn.com/%E8%AE%A2%E9%98%85UITableViewCell%E9%87%8C%E7%9A%84%E6%8C%89%E9%92%AE%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6.gif" alt="效果图"></p><h1 id="MyTableCell-swift（自定义单元格类）"><a href="#MyTableCell-swift（自定义单元格类）" class="headerlink" title="MyTableCell.swift（自定义单元格类）"></a>MyTableCell.swift（自定义单元格类）</h1><ul><li>注意 prepareForReuse() 方法里的 disposeBag = DisposeBag()</li><li>每次 prepareForReuse() 方法执行时都会初始化一个新的 disposeBag。</li><li>这是因为 cell 是可以复用的，这样当 cell 每次重用的时候，便会自动释放之前的 disposeBag，从而保证 cell 被重用的时候不会被多次订阅，避免错误发生。</li></ul><blockquote><p>单元格类</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTableCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> button : <span class="type">UIButton</span>!</span><br><span class="line">    <span class="keyword">var</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    <span class="comment">//单元格重用时调用</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepareForReuse()</span><br><span class="line">        disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(style: <span class="type">UITableViewCellStyle</span>, reuseIdentifier: <span class="type">String</span>?) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(style: style, reuseIdentifier: reuseIdentifier)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//添加按钮</span></span><br><span class="line">        button = <span class="type">UIButton</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">40</span>, height: <span class="number">25</span>))</span><br><span class="line">        button.setTitle(<span class="string">"click"</span>, <span class="keyword">for</span>: .normal)<span class="comment">//普通状态下的文字</span></span><br><span class="line">        button.backgroundColor = <span class="type">UIColor</span>.red</span><br><span class="line">        button.layer.cornerRadius = <span class="number">5</span></span><br><span class="line">        button.titleLabel?.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>)</span><br><span class="line">        <span class="keyword">self</span>.addSubview(button)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 布局</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span>  <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">super</span>.layoutSubviews()</span><br><span class="line">        button.center = <span class="type">CGPoint</span>(x: bounds.width - <span class="number">35</span>, y: bounds.midY)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">              <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ViewController-swift（主视图控制器）"><a href="#ViewController-swift（主视图控制器）" class="headerlink" title="ViewController.swift（主视图控制器）"></a>ViewController.swift（主视图控制器）</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> RxCocoa</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//disposeBag</span></span><br><span class="line">    <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    <span class="comment">//tableView</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> tableView: <span class="type">UITableView</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> tableView = <span class="type">UITableView</span>(frame: <span class="keyword">self</span>.view.frame,style: .plain)</span><br><span class="line">        <span class="comment">//创建表格视图</span></span><br><span class="line">        <span class="comment">//创建一个重用的单元格</span></span><br><span class="line">        tableView.register(<span class="type">MyTableCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"Cell"</span>)</span><br><span class="line">        <span class="comment">//单元格无法选中</span></span><br><span class="line">        tableView.allowsSelection = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> tableView</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//加载tableView</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(<span class="keyword">self</span>.tableView)</span><br><span class="line">        <span class="comment">//初始化数据  .just 只创建包含一个元素的序列</span></span><br><span class="line">        <span class="keyword">let</span> items = <span class="type">Observable</span>.just([<span class="string">"01"</span>,<span class="string">"02"</span>,<span class="string">"03"</span>,<span class="string">"04"</span>])</span><br><span class="line">        <span class="comment">//设置单元格数据（其实就是对 cellForRowAt 的封装）</span></span><br><span class="line">        items.bind(to: tableView.rx.items)&#123; (tableView, row , element) <span class="keyword">in</span></span><br><span class="line">                                                <span class="comment">//初始化cell</span></span><br><span class="line">                                                <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"Cell"</span>) <span class="keyword">as</span>! <span class="type">MyTableCell</span></span><br><span class="line">                                                cell.textLabel?.text = <span class="string">"<span class="subst">\(element)</span>"</span></span><br><span class="line">                                                <span class="comment">//cell中按钮点击事件订阅</span></span><br><span class="line">                                                cell.button</span><br><span class="line">                                                    .rx</span><br><span class="line">                                                    .tap</span><br><span class="line">                                                    .asDriver() <span class="comment">//转换成一个Driver序列</span></span><br><span class="line">                                                    .drive(onNext: &#123;</span><br><span class="line">                                                        [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">                                                        <span class="keyword">self</span>?.showAlert(title: <span class="string">"<span class="subst">\(row)</span>"</span>,</span><br><span class="line">                                                            msg: element)</span><br><span class="line">                                                        &#125;</span><br><span class="line">                                                    )</span><br><span class="line">                                                    .disposed(by: cell.disposeBag)</span><br><span class="line">                                                <span class="keyword">return</span> cell</span><br><span class="line">                                        &#125;</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显示弹出框信息</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showAlert</span><span class="params">(title: String, msg: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> alert = <span class="type">UIAlertController</span>(title: title,</span><br><span class="line">                                      message: msg,</span><br><span class="line">                                      preferredStyle: .alert)</span><br><span class="line">        alert.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"sure"</span>,</span><br><span class="line">                                      style: .cancel))</span><br><span class="line">        <span class="keyword">self</span>.present(alert,animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TLibSet  第三方账号配置目录</title>
      <link href="/2018/05/18/OC/TLibSet/TLibSet/"/>
      <url>/2018/05/18/OC/TLibSet/TLibSet/</url>
      <content type="html"><![CDATA[<p>直播</p>]]></content>
      
      <categories>
          
          <category> TLibSet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TLibSet </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>BlockChain</title>
      <link href="/2018/05/18/OC/BlockChain/BlockChain/"/>
      <url>/2018/05/18/OC/BlockChain/BlockChain/</url>
      <content type="html"><![CDATA[<p>blockchain  区块链</p>]]></content>
      
      <categories>
          
          <category> BlockChain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BlockChain </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Directory</title>
      <link href="/2018/05/18/OC/Live/Live/"/>
      <url>/2018/05/18/OC/Live/Live/</url>
      <content type="html"><![CDATA[<p>直播</p>]]></content>
      
      <categories>
          
          <category> Live </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Live </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TLibSet  第三方账号配置目录</title>
      <link href="/2018/05/18/OC/Tool/Tool/"/>
      <url>/2018/05/18/OC/Tool/Tool/</url>
      <content type="html"><![CDATA[<p>直播</p>]]></content>
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tool </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Directory</title>
      <link href="/2018/05/18/OC/KLine/KLine/"/>
      <url>/2018/05/18/OC/KLine/KLine/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      <categories>
          
          <category> KLine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KLine </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Lib-ObjectMapper-数据转模型</title>
      <link href="/2018/04/25/Swift/Swift/Lib/ObjectMapper-%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/04/25/Swift/Swift/Lib/ObjectMapper-%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p><a href="https://www.hangge.com/blog/cache/detail_1673.html#" target="_blank" rel="noopener">原文参考</a></p><h1 id="ObjectMapper"><a href="#ObjectMapper" class="headerlink" title="ObjectMapper"></a>ObjectMapper</h1><blockquote><p>ObjectMapper 是一个使用 Swift 语言编写的数据模型转换框架。使用它，我们可以很方便地将模型对象（类和结构体）转换为 JSON，或者根据 JSON 生成对应的模型对象<br>原文出自：<a href="http://www.hangge.com" target="_blank" rel="noopener">www.hangge.com</a>  转载请保留原文链接：<a href="https://www.hangge.com/blog/cache/detail_1673.html" target="_blank" rel="noopener">https://www.hangge.com/blog/cache/detail_1673.html</a></p></blockquote><p><a href="https://github.com/Hearst-DD/ObjectMapper" target="_blank" rel="noopener">Github主页</a></p><h2 id="功能特点"><a href="#功能特点" class="headerlink" title="功能特点"></a>功能特点</h2><ul><li>可以将 JSON 映射到对象</li><li>可以将对象映射到 JSON</li><li>支持嵌套对象（在数组或字典中单独使用）</li><li>支持映射过程中的自定义转换</li><li>支持结构体</li><li>支持 Immutable(目前处于测试阶段)</li></ul><h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><blockquote><p>(若是拖入SDK)工程 -&gt; General -&gt; Embedded Binaries 项，把 iOS 版的 framework 添加进来</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import ObjectMapper</span><br></pre></td></tr></table></figure><h1 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h1><h2 id="CocoaPods库导入"><a href="#CocoaPods库导入" class="headerlink" title="CocoaPods库导入"></a>CocoaPods库导入</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">pod '<span class="type">ObjectMapper'</span></span><br></pre></td></tr></table></figure><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ObjectMapper</span><br></pre></td></tr></table></figure><h2 id="ObjectMapper-的协议-Mappable"><a href="#ObjectMapper-的协议-Mappable" class="headerlink" title="ObjectMapper 的协议 Mappable"></a>ObjectMapper 的协议 Mappable</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YKModel</span>:<span class="title">Mappable</span></span></span><br></pre></td></tr></table></figure><h1 id="Model-amp-Dic相互转换"><a href="#Model-amp-Dic相互转换" class="headerlink" title="Model &amp; Dic相互转换"></a>Model &amp; Dic相互转换</h1><h2 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h2><blockquote><p>要实现映射，我们的模型需要实现 ObjectMapper 的 Mappable 协议，并实现该协议里的如下两个方法</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init?(map: Map)</span><br><span class="line"></span><br><span class="line">mutating func mapping(map: Map)</span><br></pre></td></tr></table></figure><blockquote><p>eg:定义一个用户类（User<br>ObjectMapper 定义了一个 &lt;- 操作符来表示成员对象与 JSON 中属性的相互映射关系</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>: <span class="title">Mappable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> username: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span>?</span><br><span class="line">    <span class="keyword">var</span> weight: <span class="type">Double</span>!</span><br><span class="line">    <span class="keyword">var</span> bestFriend: <span class="type">User</span>?        <span class="comment">// User对象</span></span><br><span class="line">    <span class="keyword">var</span> friends: [<span class="type">User</span>]?         <span class="comment">// Users数组</span></span><br><span class="line">    <span class="keyword">var</span> birthday: <span class="type">Date</span>?</span><br><span class="line">    <span class="keyword">var</span> array: [<span class="type">AnyObject</span>]?</span><br><span class="line">    <span class="keyword">var</span> dictionary: [<span class="type">String</span> : <span class="type">AnyObject</span>] = [:]</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">init</span> () &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">required</span> <span class="keyword">init</span>?(<span class="built_in">map</span>: <span class="type">Map</span>)&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">mapping</span><span class="params">(<span class="built_in">map</span>: Map)</span></span> &#123;</span><br><span class="line">    username    &lt;- <span class="built_in">map</span>[<span class="string">"username"</span>]</span><br><span class="line">        age         &lt;- <span class="built_in">map</span>[<span class="string">"age"</span>]</span><br><span class="line">        weight      &lt;- <span class="built_in">map</span>[<span class="string">"weight"</span>]</span><br><span class="line">        bestFriend  &lt;- <span class="built_in">map</span>[<span class="string">"best_friend"</span>]</span><br><span class="line">        friends     &lt;- <span class="built_in">map</span>[<span class="string">"friends"</span>]</span><br><span class="line">        birthday    &lt;- (<span class="built_in">map</span>[<span class="string">"birthday"</span>], <span class="type">DateTransform</span>())</span><br><span class="line">        array       &lt;- <span class="built_in">map</span>[<span class="string">"arr"</span>]</span><br><span class="line">        dictionary  &lt;- <span class="built_in">map</span>[<span class="string">"dict"</span>]</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="型转为字典"><a href="#型转为字典" class="headerlink" title="型转为字典"></a>型转为字典</h2><blockquote><p>定义了两个 User 对象，其中一个引用另一个。最后将该对象转为字典，并打印出来</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lilei = <span class="type">User</span>()</span><br><span class="line">lilei.username = <span class="string">"李雷"</span></span><br><span class="line">lilei.age = <span class="number">18</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> meimei = <span class="type">User</span>()</span><br><span class="line">meimei.username = <span class="string">"梅梅"</span></span><br><span class="line">meimei.age = <span class="number">17</span></span><br><span class="line">meimei.bestFriend = lilei</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> meimeiDic:[<span class="type">String</span>: <span class="type">Any</span>] = meimei.toJSON()</span><br><span class="line"><span class="built_in">print</span>(meimeiDic)</span><br></pre></td></tr></table></figure><h2 id="模型数组转为字典数组"><a href="#模型数组转为字典数组" class="headerlink" title="模型数组转为字典数组"></a>模型数组转为字典数组</h2><blockquote><p>包含两个 User 对象的数组转换成字典数组</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lilei = <span class="type">User</span>()</span><br><span class="line">lilei.username = <span class="string">"李雷"</span></span><br><span class="line">lilei.age = <span class="number">18</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> meimei = <span class="type">User</span>()</span><br><span class="line">meimei.username = <span class="string">"梅梅"</span></span><br><span class="line">meimei.age = <span class="number">17</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> users = [lilei, meimei]</span><br><span class="line"><span class="keyword">let</span> usersArray:[[<span class="type">String</span>: <span class="type">Any</span>]]  = users.toJSON()</span><br><span class="line"><span class="built_in">print</span>(usersArray)</span><br></pre></td></tr></table></figure><h2 id="字典转为模型"><a href="#字典转为模型" class="headerlink" title="字典转为模型"></a>字典转为模型</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> meimeiDic = [<span class="string">"age"</span>: <span class="number">17</span>, <span class="string">"username"</span>: <span class="string">"梅梅"</span>,</span><br><span class="line">                 <span class="string">"best_friend"</span>: [<span class="string">"age"</span>: <span class="number">18</span>, <span class="string">"username"</span>: <span class="string">"李雷"</span>]]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> meimei = <span class="type">User</span>(<span class="type">JSON</span>: meimeiDic)</span><br></pre></td></tr></table></figure><h2 id="字典数组转为模型数组"><a href="#字典数组转为模型数组" class="headerlink" title="字典数组转为模型数组"></a>字典数组转为模型数组</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> usersArray = [[<span class="string">"age"</span>: <span class="number">17</span>, <span class="string">"username"</span>: <span class="string">"梅梅"</span>],</span><br><span class="line">                  [<span class="string">"age"</span>: <span class="number">18</span>, <span class="string">"username"</span>: <span class="string">"李雷"</span>]]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> users:[<span class="type">User</span>] = <span class="type">Mapper</span>&lt;<span class="type">User</span>&gt;().mapArray(<span class="type">JSONArray</span>: usersArray)</span><br></pre></td></tr></table></figure><h1 id="Model-amp-JSON字符串de相互转换"><a href="#Model-amp-JSON字符串de相互转换" class="headerlink" title="Model &amp; JSON字符串de相互转换"></a>Model &amp; JSON字符串de相互转换</h1><h2 id="模型转为JSON字符串"><a href="#模型转为JSON字符串" class="headerlink" title="模型转为JSON字符串"></a>模型转为JSON字符串</h2><blockquote><p>两个 User 对象，其中一个引用另一个。最后将该对象转为 json 串，并打印出来</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lilei = <span class="type">User</span>()</span><br><span class="line">lilei.username = <span class="string">"李雷"</span></span><br><span class="line">lilei.age = <span class="number">18</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> meimei = <span class="type">User</span>()</span><br><span class="line">meimei.username = <span class="string">"梅梅"</span></span><br><span class="line">meimei.age = <span class="number">17</span></span><br><span class="line">meimei.bestFriend = lilei</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> meimeiJSON:<span class="type">String</span> = meimei.toJSONString()!</span><br><span class="line"><span class="built_in">print</span>(meimeiJSON)</span><br></pre></td></tr></table></figure><h2 id="模型数组转为JSON字符串"><a href="#模型数组转为JSON字符串" class="headerlink" title="模型数组转为JSON字符串"></a>模型数组转为JSON字符串</h2><blockquote><p>将一个包含两个 User 对象的数组转换成字典数组</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lilei = <span class="type">User</span>()</span><br><span class="line">lilei.username = <span class="string">"李雷"</span></span><br><span class="line">lilei.age = <span class="number">18</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> meimei = <span class="type">User</span>()</span><br><span class="line">meimei.username = <span class="string">"梅梅"</span></span><br><span class="line">meimei.age = <span class="number">17</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> users = [lilei, meimei]</span><br><span class="line"><span class="keyword">let</span> json:<span class="type">String</span>  = users.toJSONString()!</span><br><span class="line"><span class="built_in">print</span>(json)</span><br></pre></td></tr></table></figure><h2 id="将JSON字符串转为模型"><a href="#将JSON字符串转为模型" class="headerlink" title="将JSON字符串转为模型"></a>将JSON字符串转为模型</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> meimeiJSON:<span class="type">String</span> = <span class="string">"&#123;\"age\":17,\"username\":\"梅梅\",\"best_friend\":&#123;\"age\":18,\"username\":\"李雷\"&#125;&#125;"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> meimei = <span class="type">User</span>(<span class="type">JSONString</span>: meimeiJSON)</span><br></pre></td></tr></table></figure><h2 id="JSON字符串转为模型数组"><a href="#JSON字符串转为模型数组" class="headerlink" title="JSON字符串转为模型数组"></a>JSON字符串转为模型数组</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="string">"[&#123;\"age\":18,\"username\":\"李雷\"&#125;,&#123;\"age\":17,\"username\":\"梅梅\"&#125;]"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> users:[<span class="type">User</span>] = <span class="type">Mapper</span>&lt;<span class="type">User</span>&gt;().mapArray(<span class="type">JSONString</span>: json)!</span><br></pre></td></tr></table></figure><h1 id="init-map-Map-使用介绍"><a href="#init-map-Map-使用介绍" class="headerlink" title="init?(map: Map)使用介绍"></a>init?(map: Map)使用介绍</h1><blockquote><p>ObjectMapper 通过 Mappable 协议中的 init?(map: Map) 方法来初始化创建对象。我们可以利用这个方法，在对象序列化之前验证 JSON 合法性。在不符合的条件时，返回 nil 阻止映射发生。</p></blockquote><blockquote><p>检测 JSON 数据中是否包含 username 属性</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>: <span class="title">Mappable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> username: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span>?</span><br><span class="line">    <span class="keyword">var</span> weight: <span class="type">Double</span>!</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">init</span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(<span class="built_in">map</span>: <span class="type">Map</span>)&#123;</span><br><span class="line">        <span class="comment">// 检查JSON中是否有"username"属性</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">map</span>.<span class="type">JSON</span>[<span class="string">"username"</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Mappable</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">mapping</span><span class="params">(<span class="built_in">map</span>: Map)</span></span> &#123;</span><br><span class="line">        username    &lt;- <span class="built_in">map</span>[<span class="string">"username"</span>]</span><br><span class="line">        age         &lt;- <span class="built_in">map</span>[<span class="string">"age"</span>]</span><br><span class="line">        weight      &lt;- <span class="built_in">map</span>[<span class="string">"weight"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将 JSON 字符串转为模型数组，并打印出对象个数</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="string">"[&#123;\"age\":18,\"username\":\"李雷\"&#125;,&#123;\"age\":17&#125;]"</span></span><br><span class="line"><span class="keyword">let</span> users:[<span class="type">User</span>] = <span class="type">Mapper</span>&lt;<span class="type">User</span>&gt;().mapArray(<span class="type">JSONString</span>: json)!</span><br><span class="line"><span class="built_in">print</span>(users.<span class="built_in">count</span>)</span><br></pre></td></tr></table></figure><blockquote><p>运行结果如下，可以看到生成的数组中只有 1 个对象，这是由于另一个对象的 username 为空，因此被过滤掉了</p></blockquote>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Lib </category>
          
          <category> ObjectMapper </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>RxSwift+Moya+HandyJSON</title>
      <link href="/2018/04/22/Swift/RxSwift/Func/RxSwift+Moya+HandyJSON%20/"/>
      <url>/2018/04/22/Swift/RxSwift/Func/RxSwift+Moya+HandyJSON%20/</url>
      <content type="html"><![CDATA[<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a href="https://github.com/alibaba/HandyJSON/blob/master/README_cn.md" target="_blank" rel="noopener">alibaba/HandyJSON</a><br><a href="https://blog.csdn.net/lvchenqiang_/article/details/79177444" target="_blank" rel="noopener">原文参考</a></p><h1 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h1><h2 id="Podfile"><a href="#Podfile" class="headerlink" title="Podfile"></a>Podfile</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">pod '<span class="type">Moya'</span>, '~&gt; <span class="number">10.0</span>'</span><br><span class="line"># or </span><br><span class="line">pod '<span class="type">Moya</span>/<span class="type">RxSwift'</span>, '~&gt; <span class="number">10.0</span>'</span><br></pre></td></tr></table></figure><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Moya</span><br></pre></td></tr></table></figure><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><h2 id="定义枚举，存储网络请求"><a href="#定义枚举，存储网络请求" class="headerlink" title="定义枚举，存储网络请求"></a>定义枚举，存储网络请求</h2><blockquote><p>定义一个枚举，存放我们的网络请求</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ApiManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> login(username:<span class="type">String</span>,</span><br><span class="line">               password:<span class="type">String</span>,</span><br><span class="line">                  token:<span class="type">String</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="moya的TargetType协议"><a href="#moya的TargetType协议" class="headerlink" title="moya的TargetType协议"></a>moya的TargetType协议</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ApiManager</span>:<span class="title">TargetType</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> baseURL: <span class="type">URL</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">URL</span>.<span class="keyword">init</span>(string: <span class="type">BaseURL</span>)!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求路径</span></span><br><span class="line">    <span class="keyword">var</span> path:<span class="type">String</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .login(username: <span class="number">_</span>, password:<span class="number">_</span> , token:<span class="number">_</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"login/accountLogin"</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> headers: [<span class="type">String</span>: <span class="type">String</span>]? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//请求的参数</span></span><br><span class="line">    <span class="keyword">var</span> parameters: [<span class="type">String</span>: <span class="type">Any</span>]? &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .login(username: <span class="keyword">let</span> userName, password: <span class="keyword">let</span> pwd, token: <span class="keyword">let</span> token):</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">"account"</span>:userName,<span class="string">"pwd"</span>:pwd,<span class="string">"deviceToken"</span>:token];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///请求方式</span></span><br><span class="line">    <span class="keyword">var</span> method: <span class="type">Moya</span>.<span class="type">Method</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .login(username: <span class="number">_</span>, password: <span class="number">_</span>, token: <span class="number">_</span>):</span><br><span class="line">        <span class="keyword">return</span> .post;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The method used for parameter encoding.</span></span><br><span class="line">    <span class="keyword">var</span> parameterEncoding: <span class="type">ParameterEncoding</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">URLEncoding</span>.<span class="keyword">default</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Provides stub data for use in testing.</span></span><br><span class="line">    <span class="keyword">var</span> sampleData: <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.data(using: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//MARK:task type</span></span><br><span class="line">    <span class="keyword">var</span> task: <span class="type">Task</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> .requestPlain</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> validate: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发起网络请求"><a href="#发起网络请求" class="headerlink" title="发起网络请求"></a>发起网络请求</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> provider = <span class="type">MoyaProvider</span>&lt;<span class="type">ApiManager</span>&gt;();</span><br><span class="line"></span><br><span class="line">   provider.request(.login(username: <span class="string">"haha"</span>, password: <span class="string">"123456"</span>, token: <span class="string">"qwe"</span>)) &#123; (result) <span class="keyword">in</span></span><br><span class="line">          <span class="keyword">if</span> result.error == <span class="literal">nil</span>&#123;</span><br><span class="line">              <span class="type">LLog</span>(result.value);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="处理网络请求"><a href="#处理网络请求" class="headerlink" title="处理网络请求"></a>处理网络请求</h2><blockquote><p>使用HanyJSON处理接口返回数据，因为我们使用RxSwift,在处理网络请求，所有我们是对ObservableType 数据类型 扩展mapModel</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ObservableType</span> <span class="title">where</span> <span class="title">E</span> == <span class="title">Response</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">mapModel</span>&lt;T: HandyJSON&gt;<span class="params">(<span class="number">_</span> type: T.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> flatMap &#123; response -&gt; <span class="type">Observable</span>&lt;<span class="type">T</span>&gt; <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Observable</span>.just(response.mapModel(<span class="type">T</span>.<span class="keyword">self</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">mapModel</span>&lt;T: HandyJSON&gt;<span class="params">(<span class="number">_</span> type: T.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> jsonString = <span class="type">String</span>.<span class="keyword">init</span>(data: data, encoding: .utf8)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">JSONDeserializer</span>&lt;<span class="type">T</span>&gt;.deserializeFrom(json: jsonString)!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="调用示例"><a href="#调用示例" class="headerlink" title="调用示例"></a>调用示例</h1><h2 id="使用provider异步请求，并处理返回数据"><a href="#使用provider异步请求，并处理返回数据" class="headerlink" title="使用provider异步请求，并处理返回数据"></a>使用provider异步请求，并处理返回数据</h2><blockquote><p>接口请求完成后， subscribe 会收到next和complete两个事件 当event.element不为空时即为next事件</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">provider.rx.request(.login(username: <span class="string">"151xxxxxxxxxx"</span>, password: <span class="string">"123456"</span>, token: <span class="string">""</span>)).asObservable().mapModel(<span class="type">LoginResponseModel</span> .<span class="keyword">self</span>).subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">             <span class="comment">//当event.element 不为空时，返回的就是我们之前mapModel的类</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> model = event.element&#123;</span><br><span class="line">                 <span class="type">LLog</span>(model.data.accessToken);</span><br><span class="line">                 <span class="type">LLog</span>(model.data.crowdToken);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">LLog</span>(<span class="string">"当前事件:<span class="subst">\(event)</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;.disposed(by: disposeBag);</span><br></pre></td></tr></table></figure><blockquote><p>直接处理next事件，error和completed分开处理</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">provider.rx.request(.login(username: <span class="string">"15136176473"</span>, password: <span class="string">"123456"</span>, token: <span class="string">""</span>)).asObservable().mapModel(<span class="type">LoginResponseModel</span> .<span class="keyword">self</span>).subscribe(onNext: &#123; (model) <span class="keyword">in</span></span><br><span class="line">            <span class="type">LLog</span>(model.data.crowdToken)</span><br><span class="line">        &#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line">            <span class="type">LLog</span>(<span class="string">"请求出错"</span>)</span><br><span class="line">        &#125;, onCompleted: <span class="literal">nil</span>, onDisposed: <span class="literal">nil</span>).disposed(by: disposeBag);</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public init(endpointClosure: @escaping EndpointClosure = MoyaProvider.defaultEndpointMapping,</span><br><span class="line">               requestClosure: @escaping RequestClosure = MoyaProvider.defaultRequestMapping,</span><br><span class="line">               stubClosure: @escaping StubClosure = MoyaProvider.neverStub,</span><br><span class="line">               callbackQueue: DispatchQueue? = nil,</span><br><span class="line">               manager: Manager = MoyaProvider&lt;Target&gt;.defaultAlamofireManager(),</span><br><span class="line">               plugins: [PluginType] = [],</span><br><span class="line">               trackInflights: Bool = false) &#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="Moya"><a href="#Moya" class="headerlink" title="Moya"></a>Moya</h1><blockquote><p>Moya是一个比较全面的好用的网络管理工具,在上面我们只是使用了部分功能。通过provider的初始化，我们可以发现在开发中我们还可以处理很多。比如：</p></blockquote><h2 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h2><blockquote><p>Moya 的插件机制也很好用，提供了以下接口:</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Called to modify a request before sending</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">prepare</span><span class="params">(<span class="number">_</span> request: URLRequest, target: TargetType)</span></span> -&gt; <span class="type">URLRequest</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/// Called immediately before a request is sent over the network (or stubbed).</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">willSend</span><span class="params">(<span class="number">_</span> request: RequestType, target: TargetType)</span></span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/// Called after a response has been received, but before the MoyaProvider has invoked its completion handler.</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(<span class="number">_</span> result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType)</span></span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/// Called to modify a result before completion</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(<span class="number">_</span> result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Moya</span>.<span class="type">Response</span>, <span class="type">MoyaError</span>&gt;</span><br></pre></td></tr></table></figure><blockquote><p>与主功能接口脱离，降低了耦合度我们可以再这里处理请求的权限、token、loading等。 例如：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestLoadingPlugin</span>:<span class="title">PluginType</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">willSend</span><span class="params">(<span class="number">_</span> request: RequestType, target: TargetType)</span></span> &#123;</span><br><span class="line">        <span class="type">LLog</span>(<span class="string">"接口开始请求"</span>)</span><br><span class="line">    <span class="keyword">self</span>.showHUD()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(<span class="number">_</span> result: Result&lt;Response, MoyaError&gt;, target: TargetType)</span></span> &#123;</span><br><span class="line">        <span class="type">LLog</span>(<span class="string">"接口请求完成"</span>)</span><br><span class="line">        <span class="keyword">self</span>.dismissHUD();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//MARK:-是否显示请求加载框</span></span><br><span class="line">    <span class="keyword">fileprivate</span>  <span class="function"><span class="keyword">func</span>  <span class="title">showHUD</span><span class="params">(<span class="number">_</span> isShow:Bool = <span class="literal">true</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isShow)&#123;</span><br><span class="line">            <span class="type">SVProgressHUD</span>.show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//MARK:-隐藏请求加载框</span></span><br><span class="line">    <span class="keyword">fileprivate</span>  <span class="function"><span class="keyword">func</span> <span class="title">dismissHUD</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">SVProgressHUD</span>.dismiss();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在provider的初始化注册我们初始化的插件即可</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> provider = <span class="type">MoyaProvider</span>&lt;<span class="type">ApiManager</span>&gt;(plugins:[<span class="type">RequestLoadingPlugin</span>()]);</span><br></pre></td></tr></table></figure><h2 id="请求处理机制"><a href="#请求处理机制" class="headerlink" title="请求处理机制"></a>请求处理机制</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">EndpointClosure</span> = (<span class="type">Target</span>) -&gt; <span class="type">Endpoint</span>&lt;<span class="type">Target</span>&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">RequestClosure</span> = (<span class="type">Endpoint</span>&lt;<span class="type">Target</span>&gt;, @escaping <span class="type">RequestResultClosure</span>) -&gt; <span class="type">Void</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">StubClosure</span> = (<span class="type">Target</span>) -&gt; <span class="type">Moya</span>.<span class="type">StubBehavior</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">RequestResultClosure</span> = (<span class="type">Result</span>&lt;<span class="type">URLRequest</span>, <span class="type">MoyaError</span>&gt;) -&gt; <span class="type">Void</span></span><br></pre></td></tr></table></figure><blockquote><p>从上面的三个闭包中，我们可以看出</p></blockquote><ul><li>EndpointClosure 是输入一个Target 返回一个Endpoint 也就是完成Target-&gt;Endpoint</li></ul><blockquote><p>Endpoint的数据结构</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Endpoint</span>&lt;<span class="title">Target</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">SampleResponseClosure</span> = () -&gt; <span class="type">EndpointSampleResponse</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">let</span> url: <span class="type">String</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">let</span> sampleResponseClosure: <span class="type">SampleResponseClosure</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">let</span> method: <span class="type">Moya</span>.<span class="type">Method</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">let</span> task: <span class="type">Task</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">let</span> httpHeaderFields: [<span class="type">String</span>: <span class="type">String</span>]?</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>初始化的默认值是</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">defaultEndpointMapping</span>(<span class="title">for</span> <span class="title">target</span>: <span class="title">Target</span>) -&gt; <span class="title">Endpoint</span>&lt;<span class="title">Target</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Endpoint</span>(</span><br><span class="line">            url: <span class="type">URL</span>(target: target).absoluteString,</span><br><span class="line">            sampleResponseClosure: &#123; .networkResponse(<span class="number">200</span>, target.sampleData) &#125;,</span><br><span class="line">            method: target.method,</span><br><span class="line">            task: target.task,</span><br><span class="line">            httpHeaderFields: target.headers</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码只是创建并返回Endpoint实例。很多时候，我们可以自定义这个闭包来做更多额外的事情。比如我们处理一些网络状态码、或者结合stub 模拟网络数据等</p></blockquote><ul><li>RequestClosure 是输入一个Endpoint和RequestResultClosure闭包 返回Void<br>RequestClosure主要是实现Endpoint-&gt;NSURLRequest 用于发起真正的网络请求</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">RequestResultClosure</span> = (<span class="type">Result</span>&lt;<span class="type">URLRequest</span>, <span class="type">MoyaError</span>&gt;) -&gt; <span class="type">Void</span></span><br></pre></td></tr></table></figure><blockquote><p>在输入中RequestResultClosure就是对接口请求完成后的返回<br>初始化的默认值是：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">defaultRequestMapping</span>(<span class="title">for</span> <span class="title">endpoint</span>: <span class="title">Endpoint</span>&lt;<span class="title">Target</span>&gt;, <span class="title">closure</span>: <span class="title">RequestResultClosure</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           <span class="keyword">let</span> urlRequest = <span class="keyword">try</span> endpoint.urlRequest()</span><br><span class="line">           closure(.success(urlRequest))</span><br><span class="line">       &#125; <span class="keyword">catch</span> <span class="type">MoyaError</span>.requestMapping(<span class="keyword">let</span> url) &#123;</span><br><span class="line">           closure(.failure(<span class="type">MoyaError</span>.requestMapping(url)))</span><br><span class="line">       &#125; <span class="keyword">catch</span> <span class="type">MoyaError</span>.parameterEncoding(<span class="keyword">let</span> error) &#123;</span><br><span class="line">           closure(.failure(<span class="type">MoyaError</span>.parameterEncoding(error)))</span><br><span class="line">       &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">           closure(.failure(<span class="type">MoyaError</span>.underlying(error, <span class="literal">nil</span>)))</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里就是处理最后的urlRequest。如果你想设置全局的urlRequest，这里也是最后的机会了。我们可以再这里修改请求的超时时间、缓存策略、cookie等。<br>示例：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> requestClosure = &#123; (endpoint: <span class="type">Endpoint</span>&lt;<span class="type">ApiManager</span>&gt;, closure: (<span class="type">Result</span>&lt;<span class="type">URLRequest</span>, <span class="type">MoyaError</span>&gt;) -&gt; <span class="type">Void</span>)  -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">var</span>  urlRequest = <span class="keyword">try</span> endpoint.urlRequest()</span><br><span class="line">            urlRequest.timeoutInterval = <span class="number">30.0</span></span><br><span class="line">            urlRequest.cachePolicy = .reloadIgnoringLocalAndRemoteCacheData</span><br><span class="line">            urlRequest.httpShouldHandleCookies = <span class="literal">false</span></span><br><span class="line">            closure(.success(urlRequest))</span><br><span class="line">        &#125; <span class="keyword">catch</span> <span class="type">MoyaError</span>.requestMapping(<span class="keyword">let</span> url) &#123;</span><br><span class="line">            closure(.failure(<span class="type">MoyaError</span>.requestMapping(url)))</span><br><span class="line">        &#125; <span class="keyword">catch</span> <span class="type">MoyaError</span>.parameterEncoding(<span class="keyword">let</span> error) &#123;</span><br><span class="line">            closure(.failure(<span class="type">MoyaError</span>.parameterEncoding(error)))</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            closure(.failure(<span class="type">MoyaError</span>.underlying(error, <span class="literal">nil</span>)))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> provider = <span class="type">MoyaProvider</span>&lt;<span class="type">ApiManager</span>&gt;(requestClosure:requestClosure,plugins:[<span class="type">RequestLoadingPlugin</span>()]);</span><br></pre></td></tr></table></figure><ul><li>StubClosure 是输入一个Target 返回一个StubBehavior的闭包。</li><li>默认是：neverStub</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">StubClosure</span> = (<span class="type">Target</span>) -&gt; <span class="type">Moya</span>.<span class="type">StubBehavior</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">StubBehavior</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 不使用Stub来返回模拟的网络数据   </span></span><br><span class="line">     <span class="keyword">case</span> never</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 立刻返回Stub的数据</span></span><br><span class="line">    <span class="keyword">case</span> immediate</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 在几秒后返回stub的数据</span></span><br><span class="line">    <span class="keyword">case</span> delayed(seconds: <span class="type">TimeInterval</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h1><blockquote><p>编写测试数据</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ApiManager</span>:<span class="title">TargetType</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Provides stub data for use in testing.</span></span><br><span class="line">    <span class="keyword">var</span> sampleData: <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .login(username: <span class="number">_</span>, password: <span class="number">_</span>, token: <span class="number">_</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&#123;'code': 200,'Token':'123455'&#125;"</span>.data(using: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)!</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>.data(using: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>初始化EndpointClosure</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> endPointAction = &#123; (target: <span class="type">ApiManager</span>) -&gt; <span class="type">Endpoint</span>&lt;<span class="type">ApiManager</span>&gt; <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> url = target.baseURL.appendingPathComponent(target.path).absoluteString</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> target &#123;</span><br><span class="line">    <span class="keyword">case</span> .login(username: <span class="number">_</span>, password:<span class="number">_</span> , token:<span class="number">_</span>):</span><br><span class="line">        <span class="keyword">return</span>  <span class="type">Endpoint</span>(</span><br><span class="line">            url: url,</span><br><span class="line">            sampleResponseClosure: &#123; .networkResponse(<span class="number">200</span>, target.sampleData) &#125;,</span><br><span class="line">            method: target.method,</span><br><span class="line">            task: target.task,</span><br><span class="line">            httpHeaderFields: target.headers</span><br><span class="line">        )&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>初始化StubClosure</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stubAction: (<span class="number">_</span> type:<span class="type">ApiManager</span>) -&gt; <span class="type">Moya</span>.<span class="type">StubBehavior</span> = &#123; type <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> type &#123;</span><br><span class="line">    <span class="keyword">case</span> .login(username: <span class="number">_</span>, password:<span class="number">_</span> , token:<span class="number">_</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Moya</span>.<span class="type">StubBehavior</span>.delayed(seconds: <span class="number">3.0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>初始化provider</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> provider = <span class="type">MoyaProvider</span>&lt;<span class="type">ApiManager</span>&gt;(endpointClosure:endPointAction,requestClosure:_requestClosure,stubClosure:stubAction,plugins:[<span class="type">RequestLoadingPlugin</span>()]);</span><br></pre></td></tr></table></figure><h1 id="Manager"><a href="#Manager" class="headerlink" title="Manager"></a>Manager</h1><blockquote><p>Moya本身并不是直接处理网络请求的第三方库。它只是一个抽象的网络层，对真正发起网络请求的Manager进行管理：例如Alamofire<br>默认参数:</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">defaultAlamofireManager</span>() -&gt; <span class="title">Manager</span> </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> configuration = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span></span><br><span class="line">        configuration.httpAdditionalHeaders = <span class="type">Manager</span>.defaultHTTPHeaders</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> manager = <span class="type">Manager</span>(configuration: configuration)</span><br><span class="line">        manager.startRequestsImmediately = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> manager</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>封装Alamofire,使Moya.Manager == Alamofire.SessionManager</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Manager</span> = <span class="type">Alamofire</span>.<span class="type">SessionManager</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">typealias</span> <span class="type">Request</span> = <span class="type">Alamofire</span>.<span class="type">Request</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">typealias</span> <span class="type">DownloadRequest</span> = <span class="type">Alamofire</span>.<span class="type">DownloadRequest</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">typealias</span> <span class="type">UploadRequest</span> = <span class="type">Alamofire</span>.<span class="type">UploadRequest</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">typealias</span> <span class="type">DataRequest</span> = <span class="type">Alamofire</span>.<span class="type">DataRequest</span></span><br></pre></td></tr></table></figure><blockquote><p>所以，当我们想要定义自己的Manager，我们也可以传入自己的Manager到Moya的provider中。<br>示例</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> policies: [<span class="type">String</span>: <span class="type">ServerTrustPolicy</span>] = [</span><br><span class="line">    <span class="string">"example.com"</span>: .<span class="type">PinPublicKeys</span>(</span><br><span class="line">        publicKeys: <span class="type">ServerTrustPolicy</span>.publicKeysInBundle(),</span><br><span class="line">        validateCertificateChain: <span class="literal">true</span>,</span><br><span class="line">        validateHost: <span class="literal">true</span></span><br><span class="line">    )</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> policies: [<span class="type">String</span>: <span class="type">ServerTrustPolicy</span>] = [</span><br><span class="line">    <span class="string">"example.com"</span>: .pinPublicKeys(</span><br><span class="line">        publicKeys: <span class="type">ServerTrustPolicy</span>.publicKeys(),</span><br><span class="line">        validateCertificateChain: <span class="literal">true</span>,</span><br><span class="line">        validateHost: <span class="literal">true</span></span><br><span class="line">    )</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manager:<span class="type">Manager</span> = <span class="type">Manager</span>(configuration: <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span>, delegate: <span class="type">SessionDelegate</span>(), serverTrustPolicyManager: <span class="type">ServerTrustPolicyManager</span>(policies: policies))</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> provider = <span class="type">MoyaProvider</span>&lt;<span class="type">ApiManager</span>&gt;(manager: manager)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Func </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Func </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-ControlFlow控制流</title>
      <link href="/2018/04/14/Swift/Swift/Grammar/ControlFlow%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
      <url>/2018/04/14/Swift/Swift/Grammar/ControlFlow%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
      <content type="html"><![CDATA[<ul><li>For-In 循环</li></ul><h1 id="For-In-循环"><a href="#For-In-循环" class="headerlink" title="For-In 循环"></a>For-In 循环</h1><blockquote><p>❶for-in -&gt;数组中的元素</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span>  names &#123;</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">"-------- <span class="subst">\(name)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>❷or-in -&gt;字典<br>遍历字典时，字典的每项元素会以 (key, value) 元组的形式返回<br>for-in 循环中使用显式的常量名称来解读 (key, value) 元组</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numberOfLegs = [<span class="string">"spider"</span>: <span class="number">8</span>, </span><br><span class="line">                    <span class="string">"ant"</span>: <span class="number">6</span>, </span><br><span class="line">                    <span class="string">"cat"</span>: <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> (animalName, legCount) <span class="keyword">in</span> numberOfLegs &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(animalName)</span>s have <span class="subst">\(legCount)</span> legs"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字典的内容理论上是无序的</span></span><br></pre></td></tr></table></figure><blockquote><p>❸ for-in 循环还可以使用数字范围</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(index)</span> times 5 is <span class="subst">\(index * <span class="number">5</span>)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 times 5 is 5</span></span><br><span class="line"><span class="comment">// 2 times 5 is 10</span></span><br><span class="line"><span class="comment">// 3 times 5 is 15</span></span><br><span class="line"><span class="comment">// 4 times 5 is 20</span></span><br><span class="line"><span class="comment">// 5 times 5 is 25</span></span><br></pre></td></tr></table></figure><ul><li>用来进行遍历的元素是使用闭区间操作符（…）表示的从 1 到 5 的数字区间</li><li>index 是一个每次循环遍历开始时被自动赋值的常量</li><li></li></ul><blockquote><p>❹</p></blockquote>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Grammar </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-目录</title>
      <link href="/2018/04/11/Swift/Swift/Grammar/%E7%9B%AE%E5%BD%95/Swift-Grammar-%E7%9B%AE%E5%BD%95/"/>
      <url>/2018/04/11/Swift/Swift/Grammar/%E7%9B%AE%E5%BD%95/Swift-Grammar-%E7%9B%AE%E5%BD%95/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
          <category> Swift4.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Grammar </tag>
            
            <tag> Swift4.0 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-Lib-目录</title>
      <link href="/2018/04/07/Swift/RxSwift/Lib/RxSwift-Lib-%E7%9B%AE%E5%BD%95/"/>
      <url>/2018/04/07/Swift/RxSwift/Lib/RxSwift-Lib-%E7%9B%AE%E5%BD%95/</url>
      <content type="html"><![CDATA[<ul><li><a href="https://blockchain520.github.io/2018/03/07/Swift/RxSwift/Lib/Moya%20-%E7%BD%91%E7%BB%9C%E5%B0%81%E8%A3%85(RxSwift" target="_blank" rel="noopener">Moya-网络封装RxSwift</a>/)</li><li><a href="https://blockchain520.github.io/2018/03/07/Swift/RxSwift/Lib/RxSwift-Lib-Moya/" target="_blank" rel="noopener">Moya</a></li></ul>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-MVVM-Login 登录注册</title>
      <link href="/2018/04/06/Swift/RxSwift/Demo/RxSwift-MVVM-Login%E7%AE%80%E5%8D%95%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C/"/>
      <url>/2018/04/06/Swift/RxSwift/Demo/RxSwift-MVVM-Login%E7%AE%80%E5%8D%95%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C/</url>
      <content type="html"><![CDATA[<ul><li><a href="#1">需求</a></li><li><a href="#2">需求</a></li></ul><h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><h2 id="注册界面需求"><a href="#注册界面需求" class="headerlink" title="注册界面需求"></a>注册界面需求</h2><ul><li>输入用户名必须大于等于6个字符，不然密码不能输入；</li><li>密码必须大于等于6个字符，不然重复密码不能输入；</li><li>重复密码和密码必须一样， 不能注册按钮不能点击；</li><li>点击注册按钮，提示注册成功或者注册失败；</li><li>注册成功会写进本地的plist文件，然后输入用户名会检测该用户名是否已注册</li></ul><h2 id="登录界面需求"><a href="#登录界面需求" class="headerlink" title="登录界面需求"></a>登录界面需求</h2><ul><li>点击输入用户名，检测是否已存在，如果存在，户名可用，否则提示用户名不存在；</li><li>输入密码，点击登录，如果密码错则提示密码错误，否则进入列表界面，提示登录成功</li></ul><h1 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h1><h2 id="①UI-ViewController-swift"><a href="#①UI-ViewController-swift" class="headerlink" title="①UI-ViewController.swift"></a>①UI-ViewController.swift</h2><ul><li>懒加载+封装初始化UI</li></ul><blockquote><p>❶用户名 - 标题-Title - lab</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> userNameLab: <span class="type">UILabel</span> = &#123;</span><br><span class="line">      <span class="keyword">let</span> userNameLab = <span class="type">UILabel</span>()</span><br><span class="line">      userNameLab.frame = <span class="type">CGRect</span>(x:<span class="number">40</span>,y:<span class="number">100</span>,width:<span class="number">80</span>,height:<span class="number">30</span>)</span><br><span class="line">      userNameLab.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">14</span>)</span><br><span class="line">      userNameLab.text = <span class="string">"用户名"</span></span><br><span class="line">      <span class="keyword">return</span> userNameLab</span><br><span class="line">  &#125;()</span><br></pre></td></tr></table></figure><blockquote><p>❷用户名 -输入框-TF</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> userNameTextField: <span class="type">UITextField</span> = &#123;</span><br><span class="line">      <span class="keyword">let</span> userNameTextField = <span class="type">UITextField</span>()</span><br><span class="line">      userNameTextField.frame = <span class="type">CGRect</span>(x:<span class="number">40</span>+<span class="number">80</span>+<span class="number">10</span>,y:<span class="number">100</span>,width:<span class="number">160</span>,height:<span class="number">30</span>)</span><br><span class="line">      userNameTextField.placeholder = <span class="string">"输入不少于6位用户名"</span></span><br><span class="line">      userNameTextField.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">14</span>)</span><br><span class="line">      <span class="keyword">return</span> userNameTextField</span><br><span class="line">  &#125;()</span><br></pre></td></tr></table></figure><blockquote><p>❸用户名 - 输入提示-lab</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> userNameInputLab: <span class="type">UILabel</span> = &#123;</span><br><span class="line">     <span class="keyword">let</span> userNameInputLab = <span class="type">UILabel</span>()</span><br><span class="line">     userNameInputLab.frame = <span class="type">CGRect</span>(x:<span class="number">40</span>+<span class="number">80</span>+<span class="number">10</span>,y:<span class="number">100</span>+<span class="number">30</span>+<span class="number">10</span>,width:<span class="number">100</span>,height:<span class="number">20</span>)</span><br><span class="line">     userNameInputLab.text = <span class="string">"用户名至少6位"</span></span><br><span class="line">     userNameInputLab.textColor = <span class="type">UIColor</span>.red</span><br><span class="line">     userNameInputLab.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>)</span><br><span class="line">     <span class="keyword">return</span> userNameInputLab</span><br><span class="line"> &#125;()</span><br></pre></td></tr></table></figure><blockquote><p> 密码-标题-Lab</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> passWordLab: <span class="type">UILabel</span> = &#123;</span><br><span class="line">      <span class="keyword">let</span> passWordLab = <span class="type">UILabel</span>()</span><br><span class="line">      passWordLab.frame = <span class="type">CGRect</span>(x:<span class="number">40</span>,y:<span class="number">200</span>,width:<span class="number">80</span>,height:<span class="number">30</span>)</span><br><span class="line">      passWordLab.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">14</span>)</span><br><span class="line">      passWordLab.text = <span class="string">"密码"</span></span><br><span class="line">      <span class="keyword">return</span> passWordLab</span><br><span class="line">  &#125;()</span><br></pre></td></tr></table></figure><blockquote><p>密码- 输入- TF</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> passWordTextField:<span class="type">UITextField</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> passWordTextField = <span class="type">UITextField</span>()</span><br><span class="line">    passWordTextField.frame = <span class="type">CGRect</span>(x:<span class="number">40</span>+<span class="number">80</span>+<span class="number">10</span>,y:<span class="number">200</span>,width:<span class="number">100</span>,height:<span class="number">30</span>)</span><br><span class="line">    passWordTextField.placeholder = <span class="string">"请填输入密码"</span></span><br><span class="line">    passWordTextField.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">14</span>)</span><br><span class="line">    <span class="keyword">return</span> passWordTextField</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><blockquote><p>密码 - 输入提示-lab</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> passWordInputLab: <span class="type">UILabel</span> = &#123;</span><br><span class="line">      <span class="keyword">let</span> passWordInputLab = <span class="type">UILabel</span>()</span><br><span class="line">      passWordInputLab.frame = <span class="type">CGRect</span>(x:<span class="number">40</span>+<span class="number">80</span>+<span class="number">10</span>,y:<span class="number">200</span>+<span class="number">30</span>+<span class="number">10</span>,width:<span class="number">100</span>,height:<span class="number">20</span>)</span><br><span class="line">      passWordInputLab.text = <span class="string">"用户名至少6位"</span></span><br><span class="line">      passWordInputLab.textColor = <span class="type">UIColor</span>.red</span><br><span class="line">      passWordInputLab.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>)</span><br><span class="line">      <span class="keyword">return</span> passWordInputLab</span><br><span class="line">  &#125;()</span><br></pre></td></tr></table></figure><blockquote><p>密码检验 - 标题 - Lab</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> checkPassWordLab: <span class="type">UILabel</span> = &#123;</span><br><span class="line">     <span class="keyword">let</span> checkPassWordLab = <span class="type">UILabel</span>()</span><br><span class="line">     checkPassWordLab.frame = <span class="type">CGRect</span>(x:<span class="number">40</span>,y:<span class="number">300</span>,width:<span class="number">80</span>,height:<span class="number">30</span>)</span><br><span class="line">     checkPassWordLab.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">14</span>)</span><br><span class="line">     checkPassWordLab.text = <span class="string">"密码检查"</span></span><br><span class="line">     <span class="keyword">return</span> checkPassWordLab</span><br><span class="line"> &#125;()</span><br></pre></td></tr></table></figure><blockquote><p>密码检验 - 输入- TF</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> checkPassWordTextField:<span class="type">UITextField</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> checkPassWordTextField = <span class="type">UITextField</span>()</span><br><span class="line">    checkPassWordTextField.frame = <span class="type">CGRect</span>(x:<span class="number">40</span>+<span class="number">80</span>+<span class="number">10</span>,y:<span class="number">300</span>,width:<span class="number">100</span>,height:<span class="number">30</span>)</span><br><span class="line">    checkPassWordTextField.placeholder = <span class="string">"请再一次输入密码"</span></span><br><span class="line">    checkPassWordTextField.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">14</span>)</span><br><span class="line">    <span class="keyword">return</span> checkPassWordTextField</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><blockquote><p>密码检验 - 输入警告提示-lab</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> checkPassWordInputLab: <span class="type">UILabel</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> checkPassWordInputLab = <span class="type">UILabel</span>()</span><br><span class="line">    checkPassWordInputLab.frame = <span class="type">CGRect</span>(x:<span class="number">40</span>+<span class="number">80</span>+<span class="number">10</span>,y:<span class="number">300</span>+<span class="number">30</span>+<span class="number">10</span>,width:<span class="number">100</span>,height:<span class="number">20</span>)</span><br><span class="line">    checkPassWordInputLab.text = <span class="string">"用户名至少6位"</span></span><br><span class="line">    checkPassWordInputLab.textColor = <span class="type">UIColor</span>.red</span><br><span class="line">    checkPassWordInputLab.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>)</span><br><span class="line">    <span class="keyword">self</span>.view.addSubview(checkPassWordInputLab)</span><br><span class="line">    <span class="keyword">return</span> checkPassWordInputLab</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><blockquote><p>注册 按钮 -Btn</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> registerBtn:<span class="type">UIButton</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> registerBtn = <span class="type">UIButton</span>()</span><br><span class="line">    registerBtn.frame = <span class="type">CGRect</span>(x:<span class="number">40</span>+<span class="number">80</span>+<span class="number">10</span>,y:<span class="number">400</span>,width:<span class="number">100</span>,height:<span class="number">30</span>)</span><br><span class="line">    registerBtn.setTitle(<span class="string">"注册"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">    registerBtn.setTitleColor(<span class="type">UIColor</span>.green, <span class="keyword">for</span>: .normal)</span><br><span class="line">    registerBtn.backgroundColor = <span class="type">UIColor</span>.red</span><br><span class="line">    <span class="keyword">return</span> registerBtn</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><blockquote><p>登录 - 按钮 -Btn</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> loginBtn:<span class="type">UIButton</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> loginBtn = <span class="type">UIButton</span>()</span><br><span class="line">    loginBtn.frame = <span class="type">CGRect</span>(x:<span class="number">40</span>+<span class="number">80</span>+<span class="number">10</span>,y:<span class="number">500</span>,width:<span class="number">100</span>,height:<span class="number">30</span>)</span><br><span class="line">    loginBtn.setTitle(<span class="string">"登录"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">    loginBtn.setTitleColor(<span class="type">UIColor</span>.green, <span class="keyword">for</span>: .normal)</span><br><span class="line">    loginBtn.backgroundColor = <span class="type">UIColor</span>.red</span><br><span class="line">    loginBtn.addTarget(<span class="keyword">self</span>, action: #selector(showNextCtl), <span class="keyword">for</span>: <span class="type">UIControlEvents</span>.touchUpInside)</span><br><span class="line">    <span class="keyword">return</span> loginBtn</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h2 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h2><blockquote><p>注册完毕–&gt;去登录界面</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showNextCtl</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">let</span> viewCtl = <span class="type">LoginViewCtl</span>()</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">"21312312312"</span>)</span><br><span class="line">     navigationController?.pushViewController(viewCtl, animated: <span class="literal">true</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="DisposeBag"><a href="#DisposeBag" class="headerlink" title="DisposeBag"></a>DisposeBag</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br></pre></td></tr></table></figure><h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><blockquote><p> 声明 RegisterViewModel </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> viewModel = <span class="type">RegisterViewModel</span>()</span><br></pre></td></tr></table></figure><h2 id="viewDidLoad"><a href="#viewDidLoad" class="headerlink" title="viewDidLoad"></a>viewDidLoad</h2><h3 id="UI加载"><a href="#UI加载" class="headerlink" title="UI加载"></a>UI加载</h3><blockquote><p>UI加载</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initUI</span><span class="params">()</span></span>&#123;</span><br><span class="line">    view.backgroundColor = <span class="type">UIColor</span>.white</span><br><span class="line">    view.addSubview(userNameLab)</span><br><span class="line">    view.addSubview(userNameTextField)</span><br><span class="line">    view.addSubview(userNameInputLab)</span><br><span class="line">    </span><br><span class="line">    view.addSubview(passWordLab)</span><br><span class="line">    view.addSubview(passWordTextField)</span><br><span class="line">    view.addSubview(passWordInputLab)</span><br><span class="line">    </span><br><span class="line">    view.addSubview(checkPassWordLab)</span><br><span class="line">    view.addSubview(checkPassWordTextField)</span><br><span class="line">    view.addSubview(checkPassWordLab)</span><br><span class="line">    </span><br><span class="line">    view.addSubview(registerBtn)</span><br><span class="line">    view.addSubview(loginBtn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UI控件-绑定"><a href="#UI控件-绑定" class="headerlink" title="UI控件 绑定"></a>UI控件 绑定</h3><ul><li>①usernameTextField.rx.text.orEmpty,usernameTextField.rx.text.orEmpty是Rx中的东西，他把TextFiled的text变成了一个Observable， 后面的orEmpty我们可以Command点进去看下，他会把String?过滤nil帮我们变为String类型</li><li>②bind:bind里面里面的就是监听者也就是Observer,username既是一个observable也是一个observer,此时把他当成一个Observer绑定到usernameTextFiled上，监听我们的usernameTextField流</li><li>③因为有监听，就要有监听资源的回收，so,创建一个disposeBag来盛放这些监听资源</li></ul><blockquote><p>绑定 用户名</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">userNameTextField.rx</span><br><span class="line">                 .text</span><br><span class="line">                 .orEmpty     <span class="comment">// ①</span></span><br><span class="line">                 .bind(to: viewModel.userNameVariable)  <span class="comment">// ②</span></span><br><span class="line">                 .disposed(by: disposeBag)         <span class="comment">// ③</span></span><br></pre></td></tr></table></figure><blockquote><p>绑定  密码</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">passWordTextField.rx</span><br><span class="line">                 .text</span><br><span class="line">                 .orEmpty</span><br><span class="line">                 .bind(to: viewModel.passWordVariable)</span><br><span class="line">                 .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><blockquote><p>绑定 检测 密码</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">checkPassWordTextField.rx</span><br><span class="line">                      .text</span><br><span class="line">                      .orEmpty</span><br><span class="line">                      .bind(to: viewModel.checkPassWordVariable)</span><br><span class="line">                      .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><blockquote><p>绑定 注册 按钮</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">registerBtn.rx</span><br><span class="line">           .tap</span><br><span class="line">           .bind(to: viewModel.registerTaps)<span class="comment">//registerTaps来判断 如果满足注册条件</span></span><br><span class="line">           .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h2 id="mdoel相关Variable"><a href="#mdoel相关Variable" class="headerlink" title="mdoel相关Variable"></a>mdoel相关Variable</h2><ul><li>① 被观察者</li><li>② userNameInputLab.rx.validationResult作为一个observer(观察者)观察userNameUsable上的内容变化<pre><code>将ViewModel中username处理结果usernameUseable绑定到nameLabel显示文案上，根据不同的结果显示不同的文案</code></pre></li></ul><h3 id="用户名"><a href="#用户名" class="headerlink" title="用户名"></a>用户名</h3><blockquote><p>监听 用户名输入</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">viewModel.userNameUsable <span class="comment">// ① 被观察者</span></span><br><span class="line">         .bind(to: userNameInputLab.rx.validationResult)   <span class="comment">// ②</span></span><br><span class="line">         .disposed(by: disposeBag)  <span class="comment">// ③</span></span><br></pre></td></tr></table></figure><blockquote><p>监听 用户名是否可输入</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">viewModel.userNameUsable</span><br><span class="line">         .bind(to: passWordTextField.rx.inputEnabled)</span><br><span class="line">         .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h3 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h3><blockquote><p>监听  密码 输入提示</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">viewModel.passWordUsable</span><br><span class="line">         .bind(to: passWordInputLab.rx.validationResult)</span><br><span class="line">         .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><blockquote><p>监听 密码 是否可输入</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">viewModel.passWordUsable</span><br><span class="line">         .bind(to: checkPassWordTextField.rx.inputEnabled)</span><br><span class="line">         .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h3 id="检测密码"><a href="#检测密码" class="headerlink" title="检测密码"></a>检测密码</h3><blockquote><p>监听 检测密码 输入</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">viewModel.checkPassWordUsable</span><br><span class="line">         .bind(to: checkPassWordInputLab.rx.validationResult)</span><br><span class="line">         .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><blockquote><p>监听 注册 enable<br>队列信号 –&gt;执行具体变化</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">viewModel.registerBtnEnabled</span><br><span class="line">         .subscribe(onNext:&#123;[<span class="keyword">unowned</span> <span class="keyword">self</span>] valid <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.registerBtn.isEnabled = valid</span><br><span class="line">                <span class="keyword">self</span>.registerBtn.alpha = valid ? <span class="number">1.0</span> : <span class="number">0.5</span></span><br><span class="line">                   &#125;)</span><br><span class="line">         .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><blockquote><p>注册结果处理</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">viewModel.registerResult</span><br><span class="line">         .subscribe(onNext:&#123; [<span class="keyword">weak</span> <span class="keyword">self</span>](result) <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">switch</span> result &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="keyword">let</span> .ok(msgStr):</span><br><span class="line">                    <span class="keyword">self</span>?.showAlert(msgStr: msgStr)</span><br><span class="line">                <span class="keyword">case</span> .empty:</span><br><span class="line">                    <span class="keyword">self</span>?.showAlert(msgStr: <span class="string">""</span>)</span><br><span class="line">                <span class="keyword">case</span> <span class="keyword">let</span> .failed(msgStr):</span><br><span class="line">                    <span class="keyword">self</span>?.showAlert(msgStr: msgStr)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">         .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><blockquote><p>alet提示 注册结果</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showAlert</span><span class="params">(msgStr:String)</span></span>&#123;</span><br><span class="line">     <span class="keyword">let</span> acton = <span class="type">UIAlertAction</span>(title:<span class="string">"确定"</span>,</span><br><span class="line">                               style: .<span class="keyword">default</span>,</span><br><span class="line">                               handler:<span class="literal">nil</span>)</span><br><span class="line">     <span class="keyword">let</span> alertViewCtl = <span class="type">UIAlertController</span>(title:<span class="literal">nil</span>,</span><br><span class="line">                                          message:msgStr,</span><br><span class="line">                                          preferredStyle: .alert)</span><br><span class="line">     alertViewCtl.addAction(acton)</span><br><span class="line">     present(alertViewCtl,</span><br><span class="line">             animated: <span class="literal">true</span>,</span><br><span class="line">             completion: <span class="literal">nil</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="Service网络请求"><a href="#Service网络请求" class="headerlink" title="Service网络请求"></a>Service网络请求</h1><blockquote><p>Service文件主要负责一些网络请求，和一些数据访问的操作<br>然后供 <strong>ViewModel</strong>使用，模拟从本地plist文件中读取用户数据</p></blockquote><h2 id="ValidationService类中，检测username的方法"><a href="#ValidationService类中，检测username的方法" class="headerlink" title="ValidationService类中，检测username的方法"></a>ValidationService类中，检测username的方法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">init</span> ()&#123;&#125;  <span class="comment">//初始化？？</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span>  instance = <span class="type">ValidationService</span>()  <span class="comment">// 单例类</span></span><br><span class="line"><span class="keyword">let</span> minCharacterCount = <span class="number">6</span>  <span class="comment">// 设置输入最小位数</span></span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><blockquote><p>① Method:对输入用户名 判断<br>返回一个Observable对象，因为这个请求过程需要被监听</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateUsername</span><span class="params">(<span class="number">_</span> userNameStr: String)</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">Result</span>&gt;  &#123;</span><br><span class="line">    <span class="comment">/*just是创建一个sequence只能发出一种特定的事件，能正常结束</span></span><br><span class="line"><span class="comment">     next(🔴)</span></span><br><span class="line"><span class="comment">     completed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//❶判断-是否为空 当字符等于0的时候什么都不做</span></span><br><span class="line">    <span class="keyword">if</span> userNameStr.<span class="built_in">count</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .just(.empty)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//❷判断-长度</span></span><br><span class="line">    <span class="keyword">if</span> userNameStr.<span class="built_in">count</span> &lt; minCharacterCount &#123;</span><br><span class="line">        <span class="keyword">return</span> .just(.failed(message: <span class="string">"大哥至少6位啊"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//❸判断- 检查plist文件中是否有该用户名</span></span><br><span class="line">    <span class="keyword">if</span> userNameValid(userNameStr) &#123;</span><br><span class="line">        <span class="keyword">return</span> .just(.failed(message: <span class="string">"账户已存在"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//❹判断- 返回可用</span></span><br><span class="line">    <span class="keyword">return</span> .just(.ok(message: <span class="string">"用户名可用"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>②Method: 从本地数据库中检测 用户名 是否已经存在</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">userNameValid</span><span class="params">(<span class="number">_</span> userNameStr: String)</span></span> -&gt;<span class="type">Bool</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> filePath = <span class="type">NSHomeDirectory</span>()+<span class="string">"/Documents/users.plist"</span></span><br><span class="line">      <span class="keyword">let</span> userDic = <span class="type">NSDictionary</span>(contentsOfFile:filePath)</span><br><span class="line">      <span class="keyword">let</span>  userNameArray = userDic?.allKeys</span><br><span class="line">      <span class="keyword">guard</span> userNameArray != <span class="literal">nil</span></span><br><span class="line">          <span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (userNameArray! <span class="keyword">as</span> <span class="type">NSArray</span>).<span class="built_in">contains</span>(userNameStr) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>③Method: 检测 密码长度 -&gt; Result</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validatePassWord</span><span class="params">(<span class="number">_</span> passWordStr: String)</span></span>-&gt; <span class="type">Result</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> passWordStr.<span class="built_in">count</span> == <span class="number">0</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> .empty</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> passWordStr.<span class="built_in">count</span> &lt; minCharacterCount &#123;</span><br><span class="line">           <span class="keyword">return</span> .failed(message: <span class="string">"密码长度至少6个字符"</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> .ok(message: <span class="string">"密码可用"</span>)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>④ 检测 2次密码是否一致  -&gt; Result</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateCheckPassWord</span><span class="params">(<span class="number">_</span> passWordStr: String,checkPassWordStr:String)</span></span> -&gt; <span class="type">Result</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> checkPassWordStr.<span class="built_in">count</span> == <span class="number">0</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> .empty</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> checkPassWordStr == passWordStr &#123;</span><br><span class="line">         <span class="keyword">return</span> .ok(message:<span class="string">"密码可用"</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> .failed(message: <span class="string">"两次密码不一样"</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>⑤注册函数 -  -&gt; Observable<result></result></p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">register</span><span class="params">(<span class="number">_</span> userNameStr:String,passWordStr:String)</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">Result</span>&gt;  &#123;</span><br><span class="line">       <span class="keyword">let</span> userDic = [userNameStr:passWordStr]</span><br><span class="line">       <span class="keyword">let</span> filePath = <span class="type">NSHomeDirectory</span>() + <span class="string">"/Documents/users.plist"</span></span><br><span class="line">       <span class="keyword">if</span> (userDic <span class="keyword">as</span> <span class="type">NSDictionary</span>).write(toFile: filePath, atomically: <span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> .just(.ok(message: <span class="string">"注册成功"</span>))</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> .just(.failed(message: <span class="string">"注册失败"</span>))</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>⑥登录用户名是否存在 -&gt; Observable<result></result></p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loginUsernameValid</span><span class="params">(<span class="number">_</span> useNameStr: String)</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">Result</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> useNameStr.<span class="built_in">count</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .just(.empty)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> userNameValid(useNameStr) &#123;</span><br><span class="line">        <span class="keyword">return</span> .just(.ok(message: <span class="string">"用户名 可用"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> .just(.failed(message: <span class="string">"用户名 不存在"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>⑦登录 Observable<result></result></p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(<span class="number">_</span> userNameStr: String, passWordStr: String)</span></span>-&gt; <span class="type">Observable</span>&lt;<span class="type">Result</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> filePath = <span class="type">NSHomeDirectory</span>()+<span class="string">"/Documents/users.plist"</span></span><br><span class="line">    <span class="keyword">let</span> userDic = <span class="type">NSDictionary</span>(contentsOfFile:filePath)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> usePass = userDic?.object(forKey: userNameStr) <span class="keyword">as</span>? <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> usePass == passWordStr &#123;</span><br><span class="line">            <span class="keyword">return</span> .just(.ok(message: <span class="string">"登录成功"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> .just(.failed(message: <span class="string">"密码错误"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Protocol-swift"><a href="#Protocol-swift" class="headerlink" title="Protocol.swift"></a>Protocol.swift</h1><blockquote><p>创建一个Protocol.swift文件，创建一个enum用于表示我们处理结果</p></blockquote><h2 id="枚举表示一些请求的结果"><a href="#枚举表示一些请求的结果" class="headerlink" title="枚举表示一些请求的结果"></a>枚举表示一些请求的结果</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> ok(message: <span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> empty</span><br><span class="line">    <span class="keyword">case</span> failed(message: <span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="先对Result进行了扩展"><a href="#先对Result进行了扩展" class="headerlink" title="先对Result进行了扩展"></a>先对Result进行了扩展</h2><blockquote><p>添加了一个isValid属性<br>状态是ok，这个属性就返回true，否则就返回false</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Result</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isValid: <span class="type">Bool</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .ok:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>添加了一个textColor属性，如果Result属性为ok的时候颜色就是绿色，否则即使红色</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Result</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textColor:<span class="type">UIColor</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .ok:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">UIColor</span>(red: <span class="number">138.0</span> / <span class="number">255.0</span>, green: <span class="number">221.0</span> / <span class="number">255.0</span>, blue: <span class="number">109.0</span> / <span class="number">255.0</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line">        <span class="keyword">case</span> .empty:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">UIColor</span>.black</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">               <span class="keyword">return</span> <span class="type">UIColor</span>.red</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>自定义了一个Observer<br>对UIlabel进行了扩展，根据result结果，进行他的text和textColor的显示<br>UIBindingObserver这个东西很有用的，创建我们自己的监听者，有时候RxCocoa(RxSwift中对UIKit的一个扩展库)给的扩展不够我们使用，比如一个UITextField有个isEnabled属性，我想把这个isEnabled变为一个observer，我们可以这样做</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> .ok(message):</span><br><span class="line">            <span class="keyword">return</span> message</span><br><span class="line">        <span class="keyword">case</span> .empty:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> .failed(message):</span><br><span class="line">            <span class="keyword">return</span> message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>UILabel进行了UIBingObserver，根据result结果，进行它的text和textColor显示</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UILabel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> validationResult: <span class="type">UIBindingObserver</span>&lt;<span class="type">Base</span>, <span class="type">Result</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIBindingObserver</span>(<span class="type">UIElement</span>: base) &#123; label, result <span class="keyword">in</span></span><br><span class="line">            label.textColor = result.textColor</span><br><span class="line">            label.text = result.description</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对UITextField进行扩展，根据result结果，进行他的isEnabled进行设置</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UITextField</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inputEnabled: <span class="type">UIBindingObserver</span>&lt;<span class="type">Base</span>, <span class="type">Result</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIBindingObserver</span>(<span class="type">UIElement</span>: base) &#123; textFiled, result <span class="keyword">in</span></span><br><span class="line">            textFiled.isEnabled = result.isValid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对 button.isEnabled进行扩展</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UIBarButtonItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tapEnabled: <span class="type">UIBindingObserver</span>&lt;<span class="type">Base</span>, <span class="type">Result</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIBindingObserver</span>(<span class="type">UIElement</span>: base) &#123; button, result <span class="keyword">in</span></span><br><span class="line">            button.isEnabled = result.isValid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="RegisterViewModel-swift"><a href="#RegisterViewModel-swift" class="headerlink" title="RegisterViewModel.swift"></a>RegisterViewModel.swift</h1><blockquote><p>input:</p></blockquote><ul><li>username既是一个observable也是一个observer，所以声明为他为一个Variable(被观察者)对象</li><li>对username进行处理的应该有一个结果，结果应该是需要界面去监听来改变界面，因为处理的结果不需要是一个observer，所以我们把它声明为一个Observable类型</li><li>初始值为””</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> userNameVariable      = <span class="type">Variable</span>&lt;<span class="type">String</span>&gt;(<span class="string">""</span>)<span class="comment">//usernameUseable表示对username处理的一个结果，后面userNameVariable作为 被观察的对象</span></span><br><span class="line"><span class="keyword">let</span> passWordVariable      = <span class="type">Variable</span>&lt;<span class="type">String</span>&gt;(<span class="string">""</span>)</span><br><span class="line"><span class="keyword">let</span> checkPassWordVariable = <span class="type">Variable</span>&lt;<span class="type">String</span>&gt;(<span class="string">""</span>)</span><br><span class="line"><span class="keyword">let</span> registerTaps          = <span class="type">PublishSubject</span>&lt;<span class="type">Void</span>&gt;()<span class="comment">//使用了PublishSubject，因为不需要有初始元素，其实前面的Variable都可以换成PublishSubject</span></span><br></pre></td></tr></table></figure><blockquote><p> output</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> userNameUsable:      <span class="type">Observable</span>&lt;<span class="type">Result</span>&gt;</span><br><span class="line"><span class="keyword">let</span> passWordUsable:      <span class="type">Observable</span>&lt;<span class="type">Result</span>&gt;</span><br><span class="line"><span class="keyword">let</span> checkPassWordUsable: <span class="type">Observable</span>&lt;<span class="type">Result</span>&gt;</span><br><span class="line"><span class="keyword">let</span> registerBtnEnabled:  <span class="type">Observable</span>&lt;<span class="type">Bool</span>&gt; <span class="comment">//注册按钮是否可用的输出，这个其实关系到username和password</span></span><br><span class="line"><span class="keyword">let</span> registerResult:      <span class="type">Observable</span>&lt;<span class="type">Result</span>&gt;</span><br></pre></td></tr></table></figure><blockquote><p>初始化处理- 网络层</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> service = <span class="type">ValidationService</span>.instance</span><br></pre></td></tr></table></figure><blockquote><p>观察 –&gt; userNameVariable（input）（事件源）</p></blockquote><ul><li>userNameUsable 被观察者（事件源）（就是要观察  userNameVariable）处理结果 ,然后对里面的元素进行处理之后发射对应的事件,要通过 高阶函数发出一个处理后的 队列,</li><li>flatMapLatest 只会接收最新的value事件</li><li>validateUsername 监听username 返回一个Observable对象</li><li>service.validateUsername （），处理一个队列信号，再返回一个新队列信号</li><li>shareReplay(1)是因为我们要保证无论多少个Observer来监听我们这个序列，username的处理代码我们只执行一次，这一次请求结果供多有的observer去使用</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">userNameUsable = userNameVariable.asObservable()</span><br><span class="line">                                       .flatMapLatest&#123; userNameVariable <span class="keyword">in</span></span><br><span class="line">                                                       <span class="keyword">return</span> service.validateUsername(userNameVariable)</span><br><span class="line">                                                                     .observeOn(<span class="type">MainScheduler</span>.instance)</span><br><span class="line">                                                                     .catchErrorJustReturn(.failed(message: <span class="string">"username检测出错"</span>))</span><br><span class="line">                                                      &#125;</span><br><span class="line">                                        .share(replay:<span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>密码passWordStr作为观察者，密码文本变化，判断，返回不同的队列信号</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">passWordUsable = passWordVariable.asObservable()</span><br><span class="line">                                     .<span class="built_in">map</span>&#123; passWordVariable <span class="keyword">in</span></span><br><span class="line">                                        <span class="keyword">return</span> service.validatePassWord(passWordVariable)</span><br><span class="line">                                      &#125;</span><br><span class="line">                                     .share(replay:<span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>密码+检测密码 2个队列信号<br>combineLatest邻近事件一起处理</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">checkPassWordUsable = <span class="type">Observable</span>.combineLatest(passWordVariable.asObservable(),checkPassWordVariable.asObservable())&#123;</span><br><span class="line">                                                   <span class="keyword">return</span> service.validateCheckPassWord($<span class="number">0</span>, checkPassWordStr: $<span class="number">1</span>)</span><br><span class="line">                                              &#125;</span><br><span class="line">                               .share(replay: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>用户名+密码+检车密码  3次队列合并–&gt;发出 是否注册成功的队列</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">registerBtnEnabled = <span class="type">Observable</span>.combineLatest(userNameUsable,</span><br><span class="line">                                                   passWordUsable,</span><br><span class="line">                                                   checkPassWordUsable)&#123;  (username,passWord,checkPassWord) <span class="keyword">in</span></span><br><span class="line">                                                           username.isValid &amp;&amp; passWord.isValid &amp;&amp; checkPassWord.isValid  <span class="comment">// 要求3个信号量均不为nil</span></span><br><span class="line">                                                        &#125;</span><br><span class="line">                                     .distinctUntilChanged() <span class="comment">//如果队列中出现相同Element，将被过滤掉</span></span><br><span class="line">                                     .share(replay: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注册结果队列</p></blockquote><ul><li>combineLatest 合并 userNameStr 和 passWordStr 的处理结果绑定到一起—&gt;形成总的结果流</li><li>registerTaps来判断 如果满足注册条件，</li><li>withLatestFrom 应该意思是 获取最新的队列信号</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">registerResult = registerTaps.asObserver()</span><br><span class="line">                                   .withLatestFrom( <span class="type">Observable</span>.combineLatest(userNameVariable.asObservable(), passWordVariable.asObservable()) &#123;</span><br><span class="line">                                      ($<span class="number">0</span>, $<span class="number">1</span>)</span><br><span class="line">                                    &#125;)</span><br><span class="line">                                   .flatMapLatest&#123;    <span class="comment">// flatMapLatest 只会接收最新的value事件</span></span><br><span class="line">                                      (username,password) <span class="keyword">in</span></span><br><span class="line">                                          <span class="keyword">return</span> service.register(username, passWordStr: password)</span><br><span class="line">                                              .observeOn(<span class="type">MainScheduler</span>.instance)</span><br><span class="line">                                              .catchErrorJustReturn(.failed(message: <span class="string">"注册出错"</span>))</span><br><span class="line">                                        &#125;</span><br><span class="line">                                   .share(replay: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><a href="http://www.cnblogs.com/scott-mr/p/7240991.html" target="_blank" rel="noopener">refer</a></p>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Demo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
            <tag> Demo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-Grammar-shareReplay</title>
      <link href="/2018/03/27/Swift/RxSwift/Grammar/shareReplay/"/>
      <url>/2018/03/27/Swift/RxSwift/Grammar/shareReplay/</url>
      <content type="html"><![CDATA[<h1 id="⑤shareReplay"><a href="#⑤shareReplay" class="headerlink" title="⑤shareReplay"></a>⑤shareReplay</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>.just(<span class="string">"🤣"</span>)</span><br><span class="line">                           .<span class="built_in">map</span>&#123; </span><br><span class="line">                                <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">                                &#125;</span><br><span class="line">observable.subscribe&#123;</span><br><span class="line">                 <span class="built_in">print</span>(<span class="string">"Even:<span class="subst">\($<span class="number">0</span>)</span>"</span>)</span><br><span class="line">             &#125;</span><br><span class="line">           .disposed(by: disposeBag)</span><br><span class="line">observable.subscribe&#123; </span><br><span class="line">                  <span class="built_in">print</span>(<span class="string">"Even:<span class="subst">\($<span class="number">0</span>)</span>"</span>)</span><br><span class="line">              &#125;</span><br><span class="line">           .disposed(by: disposeBag)</span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"></span><br><span class="line">🤣</span><br><span class="line"><span class="type">Even</span>:next(())</span><br><span class="line"><span class="type">Even</span>:completed</span><br><span class="line">🤣</span><br><span class="line"><span class="type">Even</span>:next(())</span><br><span class="line"><span class="type">Even</span>:completed</span><br></pre></td></tr></table></figure><blockquote><p>map()函数执行了两次，但是有些时候，我们并不想让map()函数里面的东西执行两次，比如map()函数里面执行的是网络请求，我只需要执行一次请求，然后把结果提供给大家使用就行了，多余的请求会增加负担。所以这时候就需要使用shareReplay(1)了。这里面的数字一般是1，只执行一次。(ps:我改成 2，3 也只打印一次)</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">   </span><br><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>.just(<span class="string">"🤣"</span>).<span class="built_in">map</span>&#123;<span class="built_in">print</span>($<span class="number">0</span>)&#125;.shareReplay(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">observable.subscribe&#123;<span class="built_in">print</span>(<span class="string">"Even:<span class="subst">\($<span class="number">0</span>)</span>"</span>)&#125;.disposed(by: disposeBag)</span><br><span class="line">observable.subscribe&#123;<span class="built_in">print</span>(<span class="string">"Even:<span class="subst">\($<span class="number">0</span>)</span>"</span>)&#125;.disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line">🤣</span><br><span class="line"><span class="type">Even</span>:next(())</span><br><span class="line"><span class="type">Even</span>:completed</span><br><span class="line"><span class="type">Even</span>:next(())</span><br><span class="line"><span class="type">Even</span>:completed</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Grammar </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-Grammar-Driver</title>
      <link href="/2018/03/27/Swift/RxSwift/Grammar/Driver/"/>
      <url>/2018/03/27/Swift/RxSwift/Grammar/Driver/</url>
      <content type="html"><![CDATA[<h1 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h1><blockquote><p>官方的例子的场景大概就是，根据一个输入框的关键字，来请求数据，然后接结果绑定到另一个Label,和TableView中<br>首先创建一个可监听序列results;<br>将results绑定到resultCount.rx.text上;<br>将results绑定到resultsTableView上.</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//throttle过滤操作</span></span><br><span class="line"><span class="keyword">let</span> results =  query.rx.text.throttle(<span class="number">0.3</span>,scheduler: <span class="type">MainScheduler</span>.instance)<span class="comment">//在主线程中操作，如果0.3秒内值发生多次改变，取最后一次的值</span></span><br><span class="line">        .flatMapLatest        <span class="comment">// flatMapLatest只会接收最新的value事件 </span></span><br><span class="line">         &#123;   query <span class="keyword">in</span>   <span class="comment">//筛选出空值, 拍平序列，并取得最后一个有效的值</span></span><br><span class="line">                fetchAutoCompleteItems(query)</span><br><span class="line">         &#125;</span><br><span class="line">           </span><br><span class="line">    </span><br><span class="line">results.<span class="built_in">map</span> &#123; <span class="string">"<span class="subst">\($<span class="number">0</span>.<span class="built_in">count</span>)</span>"</span> &#125;       <span class="comment">//得出结果之后，取出结果的数量</span></span><br><span class="line">       .bindTo(resultCount.rx.text) <span class="comment">//取出结果的数量，绑定到resultCount上面显示出来</span></span><br><span class="line">       .addDisposableTo(disposeBag) <span class="comment">//释放资源</span></span><br><span class="line">    </span><br><span class="line">results.bindTo(resultsTableView.rx.items(cellIdentifier: <span class="string">"Cell"</span>)) &#123;   (<span class="number">_</span>, result, cell) <span class="keyword">in</span></span><br><span class="line">                                        cell.textLabel?.text = <span class="string">"<span class="subst">\(result)</span>"</span> <span class="comment">//取出结果，TableView的Cell上面显示出来</span></span><br><span class="line">             &#125;</span><br><span class="line">       .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><blockquote><p>上面程序会出现下面几个异常：</p></blockquote><ul><li>如果fetchAutoCompleteItems出错，那么它绑定的UI将不再收到任何事件消息；</li><li>如果fetchAutoCompleteItems发生在后台线程，那么它绑定的事件也将在后台线程执行，这样更新UI会造成crash；</li><li>有两次绑定，fetchAutoCompleteItems就会执行两次</li></ul><blockquote><p>当然针对以上问题，也有解决方案<br>针对第三点，可以使用神器shareReplay(1)保证只执行一次，可以使用observeOn()保证后面所有操作在主线程完成</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> results = query.rx.text</span><br><span class="line">    .throttle(<span class="number">0.3</span>, </span><br><span class="line">              scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">    .flatMapLatest &#123; query <span class="keyword">in</span></span><br><span class="line">        fetchAutoCompleteItems(query).observeOn(<span class="type">MainScheduler</span>.instance) <span class="comment">// 将返回结果切换到到主线程上</span></span><br><span class="line">                                     .catchErrorJustReturn([])    <span class="comment">// 如果有问题，错误结果将会得到处理          </span></span><br><span class="line">    &#125;</span><br><span class="line">    .shareReplay(<span class="number">1</span>)       <span class="comment">// HTTP请求将会得到分享，即两次绑定UI使用同一网络请求</span></span><br><span class="line">                                 </span><br><span class="line">results</span><br><span class="line">    .<span class="built_in">map</span> &#123; <span class="string">"<span class="subst">\($<span class="number">0</span>.<span class="built_in">count</span>)</span>"</span> &#125;</span><br><span class="line">    .bindTo(resultCount.rx.text)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line">    </span><br><span class="line">results</span><br><span class="line">    .bindTo(resultTableView.rx.items(cellIdentifier: <span class="string">"Cell"</span>)) &#123; (<span class="number">_</span>, result, cell) <span class="keyword">in</span></span><br><span class="line">        cell.textLabel?.text = <span class="string">"<span class="subst">\(result)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><blockquote><p>用Driver来解决</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> results = query.rx</span><br><span class="line">                   .text</span><br><span class="line">                   .asDriver()</span><br><span class="line">                   .throttle(<span class="number">0.3</span>, </span><br><span class="line">                            scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">    .flatMapLatest &#123; query <span class="keyword">in</span></span><br><span class="line">        fetchAutoCompleteItems(query).asDriver(onErrorJustReturn: [])  <span class="comment">//当遇见错误需要返回什么</span></span><br><span class="line">    &#125;   <span class="comment">//不需要添加shareReplay(1)</span></span><br><span class="line">    </span><br><span class="line">results.<span class="built_in">map</span> &#123; <span class="string">"<span class="subst">\($<span class="number">0</span>.<span class="built_in">count</span>)</span>"</span> &#125;</span><br><span class="line">      .drive(resultCount.rx.text)     <span class="comment">//和bingTo()功能一样</span></span><br><span class="line">     .addDisposableTo(disposeBag) </span><br><span class="line">                                             </span><br><span class="line">results.drive(resultTableView.rx.items(cellIdentifier: <span class="string">"Cell"</span>)) &#123; (<span class="number">_</span>, result, cell) <span class="keyword">in</span></span><br><span class="line">        cell.textLabel?.text = <span class="string">"<span class="subst">\(result)</span>"</span></span><br><span class="line">         &#125;</span><br><span class="line">     .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><ul><li>.asDriver 将‘ControlProperty’ 转换成了 ‘Driver’</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">query.rx_text.asDriver()</span><br></pre></td></tr></table></figure><ul><li>‘Driver’拥有’ControlProperty’的所有属性，同时又增加了很多属性</li></ul><blockquote><p>任何 ‘Observable’ 序列都可以被转换为’Driver’, 只要他满足一下三点：</p></blockquote><ul><li>1.不能出错   </li><li>2.观察主线程 </li><li>3.共享资源</li><li>如何确保这些属性都满足呢？只需要使用 ‘asDriver(onErrorJustReturn: [])’ ,相当于如下代码:</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> safeSequence = xs</span><br><span class="line"></span><br><span class="line">  .observeOn(<span class="type">MainScheduler</span>.instance) <span class="comment">// 切换到主线程</span></span><br><span class="line"></span><br><span class="line">  .catchErrorJustReturn(onErrorJustReturn) <span class="comment">// 不能出错</span></span><br><span class="line"></span><br><span class="line">  .shareReplayLatestWhileConnected         <span class="comment">// 共享资源</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="type">Driver</span>(raw: safeSequence)           <span class="comment">// 返回</span></span><br></pre></td></tr></table></figure><ul><li>最后一点要说明的是 ‘driver’ 可以代替’bindTo’,<code>drive</code> 只能在 <code>Driver</code> 中使用 </li></ul><blockquote><p>drive方法只能在Driver序列中使用，Driver有以下特点：</p></blockquote><ul><li>Driver序列不允许发出error，</li><li>Driver序列的监听只会在主线程中。</li></ul><blockquote><p>所以Driver是专为UI绑定量身打造的东西。<br>以下情况你可以使用Driver替换BindTo:</p></blockquote><ul><li>不能发出error;</li><li>在主线程中监听;</li><li>共享事件流;</li></ul>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Grammar </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-Grammar-Observable可观察序列&amp;Observer观察者</title>
      <link href="/2018/03/27/Swift/RxSwift/Grammar/Observable&amp;Observer/"/>
      <url>/2018/03/27/Swift/RxSwift/Grammar/Observable&amp;Observer/</url>
      <content type="html"><![CDATA[<h1 id="Observable可观察序列-和-Observer观察者"><a href="#Observable可观察序列-和-Observer观察者" class="headerlink" title="Observable可观察序列  和 Observer观察者"></a>Observable可观察序列  和 Observer观察者</h1><h2 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h2><blockquote><p>Observer (观察者)订阅一个可观察序列 Observable(事件源)<br>每一个Observable的实例都是一个序列<br>观察者 对 Observable 发射的数据或数据序列作出响应</p></blockquote><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><blockquote><p>Button 的点击这个情景</p></blockquote><ul><li>把用户一次又一次的点击 Button 看做是序列(sequence)</li><li>通过调用 subscribe 来订阅这个点击事件</li><li>每次点击都会发射一个数据</li><li>作为订阅者的 subscribe 收到这个这个数据进行某些响应</li></ul><blockquote><p>Rx 的基本概念，有Observer观察者观察一个序列sequence，每当序列发射值的时候，观察者根据序列做一些事情<br>Observable序列相比于Swift序列的关键优势点在于它能够异步地接收元素</p></blockquote><ul><li>Observable(ObservableType)等效于Sequence</li><li>observableType.subscribe(_:)方法等效于Sequence.makeIterator()</li><li>ObservableType.subscribe(_:)接收一个观察者ObserverType参数,它将被订阅自动接收由可观察到的序列事件和元素，而不是在返回的生成器上手动调用next()</li></ul><blockquote><p>如果一个Observable发出一个next事件(Event.next(Element)),它还能够继续发出更多的事件<br>但是，如果一个Observable发出一个error事件(Event.error(ErrorType))或者一个completed事件(Event.completed)，那么这个Observable序列就不能给订阅者发送其他的事件</p></blockquote><h2 id="可观察序列-Observables-aka-Sequences"><a href="#可观察序列-Observables-aka-Sequences" class="headerlink" title="可观察序列 (Observables aka Sequences)"></a>可观察序列 (Observables aka Sequences)</h2><blockquote><p>可观察序列 存在三种情况:<br>①发射数据(Next)<br>②遇到问题(Error)<br>③发射完成(Completed)</p></blockquote><blockquote><p>有限序列</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">比如，有这样一个序列 --1--2--3--4--5--6--| ，它发送了按顺序发送了 1 2 3 4 5 6 这些值后，就终止了，就是发射完成。这是一个有限序列</span><br><span class="line">也有可能因为某些特殊的情况，遇到某些错误（比如数据解析错误），--1--2--3--4--X ，因为解析错误意外终止</span><br></pre></td></tr></table></figure><blockquote><p>无限序列</p></blockquote><ul><li>比如用户点击 Button ，这个就属于无限序列</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---tap-tap-------tap---&gt; 当然这里的无限不是真的无限，是不确定用户什么时候会点击，不确定是否会继续点击。所以这是一个无限序列，每当用户点击，序列就发射一个值</span><br></pre></td></tr></table></figure><blockquote><p>将以上的三种情况统概括为事件</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Event</span>&lt;<span class="title">Element</span>&gt;  </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Next</span>(<span class="type">Element</span>)      <span class="comment">// 序列的下一个元素</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Error</span>(<span class="type">ErrorType</span>)   <span class="comment">// 序列因为某些错误终止</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Completed</span>          <span class="comment">// 正常的序列技术</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="观察者-Observer"><a href="#观察者-Observer" class="headerlink" title="观察者 (Observer)"></a>观察者 (Observer)</h2><blockquote><p>观察者需要一个订阅序列的功能</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subscribe</span><span class="params">(observer: Observer&lt;Element&gt;)</span></span> -&gt; <span class="type">Disposable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ObserverType</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">on</span><span class="params">(event: Event&lt;Element&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过序列的这个 subscribe 来订阅序列<br>这里就应该提到序列的“冷”“热”问题</p></blockquote><ul><li>冷：只有当有观察者订阅这个序列时，序列才发射值</li><li>热：序列创建时就开始发射值</li></ul><blockquote><p>整体上就是这样的一个关系，序列发射值，观察者订阅序列，收到值，进行处理</p></blockquote><h2 id="Obserable"><a href="#Obserable" class="headerlink" title="Obserable"></a>Obserable</h2><blockquote><p>创建被观察者其实就是<strong>创建一个Obserable的sequence</strong>，就是创建一个流，然后就可以被订阅subscribe，这样被观察者发出时间消失，就能做相应的处理</p></blockquote>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Grammar </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-Grammar-map和flatMap</title>
      <link href="/2018/03/27/Swift/RxSwift/Grammar/map%E5%92%8CflatMap/"/>
      <url>/2018/03/27/Swift/RxSwift/Grammar/map%E5%92%8CflatMap/</url>
      <content type="html"><![CDATA[<h1 id="map和flatMap"><a href="#map和flatMap" class="headerlink" title="map和flatMap"></a>map和flatMap</h1><blockquote><p>map函数，接收一个R类型的序列，返回一个R类型的序列，还是原来的序列。</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;R&gt;<span class="params">(<span class="number">_</span> transform: @escaping <span class="params">(<span class="keyword">Self</span>.E)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">R</span>) -&gt; <span class="type">RxSwift</span>.<span class="type">Observable</span>&lt;<span class="type">R</span>&gt;</span><br></pre></td></tr></table></figure><blockquote><p>flatMap函数，接收一个O类型的序列，返回一个O.E类型的序列，也就是有原来序列里元素组成的新序列。</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;O: ObservableConvertibleType&gt;<span class="params">(<span class="number">_</span> selector: @escaping <span class="params">(E)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">O</span>)</span><br><span class="line">        -&gt; <span class="type">Observable</span>&lt;<span class="type">O</span>.<span class="type">E</span>&gt;</span><br></pre></td></tr></table></figure><blockquote><p>实这里的map和flatMap在swift中的作用是一样的。map函数可以对原有序列里面的事件元素进行改造，返回的还是原来的序列。而flatMap对原有序列中的元素进行改造和处理，每一个元素返回一个新的sequence，然后把每一个元素对应的sequence合并为一个新的sequence序列</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">   </span><br><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>.of(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>).<span class="built_in">map</span>&#123;$<span class="number">0</span> + <span class="string">"scott"</span>&#125;</span><br><span class="line">    </span><br><span class="line">observable.subscribe(onNext: &#123;<span class="built_in">print</span>($<span class="number">0</span>)&#125;).disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line">1scott</span><br><span class="line">2scott</span><br><span class="line">3scott</span><br><span class="line">4scott</span><br><span class="line">5scott</span><br></pre></td></tr></table></figure><blockquote><p>使用map对序列中每一个元素进行了处理，返回的是一个元素，而使用flatMap需要返回的序列。那么使用map也返回一个序列看看</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> test = <span class="type">Observable</span>.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>)</span><br><span class="line">    .<span class="built_in">map</span> &#123; <span class="type">Observable</span>.just($<span class="number">0</span>) &#125;</span><br><span class="line">    </span><br><span class="line">test.subscribe(onNext: &#123;</span><br><span class="line">        <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 运行结果:</span></span><br><span class="line"><span class="type">RxSwift</span>.(<span class="type">Just</span> <span class="keyword">in</span> _BD9B9D4356C4038796FB16D0D54A9F8E)&lt;<span class="type">Swift</span>.<span class="type">String</span>&gt;</span><br><span class="line"><span class="type">RxSwift</span>.(<span class="type">Just</span> <span class="keyword">in</span> _BD9B9D4356C4038796FB16D0D54A9F8E)&lt;<span class="type">Swift</span>.<span class="type">String</span>&gt;</span><br><span class="line"><span class="type">RxSwift</span>.(<span class="type">Just</span> <span class="keyword">in</span> _BD9B9D4356C4038796FB16D0D54A9F8E)&lt;<span class="type">Swift</span>.<span class="type">String</span>&gt;</span><br><span class="line"><span class="type">RxSwift</span>.(<span class="type">Just</span> <span class="keyword">in</span> _BD9B9D4356C4038796FB16D0D54A9F8E)&lt;<span class="type">Swift</span>.<span class="type">String</span>&gt;</span><br><span class="line"><span class="type">RxSwift</span>.(<span class="type">Just</span> <span class="keyword">in</span> _BD9B9D4356C4038796FB16D0D54A9F8E)&lt;<span class="type">Swift</span>.<span class="type">String</span>&gt;</span><br></pre></td></tr></table></figure><blockquote><p>看到结果会打印出每一个序列，下面我们使用merge()方法将这几个序列进行合并:</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> test = <span class="type">Observable</span>.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>)</span><br><span class="line">    .<span class="built_in">map</span> &#123; <span class="type">Observable</span>.just($<span class="number">0</span>) &#125;.merge()</span><br><span class="line">    </span><br><span class="line">test.subscribe(onNext: &#123;</span><br><span class="line">        <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line"><span class="comment">//运行结果:</span></span><br><span class="line"> <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><blockquote><p>并为一个新序列后我们就可以正常打印元素了。下面看看使用faltMap()函数干这件事</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> test = <span class="type">Observable</span>.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>)</span><br><span class="line">    .flatMap &#123; <span class="type">Observable</span>.just($<span class="number">0</span>) &#125;</span><br><span class="line">    </span><br><span class="line">test.subscribe(onNext: &#123;</span><br><span class="line">        <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line"> <span class="comment">//运行结果:</span></span><br><span class="line"> <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><blockquote><p>看下对比是不是一样，这样子对比就清晰了吧。</p></blockquote><ul><li>map函数只能返回原来的那一个序列，里面的参数的返回值被当做原来序列中所对应的元素。</li><li>flatMap函数返回的是一个新的序列，将原来元素进行了处理，返回这些处理后的元素组成的新序列</li><li>map函数 + 合并函数 = flatMap函数</li></ul><blockquote><p>flatMap函数在实际应用中有很多地方需要用到，比如网络请求，网络请求可能会发生错误，我们需要对这个请求过程进行监听，然后处理错误。只要继续他返回的是一个新的序列</p></blockquote>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Grammar </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-Grammar-UIBindingObserver</title>
      <link href="/2018/03/27/Swift/RxSwift/Grammar/UIBindingObserver/"/>
      <url>/2018/03/27/Swift/RxSwift/Grammar/UIBindingObserver/</url>
      <content type="html"><![CDATA[<h1 id="UIBindingObserver"><a href="#UIBindingObserver" class="headerlink" title="UIBindingObserver"></a>UIBindingObserver</h1><blockquote><p>UIBindingObserver这个东西很有用的，创建我们自己的监听者，有时候RxCocoa(RxSwift中对UIKit的一个扩展库)给的扩展不够我们使用，比如一个UITextField有个isEnabled属性，我想把这个isEnabled变为一个observer，我们可以这样做</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension Reactive where Base: UITextField &#123;</span><br><span class="line">    var inputEnabled: UIBindingObserver&lt;Base, Result&gt; &#123;</span><br><span class="line">        return UIBindingObserver(UIElement: base) &#123; textFiled, result in</span><br><span class="line">            textFiled.isEnabled = result.isValid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>UIBindingObserver是一个类，他的初始化方法中，有两个参数，第一个参数是一个元素本身，第一个参数是一个闭包，闭包参数是元素本身，还有他的一个属性</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(<span class="type">UIElement</span>: <span class="type">UIElementType</span>, binding: @escaping (<span class="type">UIElementType</span>, <span class="type">Value</span>) -&gt; <span class="type">Swift</span>.<span class="type">Void</span>)</span><br></pre></td></tr></table></figure><blockquote><p>自定义了一个inputEnabled关联了UITextField的isEnabled属性</p></blockquote>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Grammar </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-Grammar-observeOn()和subscribeOn()</title>
      <link href="/2018/03/27/Swift/RxSwift/Grammar/observeOn()%E5%92%8CsubscribeOn()/"/>
      <url>/2018/03/27/Swift/RxSwift/Grammar/observeOn()%E5%92%8CsubscribeOn()/</url>
      <content type="html"><![CDATA[<h1 id="observeOn-和subscribeOn"><a href="#observeOn-和subscribeOn" class="headerlink" title="observeOn()和subscribeOn()"></a>observeOn()和subscribeOn()</h1><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>subscribeOn()</td><td>设置起点在哪个线程</td></tr><tr><td>observeOn()</td><td>置了后续工作在哪个线程</td></tr></tbody></table><blockquote><p>1)所有动作都发生在当前的默认线程<br>2)observeOn()转换线程到主线程，下面所有的操作都在主线程<br>3)subscribeOn()规定动作一开始不是发生在默认线程，而是在OtherScheduler了<br>)-如果之前没有调用observeOn()，那么这边会在OtherScheduler发生，但是我们前面调用了observeOn()，所以这个动作会在主线程中调用<br>subscribeOn()只是影响事件链开始默认的线程，而observeOn()规定了下一步动作发生在哪个线程中。</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">someObservable</span><br><span class="line">     .doOneThing() <span class="comment">//1</span></span><br><span class="line">     .observeOn(<span class="type">MainRouteScheduler</span>.instance) <span class="comment">// 2</span></span><br><span class="line">      .subscribeOn(<span class="type">OtherScheduler</span>.instance) <span class="comment">// 3</span></span><br><span class="line">      .subscribeNext &#123; <span class="comment">// 4</span></span><br><span class="line">        ......</span><br><span class="line">         &#125;</span><br><span class="line">      .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Grammar </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-Grammar-Subscribe</title>
      <link href="/2018/03/27/Swift/RxSwift/Grammar/Subscribe/"/>
      <url>/2018/03/27/Swift/RxSwift/Grammar/Subscribe/</url>
      <content type="html"><![CDATA[<h1 id="subscribe-和-subscribe-onNext"><a href="#subscribe-和-subscribe-onNext" class="headerlink" title="subscribe 和 subscribe(onNext:)"></a>subscribe 和 subscribe(onNext:)</h1><blockquote><p>Subscribe</p></blockquote><ul><li><strong>subscribe是订阅sequence发出的事件</strong>，比如next事件，error事件等</li><li>而subscribe(onNext:)是监听sequence发出的next事件中的element进行处理，他会忽略error和completed事件</li><li>相对应的还有subscribe(onError:) 和 subscribe(onCompleted:)</li></ul>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Grammar </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-Grammar-自定义operator</title>
      <link href="/2018/03/27/Swift/RxSwift/Grammar/%E8%87%AA%E5%AE%9A%E4%B9%89operator/"/>
      <url>/2018/03/27/Swift/RxSwift/Grammar/%E8%87%AA%E5%AE%9A%E4%B9%89operator/</url>
      <content type="html"><![CDATA[<h1 id="自定义operator"><a href="#自定义operator" class="headerlink" title="自定义operator"></a>自定义operator</h1><blockquote><p>自定义操作符很简单，官方推荐尽量使用标准的操作符，但是你也可以定义自己的操作符，文档上说有两种方法，这里介绍一下常用的一种方法吧<br>自定义一个map操作符</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">extension</span> <span class="title">ObserverType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">myMap</span>&lt;R&gt;<span class="params">(transform: E -&gt; R)</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">R</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Observable</span>.create&#123; observer <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> subscription = <span class="keyword">self</span>.subscribe &#123;e <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">switch</span> e&#123;</span><br><span class="line">                <span class="keyword">case</span> .next(<span class="keyword">let</span> value):</span><br><span class="line">                    <span class="keyword">let</span> result = transform(value)</span><br><span class="line">                    observer.on(.next(result))</span><br><span class="line">                <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">                    observer.on(.error(error))</span><br><span class="line">                <span class="keyword">case</span> .completed:</span><br><span class="line">                    observer.on(.completed)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> subscription</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参数是一个闭包，其中闭包参数是E类型返回值是R类型，map函数的返回值是一个Observable类型。</p></blockquote>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Grammar </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-Grammar-Dispose和DisposeBag</title>
      <link href="/2018/03/27/Swift/RxSwift/Grammar/Dispose%E5%92%8CDisposeBag/"/>
      <url>/2018/03/27/Swift/RxSwift/Grammar/Dispose%E5%92%8CDisposeBag/</url>
      <content type="html"><![CDATA[<h1 id="Dispose-和-DisposeBag"><a href="#Dispose-和-DisposeBag" class="headerlink" title="Dispose 和 DisposeBag"></a>Dispose 和 DisposeBag</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">当监听一个sequence的时候，有消息事件来了，做某些事情。但是这个sequence不再发送消息事件了，那么我们的监听也就没有什么存在的价值了，所以我们需要释放我们这些监听资源，其实也就是内存资源释放</span><br></pre></td></tr></table></figure><p>##手动调用释放方式(一般不适用这种方式)</p><blockquote><p>创建一个subscription监听，在两秒以后我们不需要了，手动调用dispose()方法，就能释放监听资源，不再打印信息。上面的subscription不论是在哪个线程中监听，就算在主线程中调用的dispose()方法一样会销毁资源</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> subscription = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.interval(<span class="number">0.3</span>, scheduler:<span class="type">SerialDispatchQueueScheduler</span>.<span class="keyword">init</span>(internalSerialQueueName: <span class="string">"scott"</span>))</span><br><span class="line">                                  .observeOn(<span class="type">MainScheduler</span>.instance)</span><br><span class="line"> .subscribe &#123; event <span class="keyword">in</span> </span><br><span class="line">          <span class="built_in">print</span> (event)</span><br><span class="line">       &#125;</span><br><span class="line"><span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">2.0</span>)</span><br><span class="line">subscription.dispose()</span><br><span class="line">   </span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line">next(<span class="number">0</span>)</span><br><span class="line">next(<span class="number">1</span>)</span><br><span class="line">next(<span class="number">2</span>)</span><br><span class="line">next(<span class="number">3</span>)</span><br><span class="line">next(<span class="number">4</span>)</span><br><span class="line">next(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h2 id="自动方式"><a href="#自动方式" class="headerlink" title="自动方式"></a>自动方式</h2><blockquote><p>创建一个disposeBag来盛放我们需要管理的资源，然后把新建的监听都放进去，会在适当的时候销毁这些资源<br>如果需要立即释放资源只需要新建一个DisposeBag()，那么上一个DisposeBag就会被销毁</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.empty()</span><br><span class="line">               .subscribe&#123; event <span class="keyword">in</span> </span><br><span class="line">                   <span class="built_in">print</span> (event)</span><br><span class="line">                   &#125;</span><br><span class="line">                .addDisponseableTo(disposeBag)</span><br></pre></td></tr></table></figure><h2 id="DisposeBag"><a href="#DisposeBag" class="headerlink" title="DisposeBag"></a>DisposeBag</h2><blockquote><p>DisposeBag其实就相当于iOS中的ARC似得，会在适当的时候销毁观察者，相当于内存管理者吧</p></blockquote>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Grammar </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-Protocol协议-基础</title>
      <link href="/2018/03/21/Swift/Swift/Grammar/Protocol%E5%8D%8F%E8%AE%AE-Base/"/>
      <url>/2018/03/21/Swift/Swift/Grammar/Protocol%E5%8D%8F%E8%AE%AE-Base/</url>
      <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/flyingkuikui/article/details/77717480" target="_blank" rel="noopener">相关资料1</a><br><a href="http://blog.csdn.net/u010586842/article/details/47971853" target="_blank" rel="noopener">相关资料2</a><br><a href="http://blog.csdn.net/u010586842/article/details/47971853" target="_blank" rel="noopener">相关资料3</a></p><p>1.<a href="#Protocol">Protocol</a><br>   1.1<a href="#Protocol语法">Protocol语法</a><br>      1.2<a href="#格式">格式</a><br>      1.3<a href="#对属性的使用">对属性的使用</a><br>      1.4<a href="#方法要求">方法要求</a><br>      1.5<a href="#Mutating方法要求">Mutating方法要求</a><br>      1.6<a href="#使用协议规范构造函数">使用协议规范构造函数</a><br>      1.7<a href="#协议类型">协议类型</a><br>2.<a href="#委托/代理设计模式">委托/代理设计模式</a><br>3.<a href="#协议的使用">协议的使用</a><br>  3.1<a href="#在扩展中添加协议成员">在扩展中添加协议成员</a><br>  3.2<a href="#通过扩展补充协议声明">通过扩展补充协议声明</a><br>  3.3<a href="#集合中的协议类型">集合中的协议类型</a><br>  3.4<a href="#仅在类中使用协议">仅在类中使用协议</a><br>4.<a href="#协议的继承">协议的继承</a><br>  4.1<a href="#protocolComposition协议的合成">protocolComposition协议的合成</a><br>  4.2<a href="#检验协议的一致性">检验协议的一致性</a><br>   4.3<a href="#可选协议要求">可选协议要求</a></p><h1 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h1><p><span id="Protocol"></span></p><ul><li>协议：代理设计模式</li><li>协议能够被 类、枚举、结构体 实现，满足协议要求的类、枚举、结构体被称为协议的是实现者</li><li>官方的定义：协议定义了一个蓝图 ， 规定了用来实现某一特定工作或者功能所必须的方法和属性，类、结构体、或者枚举类型都可以遵循协议， 并提供具体实现来完成协议定义的方法和功能 。 任意能够满足协议要求的类型都被成为遵循了这个协议</li></ul><h1 id="Protocol语法"><a href="#Protocol语法" class="headerlink" title="Protocol语法"></a>Protocol语法</h1><p><span id="Protocol语法"></span></p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p><span id="格式"></span></p><ul><li>在类、枚举、结构体的名称后加上协议名称，中间以冒号(:)分隔，即可实现协议，当实现多个协议时，多个协议间用逗号(,)隔开</li><li>类含有父类,则应当将父类放在所有的协议之前</li></ul><blockquote><p>协议实现书写格式</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 : 协议1 , 协议<span class="title">n</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名:父类,协议1,协议<span class="title">n</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对属性的使用"><a href="#对属性的使用" class="headerlink" title="对属性的使用"></a>对属性的使用</h2><p><span id="对属性的使用"></span></p><ul><li>无论声明的属性为类属性还是对象属性，均需要在属性声明后加上{get}或{get set}，代表属性只读或读写</li><li>属性被声明为{get}，为可读的属性实现{setter}方法，也不会报错。</li><li>在声明类属性时，需要在声明的属性前添加关键字static。</li><li>在实现者内，必须实现协议的类属性的getter方法，如果协议内定义的类属性是读写的，则还必须实现setter方法</li><li>在协议中使用类型属性 总是使用static</li></ul><blockquote><p>协议1</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">oneProtocol</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定义变量，必须在属性声明后添加&#123;get&#125;或者&#123;get set&#125;</span></span><br><span class="line">    <span class="keyword">var</span> argumentOne:<span class="type">Int</span>&#123;<span class="keyword">get</span>&#125; <span class="comment">// 只读</span></span><br><span class="line">    <span class="keyword">var</span> argumentTwo:<span class="type">Int</span>&#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125; <span class="comment">// 读写</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> argumentClass:<span class="type">Int</span>&#123;<span class="keyword">get</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:<span class="title">oneProtocol</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> argumentOne: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> argumentTwo: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> argumentClass: <span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">30</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(argumentOne:<span class="type">Int</span>,argumentTwo:<span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.argumentOne = argumentOne</span><br><span class="line">        <span class="keyword">self</span>.argumentTwo = argumentTwo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> per = <span class="type">Person</span>(argumentOne: <span class="number">90</span>, argumentTwo: <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(per.argumentOne)</span>"</span>) <span class="comment">// 90</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(Person.argumentClass)</span>"</span>) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><blockquote><p>协议2</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Pro1</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span>&#123;<span class="keyword">set</span> <span class="keyword">get</span>&#125;  <span class="comment">//可读可写</span></span><br><span class="line">    <span class="keyword">var</span> age:<span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;  <span class="comment">//只读属性</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> status:<span class="type">Int</span> &#123;<span class="keyword">set</span> <span class="keyword">get</span>&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>遵循协议</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Struct1</span> : <span class="title">Pro1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _name = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span>   &#123;</span><br><span class="line">        <span class="keyword">set</span>&#123;</span><br><span class="line">           _name = newValue</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">18</span> <span class="comment">//可以声明为可读可写的</span></span><br><span class="line">    <span class="keyword">static</span>  <span class="keyword">var</span> status = <span class="number">1</span>  <span class="comment">//类型方法。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class1</span>: <span class="title">Pro1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"class"</span></span><br><span class="line">    <span class="keyword">var</span> age:<span class="type">Int</span>&#123; <span class="keyword">return</span>  <span class="number">19</span> &#125; <span class="comment">//也可以是只读</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> status = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法要求"><a href="#方法要求" class="headerlink" title="方法要求"></a>方法要求</h2><p><span id="方法要求"></span></p><ul><li>协议内声明的方法不需要协议进行方法的实现(OC差不多)</li><li>类方法，需要使用关键字 <strong>static</strong></li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">funcProtocol</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">sayBad</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:<span class="title">funcProtocol</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Hello"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">sayBad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Bad"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mutating方法要求"><a href="#Mutating方法要求" class="headerlink" title="Mutating方法要求"></a>Mutating方法要求</h2><p><span id="Mutating方法要求"></span></p><ul><li>能在方法或者函数内部改变字段的方法称为Mutating方法。</li><li>mutating关键字表示该函数允许改变该示例和其属性的类型。</li><li>一般mutating用在值拷贝的地方，例如：结构体、枚举。对于类或者类绑定协议中的方法无效</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Togglable</span></span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">toggle</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OnOffSwitch</span>:<span class="title">Togglable</span></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">On</span>,<span class="type">Off</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">toggle</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Off</span>:</span><br><span class="line">            <span class="keyword">self</span> = .<span class="type">On</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">On</span>:</span><br><span class="line">            <span class="keyword">self</span> = .<span class="type">Off</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> light = <span class="type">OnOffSwitch</span>.<span class="type">Off</span> <span class="comment">//Off</span></span><br><span class="line">light.toggle()  <span class="comment">// On</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OnOFF</span>:<span class="title">Togglable</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> one:<span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> two:<span class="type">Int</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">toggle</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.one &gt; <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.two = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">self</span>.two = <span class="number">20</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="type">LIGHT</span> = <span class="type">OnOFF</span>(one: <span class="number">2</span>, two: <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(LIGHT.two)</span>"</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="type">LIGHT</span>.toggle()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(LIGHT.two)</span>"</span>) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h2 id="使用协议规范构造函数"><a href="#使用协议规范构造函数" class="headerlink" title="使用协议规范构造函数"></a>使用协议规范构造函数</h2><p><span id="使用协议规范构造函数"></span></p><ul><li>协议可以规定必须实现指定的构造函数，比如一些类中必须要求实现init构造函数，这样就可以制造一个协议，让实现协议的类必须实现该构造函数。</li><li>实现构造协议的类，必须使用关键字required</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TwoProtocol</span></span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(twoArgument:<span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">two</span>:<span class="title">TwoProtocol</span></span>&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(twoArgument: <span class="type">Int</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>父类中存在与协议内相同的构造方法，则子类在实现构造方法时，需要同时使用关键字required和override</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TwoProtocol</span></span>&#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoSuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Two</span>:<span class="title">TwoSuperClass</span>,<span class="title">TwoProtocol</span></span>&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不能在final类中实现构造函数协议，因为final类是不能被继承的，因此不能实现构造函数协议</li><li>父类内被final修饰的方法与协议内相同，则该方法不能被遵循协议的子类实现</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">protocol</span> <span class="title">TwoProtocol</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoSuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Super Say Hello"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Two</span>:<span class="title">TwoSuperClass</span>,<span class="title">TwoProtocol</span></span>&#123;</span><br><span class="line">    <span class="comment">// 无法实现say方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="协议类型"><a href="#协议类型" class="headerlink" title="协议类型"></a>协议类型</h2><p><span id="协议类型"></span></p><ul><li>协议本身不实现任何功能，但是可以将它当作类型来使用。</li><li>协议作为类型使用的场景：<br>  ⒈作为函数、方法或构造器中的参数类型，返回值类型。<br>  ⒉作为常量、变量、属性的类型。<br>  ⒊作为数组、字典或其它容器中的元素类型</li></ul><h1 id="委托-代理设计模式"><a href="#委托-代理设计模式" class="headerlink" title="委托/代理设计模式"></a>委托/代理设计模式</h1><p><span id="委托/代理设计模式"></span></p><ul><li>委托/代理是一种设计模式，它允许类或者结构体将一些需要它们负责的功能交由给其他类型。</li><li>委托模式的实现：定义协议来封装那些需要被委托的函数和方法，使实现者拥有数据源的类型</li></ul><h1 id="协议的使用"><a href="#协议的使用" class="headerlink" title="协议的使用"></a>协议的使用</h1><p><span id="协议的使用"></span></p><h2 id="在扩展中添加协议成员"><a href="#在扩展中添加协议成员" class="headerlink" title="在扩展中添加协议成员"></a>在扩展中添加协议成员</h2><p><span id="在扩展中添加协议成员"></span></p><ul><li>当无法修改原代码时，可以通过扩展来补充已经存在的类型。</li><li>扩展可以为已经存在的类型添加属性、方法、下标、协议等成员。</li><li>通过扩展为已存在的类型实现协议时，该类型的所有实例也会随之添加协议中的方法</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TextProtocol</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printSomeMessage</span><span class="params">(message:String)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dice</span></span>&#123;</span><br><span class="line">&#125;]</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Dice</span>:<span class="title">TextProtocol</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printSomeMessage</span><span class="params">(message: String)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(message)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dic = <span class="type">Dice</span>()</span><br><span class="line">dic.printSomeMessage(message: <span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure><h2 id="通过扩展补充协议声明"><a href="#通过扩展补充协议声明" class="headerlink" title="通过扩展补充协议声明"></a>通过扩展补充协议声明</h2><p><span id="通过扩展补充协议声明"></span></p><ul><li>当一个类型已经实现了协议中的所有要求，却没有声明时，可以通过扩展补充协议的声明。</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TextProtocol</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printSomeMessage</span><span class="params">(message:String)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hamster</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printSomeMessage</span><span class="params">(message: String)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(message)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Hamster</span>:<span class="title">TextProtocol</span></span>&#123;</span><br><span class="line">   <span class="comment">// 此时，Hamster的实例也可以作为TextProtocol类型使用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> hamster = <span class="type">Hamster</span>()</span><br></pre></td></tr></table></figure><h2 id="集合中的协议类型"><a href="#集合中的协议类型" class="headerlink" title="集合中的协议类型"></a>集合中的协议类型</h2><p><span id="集合中的协议类型"></span></p><ul><li>协议也可以作为类型在集合中被使用，表示集合中的元素均为协议类型</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> things:[<span class="type">TextProtocol</span>] = [dic,hamster]</span><br><span class="line"><span class="keyword">for</span> thing <span class="keyword">in</span> things &#123;</span><br><span class="line">    thing.printSomeMessage(message: <span class="string">"Hello Word"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 由于thing被当作是TextProtocol类型，故都能调用printSomeMessage方法</span></span><br></pre></td></tr></table></figure><h2 id="仅在类中使用协议"><a href="#仅在类中使用协议" class="headerlink" title="仅在类中使用协议"></a>仅在类中使用协议</h2><p><span id="仅在类中使用协议"></span></p><ul><li>通过在协议中增加class关键字，可以实现协议只让类来实现。</li><li>如果该协议同时继承其它协议，则需要在class后添加，并且用逗号隔开</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">protocol</span> <span class="title">SomeOnlyClassProtocol</span>:<span class="title">class</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 协议SomeOnlyClassProtocol实现者只能是类</span></span><br></pre></td></tr></table></figure><h1 id="协议的继承"><a href="#协议的继承" class="headerlink" title="协议的继承"></a>协议的继承</h1><p><span id="协议的继承"></span></p><ul><li>协议可以继承一个或者多个其他协议，多个协议间用逗号隔开。</li><li>当类或者枚举等遵循协议时，不仅仅要实现当前协议的方法，也需要实现所遵循协议继承的其他协议</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">OneProtocol</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sayOne</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 协议的继承</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TwoProtocol</span>:<span class="title">OneProtocol</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sayTwo</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:<span class="title">TwoProtocol</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sayOne</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 协议OneProtocol的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sayTwo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 协议TwoProtocol的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="protocolComposition协议的合成"><a href="#protocolComposition协议的合成" class="headerlink" title="protocolComposition协议的合成"></a>protocolComposition协议的合成</h2><p><span id="protocolComposition协议的合成"></span></p><ul><li>一个协议可以由多个协议采用protocol&lt;NamedProtocol,GenderProtocol&gt;这样的格式进行组合，称之为协议的合成(protocol composition)。</li><li>协议合成并不会产生一个新的协议，而是将多个协议合成一个临时的协议，超出范围后立即失效</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">NamedProtocol</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span>&#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">GenderProtocol</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> gender:<span class="type">String</span>&#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AgedProtocol</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age:<span class="type">Int</span>&#123;<span class="keyword">get</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>:<span class="title">NamedProtocol</span>,<span class="title">GenderProtocol</span>,<span class="title">AgedProtocol</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> gender: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wishBirthday</span><span class="params">(celebrator:NamedProtocol &amp; GenderProtocol)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"姓名：<span class="subst">\(celebrator.name)</span>，性别：<span class="subst">\(celebrator.gender)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> per = <span class="type">Person</span>(name: <span class="string">"wang"</span>, gender: <span class="string">"man"</span>,age:<span class="number">20</span>)</span><br><span class="line">wishBirthday(celebrator: per)</span><br><span class="line"><span class="comment">// 形参celebrator的类型为protocol&lt;NamedProtocol,GenderProtocol&gt;，可以传入任何实现这两个协议的实例。即使此实例不仅仅遵循这两个协议。</span></span><br><span class="line"><span class="comment">// swift3.0之后，protocol&lt;NamedProtocol,GenderProtocol&gt;被NamedProtocol &amp; GenderProtocol替换。</span></span><br></pre></td></tr></table></figure><h2 id="检验协议的一致性"><a href="#检验协议的一致性" class="headerlink" title="检验协议的一致性"></a>检验协议的一致性</h2><p><span id="检验协议的一致性"></span></p><ul><li>用is检验协议的一致性，使用as将协议类型向下转换为其他协议类型。</li><li>is操作符用来检查实例是否实现了某个协议。返回值true/false。</li><li>as?返回一个可选值，当实例实现协议时，返回该协议类型；否则返回nil。</li><li>as用以强制向下转化类型。</li><li>@objc用来表示协议时可选的，还可以表示暴露给Objective-C的代码，。</li><li>@objc型协议只对类有效，因此只能在类中检查协议的一致性。</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">HasArea</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> area:<span class="type">Double</span>&#123;<span class="keyword">get</span>&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:<span class="title">HasArea</span></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pi = <span class="number">3.1415927</span></span><br><span class="line">    <span class="keyword">var</span> radius:<span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pi * radius * radius</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(radius:<span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.radius = radius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span>:<span class="title">HasArea</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(area:<span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.area = area</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> legs:<span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(legs:<span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.legs = legs</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> objects:[<span class="type">AnyObject</span>] = [</span><br><span class="line">    <span class="type">Circle</span>(radius: <span class="number">20</span>),</span><br><span class="line">    <span class="type">Country</span>(area: <span class="number">200</span>),</span><br><span class="line">    <span class="type">Animal</span>(legs: <span class="number">10</span>)</span><br><span class="line">]</span><br><span class="line"><span class="keyword">for</span> object <span class="keyword">in</span> objects &#123;</span><br><span class="line">    <span class="keyword">var</span> objectWithArea = object <span class="keyword">as</span>? <span class="type">HasArea</span></span><br><span class="line">    <span class="keyword">if</span> objectWithArea != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(objectWithArea)</span>"</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"遵循了HasArea协议，<span class="subst">\(object.area)</span>"</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"没有遵循HasArea协议"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"--------------------"</span>)</span><br><span class="line"><span class="keyword">for</span> object <span class="keyword">in</span> objects &#123;</span><br><span class="line">    <span class="comment">// 返回值 true/false</span></span><br><span class="line">    <span class="keyword">var</span> objectWithArea = object <span class="keyword">is</span> <span class="type">HasArea</span></span><br><span class="line">    <span class="keyword">if</span> objectWithArea &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(objectWithArea)</span>"</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"遵循了HasArea协议，<span class="subst">\(object.area)</span>"</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"没有遵循HasArea协议"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">打印结果：</span></span><br><span class="line"><span class="comment">Optional(__lldb_expr_386.Circle)</span></span><br><span class="line"><span class="comment">遵循了HasArea协议，Optional(1256.63708)</span></span><br><span class="line"><span class="comment">Optional(__lldb_expr_386.Country)</span></span><br><span class="line"><span class="comment">遵循了HasArea协议，Optional(200.0)</span></span><br><span class="line"><span class="comment">没有遵循HasArea协议</span></span><br><span class="line"><span class="comment">--------------------</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">遵循了HasArea协议，Optional(1256.63708)</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">遵循了HasArea协议，Optional(200.0)</span></span><br><span class="line"><span class="comment">没有遵循HasArea协议</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>##可选协议要求<br>  <span id="可选协议要求"></span></p><ul><li>可选协议含有可选成员，其实现者可以选择是否实现这些成员。</li><li>在协议中使用关键字optional关键字作为前缀来定义可选成员</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">HasArea</span></span>&#123;</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">optional</span> <span class="keyword">var</span> area:<span class="type">Double</span>&#123;<span class="keyword">get</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> width:<span class="type">Double</span>&#123;<span class="keyword">get</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:<span class="title">HasArea</span></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pi = <span class="number">3.1415927</span></span><br><span class="line">    <span class="keyword">var</span> radius:<span class="type">Double</span> = <span class="number">10.0</span></span><br><span class="line">    <span class="keyword">var</span> width: <span class="type">Double</span> = <span class="number">20.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Grammar </tag>
            
            <tag> Protocol </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-关键字-typealias/associatedtype</title>
      <link href="/2018/03/07/Swift/Swift/Grammar/%E5%85%B3%E9%94%AE%E5%AD%97-typealias:associatedtype/"/>
      <url>/2018/03/07/Swift/Swift/Grammar/%E5%85%B3%E9%94%AE%E5%AD%97-typealias:associatedtype/</url>
      <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/longshihua/article/details/74347889" target="_blank" rel="noopener">wenz</a></p>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-Lib-Moya-网络封装(RxSwift)</title>
      <link href="/2018/03/07/Swift/RxSwift/Lib/Moya%20-%E7%BD%91%E7%BB%9C%E5%B0%81%E8%A3%85(RxSwift)/"/>
      <url>/2018/03/07/Swift/RxSwift/Lib/Moya%20-%E7%BD%91%E7%BB%9C%E5%B0%81%E8%A3%85(RxSwift)/</url>
      <content type="html"><![CDATA[<p><a href="https://zjqian.github.io/2017/03/13/moya/" target="_blank" rel="noopener">参考01</a><br><a href="https://www.jianshu.com/p/c1494681400b" target="_blank" rel="noopener">参考02</a></p><h1 id="①Moya"><a href="#①Moya" class="headerlink" title="①Moya"></a>①Moya</h1><blockquote><p>Swift我们用Alamofire来做网络库.而Moya在Alamofire的基础上又封装了一层<br>官方说moya有以下特性:</p></blockquote><ul><li>编译时检查正确的API端点访问.</li><li>使你定义不同端点枚举值对应相应的用途更加明晰.</li><li>提高测试地位从而使单元测试更加容易.</li></ul><p><img src="http://ot0mms4k8.bkt.clouddn.com/%20Swift-Lib-Moya-%E7%BD%91%E7%BB%9C%E5%B0%81%E8%A3%85%28RxSwift%29-001.png" alt="001"></p><h1 id="②开始"><a href="#②开始" class="headerlink" title="②开始"></a>②开始</h1><h2 id="❶创建枚举API"><a href="#❶创建枚举API" class="headerlink" title="❶创建枚举API"></a>❶创建枚举API</h2><blockquote><p>首先创建一个 enum 来枚举你所有的 API targets<br>关于这个API的信息放在这个枚举类型中</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">APIManager</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> getNewsLatest      <span class="comment">//获取最新消息</span></span><br><span class="line">   <span class="keyword">case</span> getStartImage      <span class="comment">//启动界面图像获取</span></span><br><span class="line">   <span class="keyword">case</span> getVersion(<span class="type">String</span>) <span class="comment">//软件版本查询</span></span><br><span class="line">   <span class="keyword">case</span> getThemes          <span class="comment">//主题日报列表查看</span></span><br><span class="line">   <span class="keyword">case</span> getNewsDetail(<span class="type">Int</span>) <span class="comment">//获取新闻详情</span></span><br><span class="line">   <span class="keyword">case</span> create(title: <span class="type">String</span>, body: <span class="type">String</span>, userId: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="❷实现TargetType协议"><a href="#❷实现TargetType协议" class="headerlink" title="❷实现TargetType协议"></a>❷实现TargetType协议</h2><blockquote><p>在这里,可以设置请求的参数,例如url……method……para等.</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">APIManager</span>: <span class="title">TargetType</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// The target's base `URL`.</span></span><br><span class="line"><span class="keyword">var</span> baseURL: <span class="type">URL</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="type">URL</span>.<span class="keyword">init</span>(string: <span class="string">"http://news-at.zhihu.com/api/"</span>)!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// The path to be appended to `baseURL` to form the full `URL`.</span></span><br><span class="line"><span class="keyword">var</span> path: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">       <span class="keyword">case</span> .getNewsLatest:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"4/news/latest"</span></span><br><span class="line">       <span class="keyword">case</span> .getStartImage:</span><br><span class="line">            <span class="comment">//start-image 后为图像分辨率，接受任意的 number*number 格式， number 为任意非负整数，返回值均相同。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"4/start-image/1080*1776"</span></span><br><span class="line">       <span class="keyword">case</span> .getVersion(<span class="keyword">let</span> version):</span><br><span class="line">            <span class="comment">//URL 最后部分的数字代表所安装『知乎日报』的版本</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"4/version/ios/"</span> + version</span><br><span class="line">       <span class="keyword">case</span> .getThemes:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"4/themes"</span></span><br><span class="line">       <span class="keyword">case</span> .getNewsDetail(<span class="keyword">let</span> id):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"4/news/<span class="subst">\(id)</span>"</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// The HTTP method used in the request.</span></span><br><span class="line"><span class="comment">// 设置Get、POST</span></span><br><span class="line"><span class="keyword">var</span> method: <span class="type">Moya</span>.<span class="type">Method</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> .<span class="keyword">get</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// The parameters to be incoded in the request.</span></span><br><span class="line"><span class="keyword">var</span> parameters: [<span class="type">String</span>: <span class="type">Any</span>]? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// The method used for parameter encoding.</span></span><br><span class="line"><span class="keyword">var</span> parameterEncoding: <span class="type">ParameterEncoding</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">URLEncoding</span>.<span class="keyword">default</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// Provides stub data for use in testing.</span></span><br><span class="line"><span class="keyword">var</span> sampleData: <span class="type">Data</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.data(using: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)!</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// The type of HTTP task to be performed.</span></span><br><span class="line"><span class="keyword">var</span> task: <span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> .request</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// Whether or not to perform Alamofire validation. Defaults to `false`.</span></span><br><span class="line"><span class="keyword">var</span> validate: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="❸使用"><a href="#❸使用" class="headerlink" title="❸使用"></a>❸使用</h1><blockquote><p>Moya的使用非常简单，通过TargetType协议定义好每个target之后，就可以直接使用Moya开始发送网络请求了。就像这样</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> provider = <span class="type">MoyaProvider</span>&lt;<span class="type">APIManager</span>&gt;()</span><br><span class="line">provider.request(.getNewsLatest) &#123; result <span class="keyword">in</span></span><br><span class="line"><span class="comment">// do something with result</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>❹❺</p><h2 id="③配合RxSwift"><a href="#③配合RxSwift" class="headerlink" title="③配合RxSwift"></a>③配合RxSwift</h2><blockquote><p>Moya提供了非常方面的RxSwift扩展</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> provider = <span class="type">RxMoyaProvider</span>&lt;<span class="type">APIManager</span>&gt;()</span><br><span class="line">provider.request(.getNewsLatest)</span><br><span class="line">        .filterSuccessfulStatusCodes()</span><br><span class="line">        .mapJSON()</span><br><span class="line">        .subscribe(onNext: &#123; (json) <span class="keyword">in</span></span><br><span class="line">         <span class="comment">//do something with posts</span></span><br><span class="line">        <span class="built_in">print</span>(json)</span><br><span class="line">        &#125;)</span><br><span class="line">        .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>RxMoyaProvider</td><td>是MoyaProvider的子类，是对RxSwift的扩展</td></tr><tr><td>filterSuccessfulStatusCodes()</td><td>是Moya为RxSwift提供的扩展方法，可以得到成功地网络请求，忽略其他的</td></tr><tr><td>mapJSON()</td><td>是Moya RxSwift的扩展方法，可以把返回的数据解析成 JSON 格式</td></tr><tr><td>subscribe</td><td>是一个RxSwift的方法,对经过一层一层处理的 Observable 订阅一个 onNext 的 observer，一旦得到 JSON 格式的数据，就会经行相应的处理</td></tr><tr><td>addDisposableTo(disposeBag)</td><td>是 RxSwift 的一个自动内存处理机制，跟ARC有点类似，会自动清理不需要的对象</td></tr><tr><td></td><td></td></tr></tbody></table><h1 id="④配合HandyJSON"><a href="#④配合HandyJSON" class="headerlink" title="④配合HandyJSON"></a>④配合HandyJSON</h1><blockquote><p>❶网络请求紧密连接着数据层（Model），具体地说，一般需要建立一个类用来统一管理数据，然后把得到的 JSON 数据映射到数据层（Model）</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MenuModel</span>: <span class="title">HandyJSON</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> others: [<span class="type">ThemeModel</span>]?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThemeModel</span>: <span class="title">HandyJSON</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> thumnail: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">Int</span>?</span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br></pre></td></tr></table></figure><blockquote><p>❷创建ViewModel类,创建具体请求方法</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MenuViewModel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> provider = <span class="type">RxMoyaProvider</span>&lt;<span class="type">APIManager</span>&gt;()</span><br><span class="line">  <span class="keyword">var</span> dispose = <span class="type">DisposeBag</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">getThemes</span><span class="params">(completed: @escaping <span class="params">(<span class="number">_</span> menuModel: MenuModel)</span></span></span> -&gt;())&#123;</span><br><span class="line">        provider.reuest(.getThemes)</span><br><span class="line">                .mapModel(<span class="type">MenuModel</span>.<span class="keyword">self</span>)</span><br><span class="line">                .subscribe( onNext: &#123; (model) <span class="keyword">in</span> </span><br><span class="line">                                      completed(model)&#125;,</span><br><span class="line">                            onError:&#123; (error) <span class="keyword">in</span> &#125;,</span><br><span class="line">                            onCompleted:<span class="literal">nil</span>,</span><br><span class="line">                            onDisposed:<span class="literal">nil</span>,</span><br><span class="line">                           )</span><br><span class="line">               .addDisposableTo(dispose)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里是将请求的数据通过闭包传了出去,当然也可以不那么做.个人喜好问题.<br>这里是为 RxSwift 中的 ObservableType和 Response写一个简单的扩展方法 mapModel，利用我们写好的Model 类，一步就把JSON数据映射成 model</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ObservableType</span> <span class="title">where</span> <span class="title">E</span> == <span class="title">Response</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">mapModel</span> &lt;T: HandyJSON&gt;<span class="params">(<span class="number">_</span> type: T.<span class="keyword">Type</span>)</span></span>-&gt; <span class="type">Observable</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> flatMap &#123; response -&gt; <span class="type">Observable</span>&lt;<span class="type">T</span>&gt; <span class="keyword">in</span> </span><br><span class="line">          <span class="keyword">return</span> <span class="type">Observable</span>.just(response.mapModel(<span class="type">T</span>.<span class="keyword">self</span>))</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="class"><span class="keyword">extension</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">mapModel</span>&lt;T: HandyJSON&gt;<span class="params">(<span class="number">_</span> type: T.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">         <span class="keyword">let</span> jsonString = <span class="type">String</span>.<span class="keyword">init</span>(data: data,encoding: .utf8)</span><br><span class="line">         <span class="keyword">return</span> <span class="type">JSONDeserializer</span>&lt;<span class="type">T</span>&gt;.deserializeFrom(json: jsonString)!</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>#⑤配合ObjectMapper</p><p>##❷❶创建model类</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">DetailModel</span>: <span class="title">Mappable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> body = <span class="type">String</span>()</span><br><span class="line">        <span class="keyword">var</span> image_source: <span class="type">String</span>?</span><br><span class="line">  <span class="keyword">var</span> title = <span class="type">String</span>()</span><br><span class="line">  <span class="keyword">var</span> image: <span class="type">String</span>?</span><br><span class="line">  <span class="keyword">var</span> share_url = <span class="type">String</span>()</span><br><span class="line">  <span class="keyword">var</span> js = <span class="type">String</span>()</span><br><span class="line">  <span class="keyword">var</span> recommenders = [[<span class="type">String</span>: <span class="type">String</span>]]()</span><br><span class="line">  <span class="keyword">var</span> ga_prefix = <span class="type">String</span>()</span><br><span class="line">  <span class="keyword">var</span> section: <span class="type">DetailSectionModel</span>?</span><br><span class="line">  <span class="keyword">var</span> type = <span class="type">Int</span>()</span><br><span class="line">  <span class="keyword">var</span> id = <span class="type">Int</span>()</span><br><span class="line">  <span class="keyword">var</span> css = [<span class="type">String</span>]()</span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">mapping</span><span class="params">(<span class="built_in">map</span>: Map)</span></span> &#123;</span><br><span class="line">         body &lt;- <span class="built_in">map</span>[<span class="string">"body"</span>]</span><br><span class="line">  image_source &lt;- <span class="built_in">map</span>[<span class="string">"image_source"</span>]</span><br><span class="line">  title &lt;- <span class="built_in">map</span>[<span class="string">"title"</span>]</span><br><span class="line">  image &lt;- <span class="built_in">map</span>[<span class="string">"image"</span>]</span><br><span class="line">  share_url &lt;- <span class="built_in">map</span>[<span class="string">"share_url"</span>]</span><br><span class="line">  js &lt;- <span class="built_in">map</span>[<span class="string">"js"</span>]</span><br><span class="line">  recommenders &lt;- <span class="built_in">map</span>[<span class="string">"recommenders"</span>]</span><br><span class="line">  ga_prefix &lt;- <span class="built_in">map</span>[<span class="string">"ga_prefix"</span>]</span><br><span class="line">  section &lt;- <span class="built_in">map</span>[<span class="string">"section"</span>]</span><br><span class="line">  type &lt;- <span class="built_in">map</span>[<span class="string">"type"</span>]</span><br><span class="line">  id &lt;- <span class="built_in">map</span>[<span class="string">"id"</span>]</span><br><span class="line">  css &lt;- <span class="built_in">map</span>[<span class="string">"css"</span>]</span><br><span class="line">     &#125;</span><br><span class="line">  reuired <span class="keyword">init</span>?(<span class="built_in">map</span>: <span class="type">Map</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>❷使用 ObjectMapper ，需要让自己的 Model 类使用 Mappable 协议，这个协议包括两个方法：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">required</span> <span class="keyword">init</span>?(<span class="built_in">map</span>: <span class="type">Map</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapping</span><span class="params">(<span class="built_in">map</span>: Map)</span></span> &#123;&#125;<span class="comment">//在 mapping 方法中，用 &lt;- 操作符来处理和映射你的 JSON数据</span></span><br></pre></td></tr></table></figure><blockquote><p>❸数据类建立好之后，还需要为 RxSwift 中的 Observable 写一个简单的扩展方法 mapObject，利用写好的model 类，一步就把JSON 数据映射成一个个 model</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">func</span> <span class="title">mapObject</span>&lt;T: Mappable&gt;<span class="params">(type: T.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">Observale</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">self</span>.<span class="built_in">map</span> &#123; response <span class="keyword">in</span> </span><br><span class="line">               <span class="comment">//if response is a dictionary, then use ObjectMapper to map the dictionary</span></span><br><span class="line">               <span class="comment">//if not throw an error</span></span><br><span class="line">               <span class="keyword">guard</span> <span class="keyword">let</span> dict = response an? [<span class="type">String</span>: <span class="type">Any</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">                     thow <span class="type">RxSwiftMoyaError</span>.<span class="type">ParseJSONError</span></span><br><span class="line">               &#125;</span><br><span class="line">                 <span class="keyword">return</span> <span class="type">Mapper</span>&lt;<span class="type">T</span>&gt;().<span class="built_in">map</span>(<span class="type">JSON</span>: dict)!</span><br><span class="line">               &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="function"><span class="keyword">func</span> <span class="title">mapArray</span>&lt;T: Mappable&gt;<span class="params">(type: T.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">Observale</span>&lt;[<span class="type">T</span>]&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.<span class="built_in">map</span> &#123; response <span class="keyword">in</span> </span><br><span class="line">               <span class="comment">//if response is an array of dictionaries, then use ObjectMapper to map the dictionary</span></span><br><span class="line">               <span class="comment">//if not, throw an error</span></span><br><span class="line">               </span><br><span class="line">               <span class="keyword">guard</span> <span class="keyword">let</span> array = response <span class="keyword">as</span>? [<span class="type">Any</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">                     thow <span class="type">RxSwiftMoyaError</span>.<span class="type">ParseJSONError</span></span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">guard</span> <span class="keyword">let</span> dicts = array <span class="keyword">as</span>? [[<span class="type">String</span>: <span class="type">Any</span>]] <span class="keyword">else</span> &#123;</span><br><span class="line">                     thow <span class="type">RxSwiftMoyaError</span>.<span class="type">ParseJSONError</span></span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">guard</span> <span class="keyword">let</span> dicts = array <span class="keyword">as</span>? [[<span class="type">String</span>: <span class="type">Any</span>]] <span class="keyword">else</span> &#123;</span><br><span class="line">                     thow <span class="type">RxSwiftMoyaError</span>.<span class="type">ParseJSONError</span></span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">return</span> <span class="type">Mapper</span>&lt;<span class="type">T</span>&gt;().mapArray(<span class="type">JSONArray</span>: dicts)!</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="class"><span class="keyword">enum</span> <span class="title">RXSwiftMoyaError</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="type">ParaseJSONError</span></span><br><span class="line">           <span class="keyword">case</span> <span class="type">OtherError</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="class"><span class="keyword">extension</span> <span class="title">RxSwiftMoyaError</span>: <span class="title">Swift</span>.<span class="title">Error</span> </span>&#123;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><ul><li>mapObject 方法处理单个对象，mapArray 方法处理对象数组</li><li>果传进来的数据 response 是一个 dictionary，那么就利用 ObjectMapper 的 map方法映射这些数据，这个方法会调用你之前在 mapping方法里面定义的逻辑</li><li>如果 response 不是一个 dictionary， 那么就抛出一个错误</li><li>在底部自定义了简单的Error，继承了Swift 的 Error类，在实际应用过程中可以根据需要提供自己想要的 Error</li></ul><blockquote><p>❹运行请求方法</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">calss <span class="type">DetailViewModel</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">let</span> provider = <span class="type">RxMoyaProvider</span>&lt;<span class="type">APIManager</span>&gt;()</span><br><span class="line">      <span class="function"><span class="keyword">func</span> <span class="title">getNewsDetail</span><span class="params">(id: Int)</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">DetailModel</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> provider.request(.getNewDetail(id))</span><br><span class="line">                       .filterSuccesssfulStatusCodes()</span><br><span class="line">                       .mapJSON()</span><br><span class="line">                       .mapObject(type: <span class="type">DetailModel</span>.<span class="keyword">self</span>)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Lib </category>
          
          <category> Moya </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>RxSwift + ReactorKit 构建信息流框架</title>
      <link href="/2018/03/07/Swift/RxSwift/Error/RxSwift-Error/"/>
      <url>/2018/03/07/Swift/RxSwift/Error/RxSwift-Error/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> RxSwift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Error </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-Lib-Moya</title>
      <link href="/2018/03/07/Swift/RxSwift/Lib/RxSwift-Lib-Moya/"/>
      <url>/2018/03/07/Swift/RxSwift/Lib/RxSwift-Lib-Moya/</url>
      <content type="html"><![CDATA[<h1 id="关于moya"><a href="#关于moya" class="headerlink" title="关于moya"></a>关于moya</h1><blockquote><p>Moya在Alamofire的基础上又封装一层</p></blockquote><h2 id="moya有以下特性"><a href="#moya有以下特性" class="headerlink" title="moya有以下特性"></a>moya有以下特性</h2><ul><li>编译时检查正确的API端点访问.</li><li>使你定义不同端点枚举值对应相应的用途更加明晰.</li><li>提高测试地位从而使单元测试更加容易</li></ul><h1 id="枚举API"><a href="#枚举API" class="headerlink" title="枚举API"></a>枚举API</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum  APIManaager &#123;</span><br><span class="line">    case getNewsLatest     //获取最新消息</span><br><span class="line">    case getStartImage     // 启动界面图像获取</span><br><span class="line">    case getVersion(String)//软件版本查询</span><br><span class="line">    case getThemes         //主题日报列表查看</span><br><span class="line">    case getNewsDetail(Int)//获取新闻详情</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现TargetType协议"><a href="#实现TargetType协议" class="headerlink" title="实现TargetType协议"></a>实现TargetType协议</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">APIManager</span>: <span class="title">TargetType</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// base URL</span></span><br><span class="line"><span class="keyword">var</span> baseURL: <span class="type">URL</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="type">URL</span>.<span class="keyword">init</span>(string: <span class="string">"http://news-at.zhihu.com/api/"</span>)!</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 请求路径</span></span><br><span class="line"><span class="keyword">var</span> path: <span class="type">String</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">       <span class="keyword">case</span> .getNewsLatest:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"4/news/latest"</span></span><br><span class="line"> </span><br><span class="line">       <span class="keyword">case</span> .getStartImage:</span><br><span class="line">            <span class="comment">//start-image 后为图像分辨率，接受任意的 number*number 格式， number 为任意非负整数，返回值均相同。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"4/start-image/1080*1776"</span></span><br><span class="line"> </span><br><span class="line">       <span class="keyword">case</span> .getVersion(<span class="keyword">let</span> version):</span><br><span class="line">            <span class="comment">//URL 最后部分的数字代表所安装『知乎日报』的版本</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"4/version/ios/"</span> + version</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">case</span> .getThemes:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"4/themes"</span></span><br><span class="line"> </span><br><span class="line">       <span class="keyword">case</span> .getNewsDetail(<span class="keyword">let</span> id):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"4/news/<span class="subst">\(id)</span>"</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// The HTTP method used in the request</span></span><br><span class="line"><span class="keyword">var</span> method: <span class="type">Moya</span>.<span class="type">Method</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> .<span class="keyword">get</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// The parameters to be incoded in the request.</span></span><br><span class="line"><span class="keyword">var</span> parameters: [<span class="type">String</span>: <span class="type">Any</span>]? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// The method used for parameter encoding.</span></span><br><span class="line"><span class="keyword">var</span> parameterEncoding: <span class="type">ParameterEncoding</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">URLEncoding</span>.<span class="keyword">default</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Provides stub data for use in testing.</span></span><br><span class="line"><span class="keyword">var</span> sampleData: <span class="type">Data</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.data(using: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)!</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// The type of HTTP task to be performed.</span></span><br><span class="line"><span class="keyword">var</span> task: <span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> .request</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Whether or not to perform Alamofire validation. Defaults to `false`.</span></span><br><span class="line"><span class="keyword">var</span> validate: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#使用</p><blockquote><p>Moya的使用非常简单，通过TargetType协议定义好每个target之后，就可以直接使用Moya开始发送网络请求了</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> provider = <span class="type">MoyaProvider</span>&lt;<span class="type">APIManager</span>&gt;()</span><br><span class="line">    provider.request(.getNewsLatest) &#123;  result <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// do something with result</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="配合RxSwift"><a href="#配合RxSwift" class="headerlink" title="配合RxSwift"></a>配合RxSwift</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> provider = <span class="type">RxMoyaProvider</span>&lt;<span class="type">APIManager</span>&gt;()</span><br><span class="line"> provider.request(.getNewsLatest)</span><br><span class="line">         .filterSuccessfulStatusCodes()</span><br><span class="line">         .mapJSON()</span><br><span class="line">         .subscribe(onNext: &#123; (json) <span class="keyword">in</span></span><br><span class="line">             <span class="comment">//do something with posts</span></span><br><span class="line">             <span class="built_in">print</span>(json)</span><br><span class="line">          &#125;)</span><br><span class="line">         .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><ul><li><p>RxMoyaProvider是MoyaProvider的子类，是对RxSwift的扩展</p></li><li><p>filterSuccessfulStatusCodes()是Moya为RxSwift提供的扩展方法，顾名思义，可以得到成功地网络请求，忽略其他的</p></li><li><p>mapJSON()也是Moya RxSwift的扩展方法，可以把返回的数据解析成 JSON 格式</p></li><li><p>subscribe 是一个RxSwift的方法，对经过一层一层处理的 Observable 订阅一个 onNext 的 observer，一旦得到 JSON 格式的数据，就会经行相应的处理</p></li><li><p>addDisposableTo(disposeBag) 是 RxSwift 的一个自动内存处理机制，跟ARC有点类似，会自动清理不需要的对象</p></li></ul><h1 id="配合HandyJSON"><a href="#配合HandyJSON" class="headerlink" title="配合HandyJSON"></a>配合HandyJSON</h1><blockquote><p>在实际应用过程中网络请求往往紧密连接着数据层（Model），具体地说，在我们的这个例子中，一般我们需要建立一个类用来统一管理数据，然后把得到的 JSON 数据映射到数据层（Model）</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MenuModel</span>: <span class="title">HandyJSON</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> others: [<span class="type">ThemeModel</span>]?</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThemeModel</span>: <span class="title">HandyJSON</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> color: <span class="type">String</span>?</span><br><span class="line"><span class="keyword">var</span> thumbnail: <span class="type">String</span>?</span><br><span class="line"><span class="keyword">var</span> id: <span class="type">Int</span>?</span><br><span class="line"><span class="keyword">var</span> description: <span class="type">String</span>?</span><br><span class="line"><span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>创建ViewModel类,创建具体请求方法:</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MenuViewModel</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> provider = <span class="type">RxMoyaProvider</span>&lt;<span class="type">APIManager</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> dispose = <span class="type">DisposeBag</span>()</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getThemes</span><span class="params">(completed: @escaping <span class="params">(<span class="number">_</span> menuModel: MenuModel)</span></span></span> -&gt; ())&#123;</span><br><span class="line"> </span><br><span class="line">provider</span><br><span class="line">.request(.getThemes)</span><br><span class="line">.mapModel(<span class="type">MenuModel</span>.<span class="keyword">self</span>)</span><br><span class="line">.subscribe(onNext: &#123; (model) <span class="keyword">in</span></span><br><span class="line"> </span><br><span class="line">completed(model)</span><br><span class="line">&#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line"> </span><br><span class="line">&#125;, onCompleted: <span class="literal">nil</span>, onDisposed: <span class="literal">nil</span>).addDisposableTo(dispose)</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将请求的数据通过闭包传了出去,当然也可以不那么做.个人喜好问题..<br>这里是为 RxSwift 中的 ObservableType和 Response写一个简单的扩展方法 mapModel，利用我们写好的Model 类，一步就把JSON数据映射成 model</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ObservableType</span> <span class="title">where</span> <span class="title">E</span> == <span class="title">Response</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">mapModel</span>&lt;T: HandyJSON&gt;<span class="params">(<span class="number">_</span> type: T.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> flatMap &#123; response -&gt; <span class="type">Observable</span>&lt;<span class="type">T</span>&gt; <span class="keyword">in</span></span><br><span class="line"><span class="keyword">return</span> <span class="type">Observable</span>.just(response.mapModel(<span class="type">T</span>.<span class="keyword">self</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapModel</span>&lt;T: HandyJSON&gt;<span class="params">(<span class="number">_</span> type: T.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line"><span class="keyword">let</span> jsonString = <span class="type">String</span>.<span class="keyword">init</span>(data: data, encoding: .utf8)</span><br><span class="line"><span class="keyword">return</span> <span class="type">JSONDeserializer</span>&lt;<span class="type">T</span>&gt;.deserializeFrom(json: jsonString)!</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> RxSwift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Error </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Lib-Reusable-优雅地使用ReusableIdentifier</title>
      <link href="/2018/03/02/Swift/Swift/Lib/Reusable%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8ReusableIdentifier/"/>
      <url>/2018/03/02/Swift/Swift/Lib/Reusable%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8ReusableIdentifier/</url>
      <content type="html"><![CDATA[<h1 id="cell的重用机制与标示符"><a href="#cell的重用机制与标示符" class="headerlink" title="cell的重用机制与标示符"></a>cell的重用机制与标示符</h1><blockquote><p>苹果为了保准UITableView视图的性能，使用了cell的重用机制，cell可以通过重用标示符（reusableIdentifier）进行复用，默认的注册cell和获取cell的方法中，需要传入一个字符串作重用标示符<br>但这种方式很容易出错，而且使用起来也相当别扭，一种普遍的解决方式，就是直接只用类名作为重用标示符:</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">tableView.registerClass(<span class="type">UITableView</span>.<span class="keyword">self</span>,forCellReuseIdentifier:<span class="type">String</span>(<span class="type">UITableViewCell</span>.<span class="keyword">self</span>))</span><br><span class="line">tableView.dequeueReusableCellWithIdentifier(<span class="type">String</span>(<span class="type">UITableViewCell</span>.<span class="keyword">self</span>))</span><br></pre></td></tr></table></figure><blockquote><p>这种写法依然繁琐，每次传入一个类并把它转化成字符串<br>so,可借助Swift的泛型特性，我们可以有更加优雅的实现方式</p></blockquote><h1 id="使用协议"><a href="#使用协议" class="headerlink" title="使用协议"></a>使用协议</h1><ul><li><a href="http://swift.gg/2016/01/27/generic-tableviewcells/index.html" target="_blank" rel="noopener">使用泛型来优化 TableView Cells 的使用体验</a>详细介绍了如何通过协议+泛型的方式，优化TableView Cells 的使用体验</li></ul><h2 id="具体的做法很简单"><a href="#具体的做法很简单" class="headerlink" title="具体的做法很简单:"></a>具体的做法很简单:</h2><blockquote><p>❶协议</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明了一个协议</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Reusable</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">var</span> reuseIdentifier: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供并默认实现了一个reuseIdentifier静态属性</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reusable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">var</span> reuseIdentifier: <span class="type">String</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="type">String</span> (<span class="type">Self</span>) </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>❷提供一个注册和获取重用cell的方法<br>这样只要cell遵守了Reusable协议，就可以通过上面两个方法注册复用cell了。具体的代码和使用<a href="http://swift.gg/2016/01/27/generic-tableviewcells/index.html" target="_blank" rel="noopener">使用泛型来优化 TableView Cells 的使用体验</a></p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerReusableCell</span>&lt;T: UITableViewCell where T: Reusable&gt;<span class="params">(<span class="number">_</span>: T.<span class="keyword">Type</span>)</span></span> &#123; </span><br><span class="line">     <span class="keyword">self</span>.registerClass(<span class="type">T</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="type">T</span>.reuseIdentifier) </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">dequeueReusableCell</span>&lt;T: UITableViewCell where T: Reusable&gt;<span class="params">(indexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">T</span> &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span>.dequeueReusableCellWithIdentifier(<span class="type">T</span>.reuseIdentifier, forIndexPath: indexPath) <span class="keyword">as</span>! <span class="type">T</span> </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><blockquote><p>cell必须遵守了Reusable协议，虽然通过让UITableViewCell遵守这个协议的方式，避免每个UITableViewCell子cell都写一遍，但这依然还不是最理想的解决方式。最理想的解决方式，应该是只需要调用方法，不需要UITableViewCell做任何修改，为此我们可以使用结构体，而非协议来实现</p></blockquote><h1 id="使用结构体"><a href="#使用结构体" class="headerlink" title="使用结构体"></a>使用结构体</h1><blockquote><p>使用泛型定义一个ReusableIdentifier结构体，有一个identifier的不变量</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">ReusableIdentifier</span> &lt;<span class="title">T</span>: <span class="title">UIView</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">let</span> identifier: string</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">init</span> () &#123;</span><br><span class="line">          identifier = <span class="type">String</span>(<span class="type">T</span>.<span class="type">Self</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注册的时候就非常简单</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">tableview.register(<span class="type">UITableViewCell</span>.<span class="keyword">self</span>)</span><br></pre></td></tr></table></figure><blockquote><p>同样的，可以为UITableView实现一个dequeue方法</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@warn_unused_result</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">dequeue</span>&lt;T: UICollectionViewCell&gt;<span class="params">(indexPath: NSIndexPath)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> rid = <span class="type">ReusableIdentifier</span>&lt;<span class="type">T</span>&gt;()</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> cell = dequeueReusableCellWithReuseIdentifier(rid.identifier, forIndexPath: indexPath) <span class="keyword">as</span>? <span class="type">T</span> <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="built_in">assertionFailure</span>(<span class="string">"No identifier(<span class="subst">\(rid.identifier)</span>) found for <span class="subst">\(T.<span class="keyword">self</span>)</span>"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">T</span>.<span class="keyword">init</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用的时候只需要指定cell的类型，传入indexPath即可</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cell: <span class="type">UITableViewCell</span> = tableview.dequeue(indexPath)</span><br></pre></td></tr></table></figure><ul><li><p>通过引入一个结构体，利用泛型特性，不需要对已有的类型做任何修改，只需要替换注册和复用cell时调用的方法，我们就可以非常优雅的复用Tableview Cell。</p></li><li><p>参考上面的方法，我们可以借助ReusableIdentifier结构体，为UICollectionView实现相应的方法</p></li></ul>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Lib </category>
          
          <category> Reusable </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Lib </tag>
            
            <tag> Reusable </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift + ReactorKit 构建信息流框架</title>
      <link href="/2018/03/02/Swift/RxSwift/Func/RxSwift%20+%20ReactorKit%20%E6%9E%84%E5%BB%BA%E4%BF%A1%E6%81%AF%E6%B5%81%E6%A1%86%E6%9E%B6/"/>
      <url>/2018/03/02/Swift/RxSwift/Func/RxSwift%20+%20ReactorKit%20%E6%9E%84%E5%BB%BA%E4%BF%A1%E6%81%AF%E6%B5%81%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/dff7b0368d2b" target="_blank" rel="noopener">https://www.jianshu.com/p/dff7b0368d2b</a></p>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> RxSwift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Func </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Lib-Then协议库-初始化方式</title>
      <link href="/2018/03/02/Swift/Swift/Lib/Then%E5%8D%8F%E8%AE%AE%E5%BA%93-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/03/02/Swift/Swift/Lib/Then%E5%8D%8F%E8%AE%AE%E5%BA%93-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="写法对比"><a href="#写法对比" class="headerlink" title="写法对比"></a>写法对比</h1><blockquote><p>普通的写法，先看通过Block创建对象的写法<br>优点：代码整合在一个闭包里面，可读性强</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="number">_</span> = &#123; () -&gt; <span class="type">UILabel</span> <span class="keyword">in</span> </span><br><span class="line"> <span class="keyword">let</span>  label = <span class="type">UILab</span>()</span><br><span class="line"> view.addSubview(label)</span><br><span class="line"> label.text = <span class="string">"myLabel"</span></span><br><span class="line"> label.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">18</span>)</span><br><span class="line"> label.center = <span class="keyword">self</span>.view.center</span><br><span class="line"> label.bounds = <span class="type">CGRect</span>.<span class="keyword">init</span>(x : <span class="number">0</span>, y : <span class="number">0</span>, width : <span class="number">100</span>, height : <span class="number">50</span>)</span><br><span class="line"> <span class="keyword">return</span> label</span><br><span class="line"> &#125;()</span><br></pre></td></tr></table></figure><blockquote><p>在Block外初始化一个对象，再传进闭包进行设值，统一用$0取参数对象，不用再去烦如何命名了。当然也可以命名，参考后文的写法 不过有个缺点：里面的$0没法自动联想出属性，手敲几行代码你就会蓝瘦香菇</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="number">_</span> =:<span class="type">UILabel</span> &#123;</span><br><span class="line">  view.addSubview($<span class="number">0</span>)</span><br><span class="line">  $<span class="number">0</span>.text = <span class="string">"测试"</span></span><br><span class="line">  $<span class="number">0</span>.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">18</span>)</span><br><span class="line">  $<span class="number">0</span>.center = <span class="keyword">self</span>.view.center</span><br><span class="line">  $<span class="number">0</span>.bounds = <span class="type">CGRect</span>.<span class="keyword">init</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span>,height: <span class="number">50</span>)</span><br><span class="line">  <span class="keyword">return</span> $<span class="number">0</span></span><br><span class="line">&#125;(<span class="type">UILabel</span>())</span><br></pre></td></tr></table></figure><blockquote><p>用Then协议库的初始化写法<br>比上面的代码更简洁，不用写return了，而且里面的$0还能自动联想。优点：暂时没有吐槽点</p></blockquote><blockquote><p>带参数，可自行命名</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="number">_</span> = <span class="type">UILabel</span>().then_Any&#123; (label) <span class="keyword">in</span></span><br><span class="line">    label.backgroundColor = .blue</span><br><span class="line">    label.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">18</span>)</span><br><span class="line">    label.textAlinment = .center</span><br><span class="line">    label.text = <span class="string">"Then协议库写法"</span></span><br><span class="line">    label.frame = <span class="type">CGRect</span>.<span class="keyword">init</span>(x: <span class="number">20</span>, y:<span class="number">200</span>, width: <span class="number">150</span>, height:<span class="number">40</span>)</span><br><span class="line">      <span class="comment">// 不会循环引用(已测试)</span></span><br><span class="line">     <span class="keyword">self</span>.view.addSubview(label)</span><br></pre></td></tr></table></figure><blockquote><p>(推荐)无参数，无需命名，用$0取参数，可自动联想属性(推荐)</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="number">_</span> = <span class="type">UILabel</span>().then_Any&#123;</span><br><span class="line">   $<span class="number">0</span>.backgroundColor = .blue</span><br><span class="line">   $<span class="number">0</span>.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">18</span>)</span><br><span class="line">   $<span class="number">0</span>.textAlignment = .center</span><br><span class="line">   $<span class="number">0</span>.text = <span class="string">"Then库写法1.1"</span></span><br><span class="line">   $<span class="number">0</span>.frame = <span class="type">CGRect</span>.<span class="keyword">init</span>(x: <span class="number">200</span>, y: <span class="number">200</span>, height: <span class="number">50</span>)</span><br><span class="line">   <span class="keyword">self</span>.view.adSubview($<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.0 带参数，可自行命名</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> label_Any0 = <span class="type">UILabel</span>().then&#123; (label) <span class="keyword">in</span></span><br><span class="line">    label.backgroundColor = .blue</span><br><span class="line">    label.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">18</span>)</span><br><span class="line">    label.textAlignment = .center</span><br><span class="line">    label.text = <span class="string">"Then库写法_2.0"</span></span><br><span class="line">    label.frame = <span class="type">CGRect</span>.<span class="keyword">init</span>(x: <span class="number">200</span>, y:<span class="number">240</span>, width:<span class="number">150</span>, height: <span class="number">40</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">self</span>.view.addSubview(label_Any0)</span><br></pre></td></tr></table></figure><blockquote><p>2.1 (推荐)无参数，无需命名，用$0取参数，可自动联想属性</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="number">_</span> = <span class="type">UILabel</span>().then &#123;</span><br><span class="line">   $<span class="number">0</span>.backgroundColor = .blue</span><br><span class="line">   $<span class="number">0</span>.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">18</span>)</span><br><span class="line">   $<span class="number">0</span>.textAlignment = .center</span><br><span class="line">   $<span class="number">0</span>.text = <span class="string">"Then库写法_2.1"</span></span><br><span class="line">   $<span class="number">0</span>.frame = <span class="type">CGRect</span>.<span class="keyword">init</span>(x: <span class="number">200</span>, y: <span class="number">260</span>,width: <span class="number">150</span>,height: <span class="number">40</span>)</span><br><span class="line">   <span class="keyword">self</span>.view.addSubview($<span class="number">0</span>)</span><br></pre></td></tr></table></figure><blockquote><p>栗子：某工厂方法 </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">label</span> (<span class="title">withFrame</span> <span class="title">frame</span>: <span class="title">CGRect</span>, <span class="title">text</span>: <span class="title">String</span>?, <span class="title">font</span>: <span class="title">UIFont</span>)-&gt;<span class="title">UILabel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UILabel</span>.<span class="keyword">init</span>(frame: frame).then(block: &#123; (label) <span class="keyword">in</span> </span><br><span class="line">          label.text = text</span><br><span class="line">          label.textColor = <span class="type">UIColor</span>.black</span><br><span class="line">          label.backgroundColor = <span class="type">UIColor</span>.white</span><br><span class="line">          label.font = font</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>其实Then协议库只有十几行代码，但是能带来非常好的体验感，简约实用，不会出现循环引用。下面的代码可以复制到一个swift file中，直接用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Then</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Then</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">Any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">then_Any</span><span class="params">( block: <span class="params">(<span class="keyword">inout</span> <span class="keyword">Self</span>)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> copy = <span class="keyword">self</span></span><br><span class="line">        block(&amp;copy)</span><br><span class="line">        <span class="keyword">return</span> copy</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Then</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">AnyObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">then</span><span class="params">( block: <span class="params">(<span class="keyword">Self</span>)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">        block(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSObject</span>: <span class="title">Then</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/6cc1e21df6ac" target="_blank" rel="noopener">参考原文</a></p>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Lib </category>
          
          <category> Then </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>RxSwift+Moya+列表展示</title>
      <link href="/2018/03/01/Swift/RxSwift/Demo/RxSwift+Moya+%E5%88%97%E8%A1%A8%E5%B1%95%E7%A4%BA/"/>
      <url>/2018/03/01/Swift/RxSwift/Demo/RxSwift+Moya+%E5%88%97%E8%A1%A8%E5%B1%95%E7%A4%BA/</url>
      <content type="html"><![CDATA[<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><blockquote><p>根据网上demo仿写<a href="https://mp.weixin.qq.com/s/B-AdatKDkjknKCYorqSfEw" target="_blank" rel="noopener">原文</a></p></blockquote><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>Controller</td><td></td><td></td></tr><tr><td></td><td>LXFViewController.swift</td><td>主视图控制器</td></tr><tr><td>Extension</td><td></td><td></td></tr><tr><td></td><td>Response+ObjectMapper.swift</td><td>Response分类，Moya请求完进行Json转模型或模型数组</td></tr><tr><td>Model</td><td></td><td></td></tr><tr><td></td><td>LXFModel.swift</td><td>模型</td></tr><tr><td>Protocol</td><td></td><td></td></tr><tr><td></td><td>LXFViewModelType.swift</td><td>定义了模型协议</td></tr><tr><td>Tool</td><td></td><td></td></tr><tr><td></td><td>LXFNetworkTool.swift</td><td>封装Moya请求</td></tr><tr><td></td><td>LXFProgressHUD.swift</td><td>封装的HUD</td></tr><tr><td>View</td><td></td><td></td></tr><tr><td></td><td>LXFViewCell.swift</td><td>自定义cell</td></tr><tr><td></td><td>LXFViewCell.xib</td><td>cell的xib文件</td></tr><tr><td>ViewModel</td><td></td><td></td></tr><tr><td></td><td>LXFViewModel.swift</td><td>视图模型</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>RxSwift</td><td>想玩RxSwift的必备库</td></tr><tr><td>RxCocoa</td><td>对 UIKit Foundation 进行 Rx 化</td></tr><tr><td>NSObject+Rx</td><td>为我们提供 rx_disposeBag</td></tr><tr><td>Moya/RxSwift</td><td>为RxSwift专用提供，对Alamofire进行封装的一个网络请求库</td></tr><tr><td>ObjectMapper</td><td>Json转模型之必备良品</td></tr><tr><td>RxDataSources</td><td>帮助我们优雅的使用tableView的数据源方法</td></tr><tr><td>Then</td><td>提供快速初始化的语法糖</td></tr><tr><td>Kingfisher</td><td>图片加载库</td></tr><tr><td>SnapKit</td><td>视图约束库</td></tr><tr><td>Reusable</td><td>帮助我们优雅的使用自定义cell和view,不再出现Optional</td></tr><tr><td>MJRefresh</td><td>上拉加载、下拉刷新的库</td></tr><tr><td>SVProgressHUD</td><td>简单易用的HUD</td></tr></tbody></table><h3 id="Moya"><a href="#Moya" class="headerlink" title="Moya"></a>Moya</h3><ul><li>Moya是基于Alamofire的网络请求库</li><li>Moya的基础上添加了对RxSwift的接口支持</li></ul><blockquote><p>❶ 创建网络类型枚举，用来存放请求类型</p><ul><li>顺便设置相应的路径，等下统一取出来直接赋值即可</li></ul></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LXFNetworkCategory</span> : <span class="title">String</span> </span>&#123;</span><br><span class="line"> <span class="keyword">case</span> all = <span class="string">"all"</span></span><br><span class="line"> <span class="keyword">case</span> android = <span class="string">"Android"</span></span><br><span class="line"> <span class="keyword">case</span> ios = <span class="string">"iOS"</span></span><br><span class="line"> <span class="keyword">case</span> welfare = <span class="string">"福利"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>❷枚举写一个扩展，并遵循塄 TargetType，这个协议的Moya这个库规定的协议</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LXFNetworkTool</span> : <span class="title">TargetType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//baseURL 统一基本的URL</span></span><br><span class="line">    <span class="keyword">var</span> baseURL : <span class="type">URL</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="type">URL</span> (string : <span class="string">"http://xxxx/xx/"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//path字段会追加至baseURL后面</span></span><br><span class="line">    <span class="keyword">var</span> path : <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span>.data(<span class="keyword">let</span> type, <span class="keyword">let</span> size , <span class="keyword">let</span> index):</span><br><span class="line">             <span class="keyword">return</span> <span class="string">"(type.rawValue)/(size)/(index)"</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// HTTP的请求方式</span></span><br><span class="line">     <span class="keyword">var</span> method : <span class="type">Moya</span>.<span class="type">Method</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> .<span class="keyword">get</span></span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">      <span class="comment">//请求参数(会在请求时进行编码)</span></span><br><span class="line">      <span class="keyword">var</span> parameters : [<span class="type">String</span> : <span class="type">Any</span>]?&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">       <span class="comment">//参数编码方式(这里使用URL的默认方式)</span></span><br><span class="line">       <span class="keyword">var</span> parameterEncoding : <span class="type">ParameterEncoding</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="type">URLEncoding</span>.<span class="keyword">default</span></span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//用于单元测试，不需要的就像我一样随便写写</span></span><br><span class="line">       <span class="keyword">var</span> sampleData : <span class="type">Data</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"AAAA"</span>.data(using : .utf8)</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">      <span class="comment">//将要被执行的任务(请求：request 下载：upload 上传：download)</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">var</span> task : <span class="type">Task</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> .reuqest</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//是否执行Alamofire验证，默认值为false</span></span><br><span class="line">        <span class="keyword">var</span> validate : <span class="type">Bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>❸ 定义一个全局变量用于整个项目的网络请求<br>以使用这个全局变量来请求数据</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lxfNetTool = <span class="type">RxMoyaProvider</span>&lt;<span class="type">LXFNetworkTool</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="RxDataSources"><a href="#RxDataSources" class="headerlink" title="RxDataSources"></a>RxDataSources</h3><ul><li>RxDataSources是以section来做为数据结构来传输</li></ul><blockquote><p>自定义Section<br>Model中创建一个Section的结构体，并且创建一个扩展，遵循SectionModelType协议，实现相应的协议方法</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">LXFModel</span>.swift</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LXFSection</span> </span>&#123;</span><br><span class="line">  <span class="comment">// items就是rows</span></span><br><span class="line">  <span class="keyword">var</span> items : [<span class="type">Item</span>]</span><br><span class="line">  <span class="comment">//这里加你需要的东西，比如 headerView 的 title</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LXFSection</span> : <span class="title">SectionModelType</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 重定义 Item 的类型为 LXFModel</span></span><br><span class="line">  <span class="keyword">typealias</span> <span class="type">Item</span> = <span class="type">LXFModel</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 实现协议中的方式</span></span><br><span class="line">    <span class="keyword">init</span>(original: <span class="type">LXFSection</span>, items: [<span class="type">LXFSection</span>.<span class="type">Item</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span> = original</span><br><span class="line">        <span class="keyword">self</span>.items = items</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>❷ 控制器下创建数据源属性<br>LXFViewController.swift</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个数据源属性，类型为自定义的Section类型</span></span><br><span class="line">   <span class="keyword">let</span> dataSource = <span class="type">RxTableViewSectionedReloadDataSource</span>&lt;<span class="type">LXFSection</span>&gt;()</span><br><span class="line">   </span><br><span class="line"> <span class="comment">//使用数据源属性绑定cell</span></span><br><span class="line"> dataSource.configureCell = &#123; ds,tv,ip,iteam <span class="keyword">in</span></span><br><span class="line">   <span class="comment">// 这个地方使用了Reusable这个库，在LXFViewCell中遵守了相应的协议</span></span><br><span class="line">   <span class="comment">// 使其方便转换cell为非可选型的相应的cell类型</span></span><br><span class="line">   <span class="keyword">let</span> cell = tv.dequeueReusableCell(<span class="keyword">for</span> : ip) <span class="keyword">as</span> <span class="type">LXFViewCell</span></span><br><span class="line">   cell.picView.kf.setImgage(with : <span class="type">URL</span>(string: item.url))</span><br><span class="line">   cell.descLabel.text = <span class="string">"描述 : (item.desc)"</span></span><br><span class="line">   cell.sourceLabel.text = <span class="string">"来源 : (item.source)"</span></span><br><span class="line">   <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>❸ sections序列绑定给我们的rows</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">output.sections</span><br><span class="line">      .asDriver()</span><br><span class="line">      .drive(tableView.rx</span><br><span class="line">                      .items(dataSource : dataSource))</span><br><span class="line">       .addDisposable(rx_disposeBag)</span><br></pre></td></tr></table></figure><h3 id="ViewModel的规范"><a href="#ViewModel的规范" class="headerlink" title="ViewModel的规范"></a>ViewModel的规范</h3><ul><li>MVVM思想是将原本在ViewController的视图显示逻辑、验证逻辑、网络请求等代码存放于ViewModel中，达到ViewController瘦身-</li><li>逻辑由ViewModel负责，外界不需要关心，外界只需要结果，ViewModel也只需要将结果给到外界</li><li>基于此，我们定义了一个协议LXFViewModelType</li></ul><blockquote><p>❶创建LXFViewModelType.swift</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">LXFViewModelType</span>.swift</span><br><span class="line"></span><br><span class="line"><span class="comment">// associatedtype 关键字 用来声明一个类型的占位符作为协议定义的一部分</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">LXFViewModelType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  associatedtype <span class="type">Input</span></span><br><span class="line">  associatedtype <span class="type">Output</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">transform</span><span class="params">(input : Input )</span></span> - &gt; <span class="type">Output</span></span><br></pre></td></tr></table></figure><blockquote><p>❷viewModel遵守LXFViewModelType协议</p></blockquote><ul><li>可以为XFViewModelType的Input和Output定义别名，以示区分,如：这个viewModel的用于请求首页模块相关联的，则可以命名为：HomeInput 和 HomeOutput</li><li>可以丰富我们的 Input 和 Output 。可以看到为Output添加了一个序列，类型为自定义的LXFSection数组，在Input里面添加了一个请求类型(即要请求什么数据，比如首页的数据)</li><li>通过 transform 方法将input携带的数据进行处理，生成了一个Output</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">LXFViewModel</span>.swift</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LXFViewModel</span> :<span class="title">LXFViewModelType</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存放着解析完成的模型数组</span></span><br><span class="line">        <span class="keyword">let</span> models = <span class="type">Variable</span> &lt;[<span class="type">LXFModel</span>]&gt;([])</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为LXFViewModelType的Input和Output定义别名</span></span><br><span class="line">        <span class="keyword">typealias</span> <span class="type">Input</span> = <span class="type">LXFInput</span></span><br><span class="line">        <span class="keyword">typealias</span> <span class="type">Output</span> = <span class="type">LXFOutput</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 丰富Input和Output</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">LXFInput</span> </span>&#123;</span><br><span class="line">           <span class="comment">//网络请求类型</span></span><br><span class="line">           <span class="keyword">let</span> category : <span class="type">LXFNetworkTool</span>.<span class="type">LXFNetworkCategory</span></span><br><span class="line">           int(category : <span class="type">LXFNetworkTool</span>.<span class="type">LXFNetworkCategory</span>)&#123;</span><br><span class="line">              <span class="keyword">self</span>.category = category</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">LXFOutput</span> </span>&#123;</span><br><span class="line">            <span class="comment">//tableView的sections数据</span></span><br><span class="line">            <span class="keyword">let</span> sections : <span class="type">Driver</span> &lt;<span class="type">LXFsection</span>&gt;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">init</span>(sections : <span class="type">Driver</span> &lt;[<span class="type">LXFSection</span>]&gt;)&#123;</span><br><span class="line">               <span class="keyword">self</span>.sections = sections</span><br><span class="line">             &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">func</span> <span class="title">transform</span><span class="params">(input : LXFViewModel.LXFInput)</span></span> -&gt; <span class="type">LXFViewModel</span>.<span class="type">LXFOutput</span>&#123;</span><br><span class="line">           <span class="keyword">let</span> sections = models.asObservable()</span><br><span class="line">                                .<span class="built_in">map</span>&#123; (models) -&gt; [<span class="type">LXFSection</span>] <span class="keyword">in</span> </span><br><span class="line">                                 <span class="comment">// 当models的值被改变时会调用，这是Variable的特性</span></span><br><span class="line">                                 <span class="comment">// 返回section数组</span></span><br><span class="line">                                 <span class="keyword">return</span> [<span class="type">LXFSection</span>(item : models)]</span><br><span class="line">                                 &#125;</span><br><span class="line">                                 .asDriver(onErrorJustReturn : [])</span><br><span class="line">           <span class="keyword">let</span> output = <span class="type">LXFOutput</span>(sections : sections)</span><br><span class="line">       <span class="comment">// 接下来的代码是网络请求</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>❸在ViewController中初始化我们的input，通过transform得到output，<br>然后将output中的sections序列绑定tableView的items</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">LXFViewController</span>.swift</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化input</span></span><br><span class="line"><span class="keyword">let</span> vmInput = <span class="type">LXFViewModel</span>.<span class="type">LXFInput</span>(category : welfare)</span><br><span class="line"><span class="comment">// 通过transform得到output</span></span><br><span class="line"><span class="keyword">let</span> vmOutput = viewModel.transform(input : vmInput)</span><br><span class="line">vmOutput.sections</span><br><span class="line">        .asDriver()</span><br><span class="line">        .drive(tableView.rx</span><br><span class="line">                        .items(dataSource : dataSource))</span><br><span class="line">        .addDisposableTo(rx_disposeBag)</span><br></pre></td></tr></table></figure><h3 id="MJRefresh"><a href="#MJRefresh" class="headerlink" title="MJRefresh"></a>MJRefresh</h3><blockquote><p>❶定义枚举LXFRefreshStatus，用于标志当前刷新状态</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LXFRefreshStatus</span> </span>&#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="keyword">none</span></span><br><span class="line">     <span class="keyword">case</span> beingHeaderRefresh</span><br><span class="line">     <span class="keyword">case</span> endHeaderRefresh</span><br><span class="line">     <span class="keyword">case</span> beingFooterRefresh</span><br><span class="line">     <span class="keyword">case</span> endFooterRefresh</span><br><span class="line">     <span class="keyword">case</span> noMoreData</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>❷LXFOutput添加一个refreshStatus序列，类型为LXFRefreshStatus<br>给外界订阅，告诉外界的tableView当前的刷新状态</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> refreshStatus = <span class="type">Variable</span>&lt;<span class="type">LXFRefreshStatus</span>&gt;(.<span class="keyword">none</span>)</span><br></pre></td></tr></table></figure><ul><li>进行网络请求并得到结果之后，修改refreshStatus的value为相应的LXFRefreshStatus项</li></ul><blockquote><p>❸外界订阅output的refreshStatus,并且根据接收到的值进行相应的操作</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">vmOutput.refreshStatus</span><br><span class="line">        .asObservable()</span><br><span class="line">        .subscribe(onNext : &#123;[<span class="keyword">weak</span> <span class="keyword">self</span>] status <span class="keyword">in</span> </span><br><span class="line">          <span class="keyword">switch</span> status &#123;</span><br><span class="line">           <span class="keyword">case</span> .beingHeaderRefresh:</span><br><span class="line">                <span class="keyword">self</span>?.tableView.mj_header</span><br><span class="line">                     .beginRefreshing()</span><br><span class="line">           <span class="keyword">case</span> .endHeaderRefresh:</span><br><span class="line">                <span class="keyword">self</span>?.tableView</span><br><span class="line">                     .mj_header</span><br><span class="line">                     .endRefreshing()</span><br><span class="line">           <span class="keyword">case</span> .beingFooterRefresh:</span><br><span class="line">                <span class="keyword">self</span>?.tableView</span><br><span class="line">                     .mj_footer</span><br><span class="line">                     .beginRefreshing()</span><br><span class="line">           <span class="keyword">case</span> .endFooterRefresh:</span><br><span class="line">                <span class="keyword">self</span>?.tableView</span><br><span class="line">                     .mj_footer</span><br><span class="line">                     .endRefreshing</span><br><span class="line">           <span class="keyword">case</span> .noMoreData :</span><br><span class="line">                 <span class="keyword">self</span>?.tableView</span><br><span class="line">                       .endRefreshingWithNoMoreData()</span><br><span class="line">            <span class="keyword">default</span> :</span><br><span class="line">             <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">  &#125;).addDisposable(rx_disposeBag)</span><br></pre></td></tr></table></figure><blockquote><p>❹output提供一个requestCommond用于请求数据<br>PublishSubject 的特点：即可以作为Observable，也可以作为Observer，就是可以发送信号，也可以订阅信号<br>外界通过该属性告诉viewModel加载数据（传入的值是为了标志是否重新加载）</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> requestCommond = <span class="type">PublishSubject</span>&lt;<span class="type">Bool</span>&gt;()</span><br></pre></td></tr></table></figure><blockquote><p>在transform中，对生成的output的requestCommond进行订阅</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">output.requestCommond</span><br><span class="line">      .subscribe(onNext : &#123; [<span class="keyword">unowned</span> <span class="keyword">self</span>] isReloadData <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">self</span>.index = isReload ?<span class="number">1</span>:<span class="keyword">self</span>.index+<span class="number">1</span></span><br><span class="line">      lxfNetTool.request(.data(type:input.category,</span><br><span class="line">                               size:<span class="number">10</span>,</span><br><span class="line">                               index:<span class="keyword">self</span>.index</span><br><span class="line">                               )</span><br><span class="line">                         )</span><br><span class="line">                 .mapArray(<span class="type">LXFModel</span>.<span class="keyword">self</span>)</span><br><span class="line">                 .subscribe(&#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (event) <span class="keyword">in</span></span><br><span class="line">                     <span class="keyword">switch</span> event &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="keyword">let</span>.next(modelArr):</span><br><span class="line">                           <span class="keyword">self</span>?.models.value = isReloadData?modelArr:(<span class="keyword">self</span>?.models.value??[])+modelArr</span><br><span class="line">                           <span class="type">LXFProgressHUD</span>.showSuccess(<span class="string">"加载成功"</span>)</span><br><span class="line">                        <span class="keyword">case</span> <span class="keyword">let</span>.error(error):</span><br><span class="line">                           <span class="type">LXFProgressHUD</span>.showError(error.localizedDescription)</span><br><span class="line">                        <span class="keyword">case</span> .completed:</span><br><span class="line">                           output.refreshStatus.value = isReloadData?.endHeaderRefresh:.endFooterRefresh</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;)</span><br><span class="line">                  .addDisposableTo(slf.rx_disposeBag)</span><br><span class="line">     &#125;)</span><br><span class="line">     .addDisposableTo(rx_disposeBag)</span><br></pre></td></tr></table></figure><blockquote><p>❺在ViewController中初始化刷新控件<br>为tableView设置刷新控件，并且在创建刷新控件的回调中使用output的requestCommond发射信号</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">tableView.mj_header = <span class="type">MJRefreshNormalHeader</span>(refreshingBlock:&#123;</span><br><span class="line">  vmOutput.requestCommond</span><br><span class="line">          .onNext(<span class="literal">true</span>)</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line">tableView.mj_footer = <span class="type">MJRefreshAutoNormalFooter</span>(refreshingBlock:&#123;</span><br><span class="line">  vmOutput.requestCommond</span><br><span class="line">          .onNext(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><ul><li>ViewController已经拿到output，当下拉加载数据的时候，使用output的requestCommond发射信息，告诉viewModel我们要加载数据</li><li>viewModel请求数据，在处理完json转模型或模型数组后修改models，当models的值被修改的时候会发信号给sections，sections在ViewController已经绑定到tableView的items了，所以此时tableView的数据会被更新。接着我们根据请求结果，修改output的refreshStatus属性的值</li><li>当output的refreshStatus属性的值改变后，会发射信号，由于外界之前已经订阅了output的refreshStatus，此时就会根据refreshStatus的新值来处理刷新控件的状态</li></ul><p><a href="https://github.com/LinXunFeng/RxSwiftDemo" target="_blank" rel="noopener">原文Demo</a></p>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> RxSwift </category>
          
          <category> Demo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RxSwift </tag>
            
            <tag> Demo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift+Moya+登录+搜索</title>
      <link href="/2018/03/01/Swift/RxSwift/Demo/RxSwift+Moya+%E7%99%BB%E5%BD%95+%E6%90%9C%E7%B4%A2/"/>
      <url>/2018/03/01/Swift/RxSwift/Demo/RxSwift+Moya+%E7%99%BB%E5%BD%95+%E6%90%9C%E7%B4%A2/</url>
      <content type="html"><![CDATA[<h1 id="项目功能"><a href="#项目功能" class="headerlink" title="项目功能"></a>项目功能</h1><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>登录注册功能</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Demo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
            <tag> Demo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-Closures闭包-使用分析</title>
      <link href="/2018/02/28/Swift/Swift/Grammar/Closures%E9%97%AD%E5%8C%85-%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"/>
      <url>/2018/02/28/Swift/Swift/Grammar/Closures%E9%97%AD%E5%8C%85-%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="OC-Block"><a href="#OC-Block" class="headerlink" title="OC-Block"></a>OC-Block</h1><blockquote><p>Block通常会用在网络请求中，请求到数据后然后回调</p></blockquote><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HttpTool</span></span></span><br><span class="line">-(<span class="keyword">void</span>)loadData:(<span class="keyword">void</span>(^)(<span class="built_in">NSString</span> * json))callBack&#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">         <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">            callBack(<span class="string">@"222"</span>);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><blockquote><p>调用</p></blockquote><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line">   <span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) HttpTool * tool;</span><br><span class="line">   <span class="keyword">@end</span></span><br><span class="line">   <span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">   - (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">     [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.tool = [HttpTool new];</span><br><span class="line">  &#125;</span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">        [<span class="keyword">self</span>.tool loadData:^(<span class="built_in">NSString</span> *json) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,json);</span><br><span class="line">          &#125;];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h1 id="用闭包来重写上面的逻辑"><a href="#用闭包来重写上面的逻辑" class="headerlink" title="用闭包来重写上面的逻辑"></a>用闭包来重写上面的逻辑</h1><blockquote><p>1，闭包的类型：(参数列表) -&gt; (返回值列表)</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpTool</span>:<span class="title">NSObject</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">loadData</span><span class="params">(callBack:<span class="params">(json:String)</span></span></span>-&gt;())&#123;</span><br><span class="line">  dispatch_async(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"<span class="subst">\(NSthread.currentThread)</span>"</span>)</span><br><span class="line">      dispatch_sync(dispatch_get_main_queue(), &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"<span class="subst">\((NSThread.currentThread()</span>)"</span>)</span><br><span class="line">      callBack(json:<span class="string">"json"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.调用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> tool : <span class="type">HttpTool</span> = <span class="type">HttpTool</span>()</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">touchesBegan</span><span class="params">(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?)</span></span> &#123;</span><br><span class="line">  tool.loadData&#123;(json) <span class="keyword">in</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">\(json)</span>"</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h1><h2 id="black循环引用"><a href="#black循环引用" class="headerlink" title="black循环引用"></a>black循环引用</h2><blockquote><p>weak self<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">  __weak ViewController * weakSelf = self;</span><br><span class="line">      [self.tool loadData:^(NSString *json) &#123;</span><br><span class="line">          NSLog(@&quot;%@&quot;,json);</span><br><span class="line">          weakSelf.view.backgroundColor = [UIColor redColor];</span><br><span class="line">             &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="闭包的循环引用"><a href="#闭包的循环引用" class="headerlink" title="闭包的循环引用"></a>闭包的循环引用</h2><blockquote><p>闭包强引用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit </span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Httptool</span>: <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    <span class="comment">//声明成可选类型的闭包</span></span><br><span class="line">    <span class="keyword">var</span> callBack :((json : <span class="type">String</span>)-&gt;())?</span><br><span class="line">     <span class="function"><span class="keyword">func</span> <span class="title">loadData</span><span class="params">(callBack : <span class="params">(json : String)</span></span></span>-&gt;()) &#123;</span><br><span class="line">      <span class="comment">//强引用</span></span><br><span class="line">      <span class="keyword">self</span>.callBack = callBack</span><br><span class="line">       dispatch_async(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">"<span class="subst">\(NSThread.currentThread()</span>)"</span>)</span><br><span class="line">        dispatch_sync(dispatch_get_main_queue(), &#123;</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">"<span class="subst">\(NSThread.currentThread()</span>)"</span>)</span><br><span class="line">          callBack(json: <span class="string">"json"</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解决闭包循环引用的3种方式</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> tool : <span class="type">HttpTool</span> = <span class="type">HttpTool</span>()</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">touchesBegan</span><span class="params">(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?)</span></span> &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">        weak var weakSelf = self</span></span><br><span class="line"><span class="comment">        tool.loadData &#123; (json) in</span></span><br><span class="line"><span class="comment">        print("\(json)")</span></span><br><span class="line"><span class="comment">        //weakSelf?.view ： 如果前面的可选类型，没有值，后面的所有代码不会执行</span></span><br><span class="line"><span class="comment">        //如果有值，系统会自动将weakSelf进行解包，并使用weakSelf</span></span><br><span class="line"><span class="comment">        weakSelf?.view.backgroundColor = UIColor.redColor()</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">          tool.loadData &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (json) <span class="keyword">in</span></span><br><span class="line">               <span class="built_in">print</span>(<span class="string">"<span class="subst">\(json)</span>"</span>)</span><br><span class="line">               <span class="comment">//weakSelf?.view ： 如果前面的可选类型，没有值，后面的所有代码不会执行</span></span><br><span class="line">               <span class="comment">//如果有值，系统会自动将weakSelf进行解包，并使用weakSelf</span></span><br><span class="line">                 <span class="keyword">self</span>?.view.backgroundColor = <span class="type">UIColor</span>.redColor()</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">              //这种写法一旦self为空，就会报错</span></span><br><span class="line"><span class="comment">              //unowned相当于oc中的__unsafe_unretained，__unsafe_unretained 修饰的弱引用，如果指向的对象销毁，那么指针指向之前的内存地址，很容易产生坏内存访问，野指针。僵尸对象</span></span><br><span class="line"><span class="comment">              tool.loadData &#123;[unowned self] (json) in</span></span><br><span class="line"><span class="comment">               print("\(json)")</span></span><br><span class="line"><span class="comment">               //weakSelf?.view ： 如果前面的可选类型，没有值，后面的所有代码不会执行</span></span><br><span class="line"><span class="comment">               //如果有值，系统会自动将weakSelf进行解包，并使用weakSelf</span></span><br><span class="line"><span class="comment">                self.view.backgroundColor = UIColor.redColor()</span></span><br><span class="line"><span class="comment">               &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//相当于oc中的dealloc方法</span></span><br><span class="line">    <span class="keyword">deinit</span>&#123;</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">"deinit"</span>)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h1><blockquote><p>普通写法</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">tool.loadData(&#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (json) <span class="keyword">in</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(json)</span>"</span>)</span><br><span class="line">     <span class="comment">//weakSelf?.view ： 如果前面的可选类型，没有值，后面的所有代码不会执行</span></span><br><span class="line">      <span class="comment">//如果有值，系统会自动将weakSelf进行解包，并使用weakSelf</span></span><br><span class="line">     <span class="keyword">self</span>?.view.backgroundColor = <span class="type">UIColor</span>.redColor()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>尾随闭包一</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">tool.loadData () &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (json) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(json)</span>"</span>)</span><br><span class="line">     <span class="comment">//weakSelf?.view ： 如果前面的可选类型，没有值，后面的所有代码不会执行</span></span><br><span class="line">     <span class="comment">//如果有值，系统会自动将weakSelf进行解包，并使用weakSelf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>尾随闭包二，当闭包为函数的最后一个参数时，会自动省略()</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">tool.loadData &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (json) <span class="keyword">in</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">\(json)</span>"</span>)</span><br><span class="line">  <span class="comment">//weakSelf?.view ： 如果前面的可选类型，没有值，后面的所有代码不会执行</span></span><br><span class="line">  <span class="comment">//如果有值，系统会自动将weakSelf进行解包，并使用weakSelf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/3a4e72b5eefd" target="_blank" rel="noopener"></a></p>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>RxSwift-Grammar-支持的操作符</title>
      <link href="/2018/01/31/Swift/RxSwift/Grammar/%E6%94%AF%E6%8C%81%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2018/01/31/Swift/RxSwift/Grammar/%E6%94%AF%E6%8C%81%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      <content type="html"><![CDATA[<p>RxSwift 支持的操作符</p><p>在某些情况，由于不同平台/实现方式，相同的操作符有多个别名，有时相同的操作命名也不一样，有些是因为历史的原因，但是还有一些是因为语言的预留关键字。</p><p>当缺少社区共识的时候，RxSwift 通常会包含多个别名。</p><p>默认情况下，操作符是没有状态的。<br>创建 Observable</p><pre><code>asObservablecreatedeferredemptyerrortoObservable (array)intervalneverjustofrangerepeatElementtimer</code></pre><p>变换 Observable</p><pre><code>bufferflatMapflatMapFirstflatMapLatestmapscanwindow</code></pre><p>过滤 Observable</p><pre><code>debounce / throttledistinctUntilChanged`elementAtfiltersampleskiptaketakeLastsingle</code></pre><p>联合 Observable</p><pre><code>mergestartWithswitchLatestcombineLatestzip</code></pre><p>错误处理操作符</p><pre><code>catchretryretryWhen</code></pre><p>Observable Utility Operators</p><pre><code>delaySubscriptiondo / doOnNextobserveOn / observeSingleOnsubscribesubscribeOntimeoutusingdebug</code></pre><p>条件和 Bool 操作符</p><pre><code>ambskipWhileskipUntiltakeUntiltakeWhile</code></pre><p>数学和聚合操作符</p><pre><code>concatreduce / aggregatetoArray</code></pre><p>连接 Observable 操作符</p><pre><code>multicastpublishrefCountreplayshareReplay创建新的操作符也是相当简单的。</code></pre><p><a href="http://blog.csdn.net/yangmeng13930719363/article/details/51905739" target="_blank" rel="noopener"></a></p>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>RxSwift-Grammar-创建Observable对象的方法</title>
      <link href="/2018/01/31/Swift/RxSwift/Grammar/%E5%88%9B%E5%BB%BAObservable%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2018/01/31/Swift/RxSwift/Grammar/%E5%88%9B%E5%BB%BAObservable%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="①never"><a href="#①never" class="headerlink" title="①never"></a>①never</h2><blockquote><p>never就是创建一个sequence，但是<strong>不发出任何事件信号</strong></p></blockquote><p><img src="http://ozr735s7e.bkt.clouddn.com/RxSwift-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5001.png" alt="001"></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> neverSequence = <span class="type">Observable</span>&lt;<span class="type">String</span>&gt;.never()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> neverSequenceSubscription = neverSequence</span><br><span class="line"> .subscribe &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"This will never be printed"</span>)</span><br><span class="line"> &#125;.addDisposableTo(disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是什么都不打印y</span></span><br></pre></td></tr></table></figure><h2 id="②empty"><a href="#②empty" class="headerlink" title="②empty"></a>②empty</h2><blockquote><p>empty就是创建一个空的sequence,只能发出一个completed事件</p></blockquote><p><img src="http://ozr735s7e.bkt.clouddn.com/RxSwift-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5002.png" alt="002"></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"></span><br><span class="line"><span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.empty()</span><br><span class="line">    .subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(event)</span><br><span class="line">    &#125;</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">completed</span><br></pre></td></tr></table></figure><h2 id="③just"><a href="#③just" class="headerlink" title="③just"></a>③just</h2><blockquote><p>just是创建一个sequence只能发出一种特定的事件，能正常结束</p></blockquote><p><img src="http://ozr735s7e.bkt.clouddn.com/RxSwift-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5003.png" alt="003"></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>.just(<span class="string">"🔴"</span>)</span><br><span class="line">    .subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(event)</span><br><span class="line">    &#125;</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">next(🔴)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure><h2 id="④of"><a href="#④of" class="headerlink" title="④of"></a>④of</h2><blockquote><p>of是创建一个sequence能发出很多种事件信号</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"🐶"</span>, <span class="string">"🐱"</span>, <span class="string">"🐭"</span>, <span class="string">"🐹"</span>)</span><br><span class="line">    .subscribe(onNext: &#123; element <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(element)</span><br><span class="line">    &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">🐶</span><br><span class="line">🐱</span><br><span class="line">🐭</span><br><span class="line">🐹</span><br></pre></td></tr></table></figure><blockquote><p>把上面的onNext:去掉的话，结果会是这样子，也正好对应了我们subscribe中，subscribe只监听事件</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  next(🐶)</span><br><span class="line">next(🐱)</span><br><span class="line">next(🐭)</span><br><span class="line">next(🐹)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure><h2 id="⑤from"><a href="#⑤from" class="headerlink" title="⑤from"></a>⑤from</h2><blockquote><p>from就是从集合中创建sequence，例如数组，字典或者Set</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>.from([<span class="string">"🐶"</span>, <span class="string">"🐱"</span>, <span class="string">"🐭"</span>, <span class="string">"🐹"</span>])</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><h2 id="⑥create"><a href="#⑥create" class="headerlink" title="⑥create"></a>⑥create</h2><blockquote><p>自定义可观察的sequence<br>create操作符传入一个观察者observer，然后调用observer的onNext，onCompleted和onError方法。返回一个可观察的obserable序列</p></blockquote><p><img src="http://ozr735s7e.bkt.clouddn.com/RxSwift-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5006.png" alt="006"></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> myJust = &#123; (element: <span class="type">String</span>) -&gt; <span class="type">Observable</span>&lt;<span class="type">String</span>&gt; <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">Observable</span>.create &#123; observer <span class="keyword">in</span></span><br><span class="line">        observer.on(.next(element))</span><br><span class="line">        observer.on(.completed)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">myJust(<span class="string">"🔴"</span>)</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">next(🔴)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure><h2 id="⑦range"><a href="#⑦range" class="headerlink" title="⑦range"></a>⑦range</h2><blockquote><p>range就是创建一个sequence，他会发出这个范围中的从开始到结束的所有事件</p></blockquote><p><img src="http://ozr735s7e.bkt.clouddn.com/RxSwift-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5007.png" alt="007"></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="type">Observable</span>.range(start: <span class="number">1</span>, <span class="built_in">count</span>: <span class="number">10</span>)</span><br><span class="line"> .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line"> .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  next(<span class="number">1</span>)</span><br><span class="line">  next(<span class="number">2</span>)</span><br><span class="line">next(<span class="number">3</span>)</span><br><span class="line">next(<span class="number">4</span>)</span><br><span class="line">next(<span class="number">5</span>)</span><br><span class="line">next(<span class="number">6</span>)</span><br><span class="line">next(<span class="number">7</span>)</span><br><span class="line">next(<span class="number">8</span>)</span><br><span class="line">next(<span class="number">9</span>)</span><br><span class="line">next(<span class="number">10</span>)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure><h2 id="⑧repeatElement"><a href="#⑧repeatElement" class="headerlink" title="⑧repeatElement"></a>⑧repeatElement</h2><blockquote><p>创建一个sequence，发出特定的事件n次</p></blockquote><p><img src="http://ozr735s7e.bkt.clouddn.com/RxSwift-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5008.png" alt="008"></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>.repeatElement(<span class="string">"🔴"</span>)</span><br><span class="line">    .take(<span class="number">3</span>)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">🔴</span><br><span class="line">🔴</span><br><span class="line">🔴</span><br></pre></td></tr></table></figure><h2 id="⑨generate"><a href="#⑨generate" class="headerlink" title="⑨generate"></a>⑨generate</h2><blockquote><p>generate是创建一个可观察sequence，当初始化的条件为true的时候，他就会发出所对应的事件</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>.generate(</span><br><span class="line">        initialState: <span class="number">0</span>,</span><br><span class="line">        condition: &#123; $<span class="number">0</span> &lt; <span class="number">3</span> &#125;,</span><br><span class="line">        iterate: &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;</span><br><span class="line">    )</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="⑩-deferred"><a href="#⑩-deferred" class="headerlink" title="⑩ deferred"></a>⑩ deferred</h2><blockquote><p>deferred会为每一为订阅者observer创建一个新的可观察序列<br>下面例子中每次进行subscribe的时候都会去创建一个新的deferredSequence，所以Emitting会打印两遍</p></blockquote><p><img src="http://ozr735s7e.bkt.clouddn.com/RxSwift-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5010.png" alt="010"></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> deferredSequence = <span class="type">Observable</span>&lt;<span class="type">String</span>&gt;.deferred &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Creating <span class="subst">\(<span class="built_in">count</span>)</span>"</span>)</span><br><span class="line">    <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">Observable</span>.create &#123; observer <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Emitting..."</span>)</span><br><span class="line">        observer.onNext(<span class="string">"🐶"</span>)</span><br><span class="line">        observer.onNext(<span class="string">"🐱"</span>)</span><br><span class="line">        observer.onNext(<span class="string">"🐵"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">deferredSequence</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line">    </span><br><span class="line">deferredSequence</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  Creating 1</span><br><span class="line">Emitting...</span><br><span class="line">🐶</span><br><span class="line">🐱</span><br><span class="line">🐵</span><br><span class="line">Creating 2</span><br><span class="line">Emitting...</span><br><span class="line">🐶</span><br><span class="line">🐱</span><br><span class="line">🐵</span><br></pre></td></tr></table></figure><h2 id="⑪error"><a href="#⑪error" class="headerlink" title="⑪error"></a>⑪error</h2><blockquote><p>创建一个可观察序列，但不发出任何正常的事件，只发出error事件并结束</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.error(<span class="type">TestError</span>.test)</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error(test)</span><br></pre></td></tr></table></figure><h2 id="⑫doOn"><a href="#⑫doOn" class="headerlink" title="⑫doOn"></a>⑫doOn</h2><blockquote><p>doOn我感觉就是在直接onNext处理时候，先执行某个方法，doOnNext(_ :)方法就是在subscribe(onNext:)前调用，doOnCompleted(_:)就是在subscribe(onCompleted:)前面调用的</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"🍎"</span>, <span class="string">"🍐"</span>, <span class="string">"🍊"</span>, <span class="string">"🍋"</span>)</span><br><span class="line">    .<span class="keyword">do</span>(onNext: &#123; <span class="built_in">print</span>(<span class="string">"Intercepted:"</span>, $<span class="number">0</span>) &#125;, onError: &#123; <span class="built_in">print</span>(<span class="string">"Intercepted error:"</span>, $<span class="number">0</span>) &#125;, onCompleted: &#123; <span class="built_in">print</span>(<span class="string">"Completed"</span>)  &#125;)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;,onCompleted: &#123; <span class="built_in">print</span>(<span class="string">"结束"</span>) &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><p><a href="http://blog.csdn.net/xwl198937/article/details/50823558" target="_blank" rel="noopener">资料</a></p>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Demo-TableView双联表</title>
      <link href="/2018/01/20/Swift/Swift/Demo/Swift-Demo-TableView%E5%8F%8C%E8%81%94%E8%A1%A8/"/>
      <url>/2018/01/20/Swift/Swift/Demo/Swift-Demo-TableView%E5%8F%8C%E8%81%94%E8%A1%A8/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Demo </category>
          
          <category> TableView </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UIWKWebView</title>
      <link href="/2017/12/21/Swift/Swift/UIKit/Swift-UIKit-UIWKWebView/"/>
      <url>/2017/12/21/Swift/Swift/UIKit/Swift-UIKit-UIWKWebView/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> WKWebView </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> WKWebView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-Grammar-调试操作 -07-08</title>
      <link href="/2017/12/20/Swift/RxSwift/Grammar/08-%E7%89%B9%E5%BE%81%E5%BA%8F%E5%88%97/"/>
      <url>/2017/12/20/Swift/RxSwift/Grammar/08-%E7%89%B9%E5%BE%81%E5%BA%8F%E5%88%97/</url>
      <content type="html"><![CDATA[<h1 id="①debug"><a href="#①debug" class="headerlink" title="①debug"></a>①debug</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>我们可以将 debug 调试操作符添加到一个链式步骤当中，这样系统就能将所有的订阅者、事件、和处理等详细信息打印出来，方便我们开发调试</p></blockquote><h2 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"> </span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"2"</span>, <span class="string">"3"</span>)</span><br><span class="line">    .startWith(<span class="string">"1"</span>)</span><br><span class="line">    .debug()</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p><img src="http://ozr735s7e.bkt.clouddn.com/%20RxSwift-Grammar-%E8%B0%83%E8%AF%95%E6%93%8D%E4%BD%9C%20-07-08.png" alt=""></p><h2 id="debug-方法还可以传入标记参数"><a href="#debug-方法还可以传入标记参数" class="headerlink" title="debug() 方法还可以传入标记参数"></a>debug() 方法还可以传入标记参数</h2><blockquote><p>当项目中存在多个 debug 时可以很方便地区分出来</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"> </span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"2"</span>, <span class="string">"3"</span>)</span><br><span class="line">    .startWith(<span class="string">"1"</span>)</span><br><span class="line">    .debug(<span class="string">"调试1"</span>)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h1 id="②RxSwift-Resources-total"><a href="#②RxSwift-Resources-total" class="headerlink" title="②RxSwift.Resources.total"></a>②RxSwift.Resources.total</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>通过将 RxSwift.Resources.total 打印出来，我们可以查看当前 RxSwift 申请的所有资源数量。这个在检查内存泄露的时候非常有用</p></blockquote><h2 id="使用样例-1"><a href="#使用样例-1" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="type">RxSwift</span>.<span class="type">Resources</span>.total)</span><br><span class="line">         </span><br><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="type">RxSwift</span>.<span class="type">Resources</span>.total)</span><br><span class="line">         </span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"BBB"</span>, <span class="string">"CCC"</span>)</span><br><span class="line">    .startWith(<span class="string">"AAA"</span>)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">         </span><br><span class="line"><span class="built_in">print</span>(<span class="type">RxSwift</span>.<span class="type">Resources</span>.total)</span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="type">AAA</span></span><br><span class="line"><span class="type">BBB</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h1 id="③retry"><a href="#③retry" class="headerlink" title="③retry"></a>③retry</h1><h2 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>使用该方法当遇到错误的时候，会重新订阅该序列。比如遇到网络请求失败时，可以进行重新连接。<br>retry() 方法可以传入数字表示重试次数。不传的话只会重试一次</p></blockquote><h2 id="使用样例-2"><a href="#使用样例-2" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> sequenceThatErrors = <span class="type">Observable</span>&lt;<span class="type">String</span>&gt;.create &#123; observer <span class="keyword">in</span></span><br><span class="line">    observer.onNext(<span class="string">"a"</span>)</span><br><span class="line">    observer.onNext(<span class="string">"b"</span>)</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//让第一个订阅时发生错误</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">count</span> == <span class="number">1</span> &#123;</span><br><span class="line">        observer.onError(<span class="type">MyError</span>.<span class="type">A</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Error encountered"</span>)</span><br><span class="line">        <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    observer.onNext(<span class="string">"c"</span>)</span><br><span class="line">    observer.onNext(<span class="string">"d"</span>)</span><br><span class="line">    observer.onCompleted()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">sequenceThatErrors</span><br><span class="line">    .retry(<span class="number">2</span>)  <span class="comment">//重试2次（参数为空则只重试一次）</span></span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)运行结果如下：</span><br><span class="line">    </span><br><span class="line"><span class="comment">//print</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line"><span class="type">Error</span> eccountered</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line"><span class="built_in">c</span></span><br><span class="line">d</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-Grammar-调试操作 -07-08</title>
      <link href="/2017/12/20/Swift/RxSwift/Grammar/07-08-Operators-%E8%B0%83%E8%AF%95%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/12/20/Swift/RxSwift/Grammar/07-08-Operators-%E8%B0%83%E8%AF%95%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h1 id="①debug"><a href="#①debug" class="headerlink" title="①debug"></a>①debug</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>我们可以将 debug 调试操作符添加到一个链式步骤当中，这样系统就能将所有的订阅者、事件、和处理等详细信息打印出来，方便我们开发调试</p></blockquote><h2 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"> </span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"2"</span>, <span class="string">"3"</span>)</span><br><span class="line">    .startWith(<span class="string">"1"</span>)</span><br><span class="line">    .debug()</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p><img src="http://ozr735s7e.bkt.clouddn.com/%20RxSwift-Grammar-%E8%B0%83%E8%AF%95%E6%93%8D%E4%BD%9C%20-07-08.png" alt=""></p><h2 id="debug-方法还可以传入标记参数"><a href="#debug-方法还可以传入标记参数" class="headerlink" title="debug() 方法还可以传入标记参数"></a>debug() 方法还可以传入标记参数</h2><blockquote><p>当项目中存在多个 debug 时可以很方便地区分出来</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"> </span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"2"</span>, <span class="string">"3"</span>)</span><br><span class="line">    .startWith(<span class="string">"1"</span>)</span><br><span class="line">    .debug(<span class="string">"调试1"</span>)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h1 id="②RxSwift-Resources-total"><a href="#②RxSwift-Resources-total" class="headerlink" title="②RxSwift.Resources.total"></a>②RxSwift.Resources.total</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>通过将 RxSwift.Resources.total 打印出来，我们可以查看当前 RxSwift 申请的所有资源数量。这个在检查内存泄露的时候非常有用</p></blockquote><h2 id="使用样例-1"><a href="#使用样例-1" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="type">RxSwift</span>.<span class="type">Resources</span>.total)</span><br><span class="line">         </span><br><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="type">RxSwift</span>.<span class="type">Resources</span>.total)</span><br><span class="line">         </span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"BBB"</span>, <span class="string">"CCC"</span>)</span><br><span class="line">    .startWith(<span class="string">"AAA"</span>)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">         </span><br><span class="line"><span class="built_in">print</span>(<span class="type">RxSwift</span>.<span class="type">Resources</span>.total)</span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="type">AAA</span></span><br><span class="line"><span class="type">BBB</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h1 id="③retry"><a href="#③retry" class="headerlink" title="③retry"></a>③retry</h1><h2 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>使用该方法当遇到错误的时候，会重新订阅该序列。比如遇到网络请求失败时，可以进行重新连接。<br>retry() 方法可以传入数字表示重试次数。不传的话只会重试一次</p></blockquote><h2 id="使用样例-2"><a href="#使用样例-2" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> sequenceThatErrors = <span class="type">Observable</span>&lt;<span class="type">String</span>&gt;.create &#123; observer <span class="keyword">in</span></span><br><span class="line">    observer.onNext(<span class="string">"a"</span>)</span><br><span class="line">    observer.onNext(<span class="string">"b"</span>)</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//让第一个订阅时发生错误</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">count</span> == <span class="number">1</span> &#123;</span><br><span class="line">        observer.onError(<span class="type">MyError</span>.<span class="type">A</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Error encountered"</span>)</span><br><span class="line">        <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    observer.onNext(<span class="string">"c"</span>)</span><br><span class="line">    observer.onNext(<span class="string">"d"</span>)</span><br><span class="line">    observer.onCompleted()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">sequenceThatErrors</span><br><span class="line">    .retry(<span class="number">2</span>)  <span class="comment">//重试2次（参数为空则只重试一次）</span></span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)运行结果如下：</span><br><span class="line">    </span><br><span class="line"><span class="comment">//print</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line"><span class="type">Error</span> eccountered</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line"><span class="built_in">c</span></span><br><span class="line">d</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-Grammar-错误处理操作-07-07</title>
      <link href="/2017/12/20/Swift/RxSwift/Grammar/07-07-Operators-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/12/20/Swift/RxSwift/Grammar/07-07-Operators-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<blockquote><p>错误处理操作符可以用来帮助我们对 Observable 发出的 error 事件做出响应，或者从错误中恢复。<br>这里我们先自定义一个错误枚举供后面使用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MyError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">A</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="①catchErrorJustReturn"><a href="#①catchErrorJustReturn" class="headerlink" title="①catchErrorJustReturn"></a>①catchErrorJustReturn</h1><p>##基本介绍</p><blockquote><p>当遇到 error 事件的时候，就返回指定的值，然后结束。</p></blockquote><h2 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> sequenceThatFails = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"> </span><br><span class="line">sequenceThatFails</span><br><span class="line">    .catchErrorJustReturn(<span class="string">"错误"</span>)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"> </span><br><span class="line">sequenceThatFails.onNext(<span class="string">"a"</span>)</span><br><span class="line">sequenceThatFails.onNext(<span class="string">"b"</span>)</span><br><span class="line">sequenceThatFails.onNext(<span class="string">"c"</span>)</span><br><span class="line">sequenceThatFails.onError(<span class="type">MyError</span>.<span class="type">A</span>)</span><br><span class="line">sequenceThatFails.onNext(<span class="string">"d"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line"><span class="built_in">c</span></span><br><span class="line">错误</span><br></pre></td></tr></table></figure><h1 id="②catchError"><a href="#②catchError" class="headerlink" title="②catchError"></a>②catchError</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>该方法可以捕获 error，并对其进行处理。<br>同时还能返回另一个 Observable 序列进行订阅（切换到新的序列）</p></blockquote><h2 id="使用样例-1"><a href="#使用样例-1" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> sequenceThatFails = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> recoverySequence = <span class="type">Observable</span>.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>)</span><br><span class="line"> </span><br><span class="line">sequenceThatFails</span><br><span class="line">    .catchError &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Error:"</span>, $<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> recoverySequence</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"> </span><br><span class="line">sequenceThatFails.onNext(<span class="string">"a"</span>)</span><br><span class="line">sequenceThatFails.onNext(<span class="string">"b"</span>)</span><br><span class="line">sequenceThatFails.onNext(<span class="string">"c"</span>)</span><br><span class="line">sequenceThatFails.onError(<span class="type">MyError</span>.<span class="type">A</span>)</span><br><span class="line">sequenceThatFails.onNext(<span class="string">"d"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line"><span class="built_in">c</span></span><br><span class="line"><span class="type">Error</span>: <span class="type">A</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h1 id="③retry"><a href="#③retry" class="headerlink" title="③retry"></a>③retry</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>使用该方法当遇到错误的时候，会重新订阅该序列。比如遇到网络请求失败时，可以进行重新连接。<br>retry() 方法可以传入数字表示重试次数。不传的话只会重试一次</p></blockquote><h2 id="使用样例-2"><a href="#使用样例-2" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> sequenceThatErrors = <span class="type">Observable</span>&lt;<span class="type">String</span>&gt;.create &#123; observer <span class="keyword">in</span></span><br><span class="line">    observer.onNext(<span class="string">"a"</span>)</span><br><span class="line">    observer.onNext(<span class="string">"b"</span>)</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//让第一个订阅时发生错误</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">count</span> == <span class="number">1</span> &#123;</span><br><span class="line">        observer.onError(<span class="type">MyError</span>.<span class="type">A</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Error encountered"</span>)</span><br><span class="line">        <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    observer.onNext(<span class="string">"c"</span>)</span><br><span class="line">    observer.onNext(<span class="string">"d"</span>)</span><br><span class="line">    observer.onCompleted()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">sequenceThatErrors</span><br><span class="line">    .retry(<span class="number">2</span>)  <span class="comment">//重试2次（参数为空则只重试一次）</span></span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)运行结果如下：</span><br><span class="line">    </span><br><span class="line"><span class="comment">//print</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line"><span class="type">Error</span> eccountered</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line"><span class="built_in">c</span></span><br><span class="line">d</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-Grammar-实用的操作符-07-06</title>
      <link href="/2017/12/20/Swift/RxSwift/Grammar/07-06-Operators-%E5%AE%9E%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2017/12/20/Swift/RxSwift/Grammar/07-06-Operators-%E5%AE%9E%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      <content type="html"><![CDATA[<ul><li><a href="#①delay">①delay</a></li><li><a href="#②delaySubscription">②delaySubscription</a></li><li><a href="#③materialize">③materialize </a></li><li><a href="#⑤timeout">⑤timeout</a></li><li><a href="#④dematerialize">④dematerialize</a></li><li><a href="#⑥using">⑥using</a></li></ul><p><span id="①delay">①delay</span></p><h1 id="①delay"><a href="#①delay" class="headerlink" title="①delay"></a>①delay</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>该操作符会将 Observable 的所有元素都先拖延一段设定好的时间，然后才将它们发送出来</p></blockquote><h2 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> RxCocoa</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">            .delay(<span class="number">3</span>, scheduler: <span class="type">MainScheduler</span>.instance) <span class="comment">//元素延迟3秒才发出</span></span><br><span class="line">            .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="②delaySubscription">②delaySubscription</span></p><h1 id="②delaySubscription"><a href="#②delaySubscription" class="headerlink" title="②delaySubscription"></a>②delaySubscription</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>使用该操作符可以进行延时订阅。即经过所设定的时间后，才对 Observable 进行订阅操作</p></blockquote><h2 id="使用样例-1"><a href="#使用样例-1" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> RxCocoa</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">            .delaySubscription(<span class="number">3</span>, scheduler: <span class="type">MainScheduler</span>.instance) <span class="comment">//延迟3秒才开始订阅</span></span><br><span class="line">            .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="③materialize ">③concat</span></p><h1 id="③materialize"><a href="#③materialize" class="headerlink" title="③materialize"></a>③materialize</h1><h2 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>该操作符可以将序列产生的事件，转换成元素<br>通常一个有限的 Observable 将产生零个或者多个 onNext 事件，最后产生一个 onCompleted 或者 onError 事件。而 materialize 操作符会将 Observable 产生的这些事件全部转换成元素，然后发送出来</p></blockquote><h2 id="使用样例1"><a href="#使用样例1" class="headerlink" title="使用样例1"></a>使用样例1</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> subject1 = <span class="type">BehaviorSubject</span>(value: <span class="string">"🍎"</span>)</span><br><span class="line"><span class="keyword">let</span> subject2 = <span class="type">BehaviorSubject</span>(value: <span class="string">"🐶"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> variable = <span class="type">Variable</span>(subject1)</span><br><span class="line">    </span><br><span class="line">variable.asObservable()</span><br><span class="line">    .concat()</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line">    </span><br><span class="line">subject1.onNext(<span class="string">"🍐"</span>)</span><br><span class="line">subject1.onNext(<span class="string">"🍊"</span>)</span><br><span class="line">    </span><br><span class="line">variable.value = subject2</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">subject2.onNext(<span class="string">"🐱"</span>)   <span class="comment">//1完成前，会被忽略</span></span><br><span class="line">subject2.onNext(<span class="string">"teng"</span>) <span class="comment">//1完成前，会被忽略</span></span><br><span class="line">subject2.onNext(<span class="string">"fei"</span>)  <span class="comment">//1完成前的最后一个，会被接收</span></span><br><span class="line">    </span><br><span class="line">subject1.onCompleted()</span><br><span class="line">    </span><br><span class="line">subject2.onNext(<span class="string">"🐭"</span>)</span><br><span class="line"></span><br><span class="line">next(🍎)</span><br><span class="line">next(🍐)</span><br><span class="line">next(🍊)</span><br><span class="line">next(fei)</span><br><span class="line">next(🐭)</span><br></pre></td></tr></table></figure><h2 id="使用样例2"><a href="#使用样例2" class="headerlink" title="使用样例2"></a>使用样例2</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> RxCocoa</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">            .materialize()</span><br><span class="line">            .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line">next(<span class="number">1</span>)</span><br><span class="line">next(<span class="number">2</span>)</span><br><span class="line">next(<span class="number">1</span>)</span><br><span class="line">completeted</span><br></pre></td></tr></table></figure><p><span id="④dematerialize">④dematerialize</span></p><h1 id="④dematerialize"><a href="#④dematerialize" class="headerlink" title="④dematerialize"></a>④dematerialize</h1><h2 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>该操作符的作用和 materialize 正好相反，它可以将 materialize 转换后的元素还原</p></blockquote><h2 id="使用样例-2"><a href="#使用样例-2" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> RxCocoa</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">            .materialize()</span><br><span class="line">            .dematerialize()</span><br><span class="line">            .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//print</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="⑤timeout">⑤timeout</span></p><h1 id="⑤timeout"><a href="#⑤timeout" class="headerlink" title="⑤timeout"></a>⑤timeout</h1><h2 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>使用该操作符可以设置一个超时时间。如果源 Observable 在规定时间内没有发任何出元素，就产生一个超时的 error 事件</p></blockquote><h2 id="使用样例-3"><a href="#使用样例-3" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> RxCocoa</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//定义好每个事件里的值以及发送的时间</span></span><br><span class="line">        <span class="keyword">let</span> times = [</span><br><span class="line">            [ <span class="string">"value"</span>: <span class="number">1</span>, <span class="string">"time"</span>: <span class="number">0</span> ],</span><br><span class="line">            [ <span class="string">"value"</span>: <span class="number">2</span>, <span class="string">"time"</span>: <span class="number">0.5</span> ],</span><br><span class="line">            [ <span class="string">"value"</span>: <span class="number">3</span>, <span class="string">"time"</span>: <span class="number">1.5</span> ],</span><br><span class="line">            [ <span class="string">"value"</span>: <span class="number">4</span>, <span class="string">"time"</span>: <span class="number">4</span> ],</span><br><span class="line">            [ <span class="string">"value"</span>: <span class="number">5</span>, <span class="string">"time"</span>: <span class="number">5</span> ]</span><br><span class="line">        ]</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//生成对应的 Observable 序列并订阅</span></span><br><span class="line">        <span class="type">Observable</span>.from(times)</span><br><span class="line">            .flatMap &#123; item <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">return</span> <span class="type">Observable</span>.of(<span class="type">Int</span>(item[<span class="string">"value"</span>]!))</span><br><span class="line">                    .delaySubscription(<span class="type">Double</span>(item[<span class="string">"time"</span>]!),</span><br><span class="line">                                       scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">            &#125;</span><br><span class="line">            .timeout(<span class="number">2</span>, scheduler: <span class="type">MainScheduler</span>.instance) <span class="comment">//超过两秒没发出元素，则产生error事件</span></span><br><span class="line">            .subscribe(onNext: &#123; element <span class="keyword">in</span></span><br><span class="line">                <span class="built_in">print</span>(element)</span><br><span class="line">            &#125;, onError: &#123; error <span class="keyword">in</span></span><br><span class="line">                <span class="built_in">print</span>(error)</span><br><span class="line">            &#125;)</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="type">Sequenece</span> timeout</span><br></pre></td></tr></table></figure><p><span id="⑥using">⑥using</span></p><h1 id="⑥using"><a href="#⑥using" class="headerlink" title="⑥using"></a>⑥using</h1><h2 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>使用 using 操作符创建 Observable 时，同时会创建一个可被清除的资源，一旦 Observable 终止了，那么这个资源就会被清除掉了</p></blockquote><h2 id="使用样例-4"><a href="#使用样例-4" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> RxCocoa</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//一个无限序列（每隔0.1秒创建一个序列数 ）</span></span><br><span class="line">        <span class="keyword">let</span> infiniteInterval$ = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;</span><br><span class="line">            .interval(<span class="number">0.1</span>, scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">            .<span class="keyword">do</span>(</span><br><span class="line">                onNext: &#123; <span class="built_in">print</span>(<span class="string">"infinite$: <span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;,</span><br><span class="line">                onSubscribe: &#123; <span class="built_in">print</span>(<span class="string">"开始订阅 infinite$"</span>)&#125;,</span><br><span class="line">                onDispose: &#123; <span class="built_in">print</span>(<span class="string">"销毁 infinite$"</span>)&#125;</span><br><span class="line">        )</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//一个有限序列（每隔0.5秒创建一个序列数，共创建三个 ）</span></span><br><span class="line">        <span class="keyword">let</span> limited$ = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;</span><br><span class="line">            .interval(<span class="number">0.5</span>, scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">            .take(<span class="number">2</span>)</span><br><span class="line">            .<span class="keyword">do</span>(</span><br><span class="line">                onNext: &#123; <span class="built_in">print</span>(<span class="string">"limited$: <span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;,</span><br><span class="line">                onSubscribe: &#123; <span class="built_in">print</span>(<span class="string">"开始订阅 limited$"</span>)&#125;,</span><br><span class="line">                onDispose: &#123; <span class="built_in">print</span>(<span class="string">"销毁 limited$"</span>)&#125;</span><br><span class="line">        )</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//使用using操作符创建序列</span></span><br><span class="line">        <span class="keyword">let</span> o: <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; = <span class="type">Observable</span>.using(&#123; () -&gt; <span class="type">AnyDisposable</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">AnyDisposable</span>(infiniteInterval$.subscribe())</span><br><span class="line">        &#125;, observableFactory: &#123; <span class="number">_</span> <span class="keyword">in</span> <span class="keyword">return</span> limited$ &#125;</span><br><span class="line">        )</span><br><span class="line">        o.subscribe()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnyDisposable</span>: <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _dispose: () -&gt; <span class="type">Void</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> disposable: <span class="type">Disposable</span>) &#123;</span><br><span class="line">        _dispose = disposable.dispose</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dispose</span><span class="params">()</span></span> &#123;</span><br><span class="line">        _dispose()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line">开始订阅 infinite$</span><br><span class="line">开始订阅  limited$</span><br><span class="line">infinite$: <span class="number">0</span></span><br><span class="line">infinite$: <span class="number">1</span></span><br><span class="line">infinite$: <span class="number">2</span></span><br><span class="line">infinite$: <span class="number">3</span></span><br><span class="line">infinite$: <span class="number">4</span></span><br><span class="line">limited$: <span class="number">0</span></span><br><span class="line">infinite$: <span class="number">5</span></span><br><span class="line">infinite$: <span class="number">6</span></span><br><span class="line">infinite$: <span class="number">7</span></span><br><span class="line">infinite$: <span class="number">8</span></span><br><span class="line">infinite$: <span class="number">9</span></span><br><span class="line">limited$: <span class="number">1</span></span><br><span class="line">销毁 limited$</span><br><span class="line">销毁 infinite $</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-算数&amp;聚合操作符-07-05</title>
      <link href="/2017/12/20/Swift/RxSwift/Grammar/07-05-Operators-%E6%95%B0%E5%AD%A6%E5%92%8C%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2017/12/20/Swift/RxSwift/Grammar/07-05-Operators-%E6%95%B0%E5%AD%A6%E5%92%8C%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      <content type="html"><![CDATA[<ul><li><a href="#①toArray">①toArray</a></li><li><a href="#1.2">①②reduce</a></li><li><a href="#1.3">②concat</a></li></ul><p><span id="①toArray">①toArray</span></p><h1 id="①toArray"><a href="#①toArray" class="headerlink" title="①toArray"></a>①toArray</h1><blockquote><p>将sequence转换成一个array，并转换成单一事件信号，然后结束</p></blockquote><h2 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="type">Observable</span>.range(start: <span class="number">1</span>, <span class="built_in">count</span>: <span class="number">10</span>)</span><br><span class="line">          .toArray()</span><br><span class="line">          .subscribe &#123; </span><br><span class="line">                    <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">                &#125;</span><br><span class="line">         .addDisposableTo(disposeBag)</span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line">next([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line">completed</span><br></pre></td></tr></table></figure><p><span id="②reduce">②reduce</span></p><h1 id="②reduce"><a href="#②reduce" class="headerlink" title="②reduce"></a>②reduce</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>用一个初始值，对事件数据进行累计操作<br>reduce接受一个初始值，和一个操作符号<br>使用一个初始值和一个操作符，对Observable序列中的所有元素进行累计操作，并转换成单一事件信号。(PS:和map有的区别就是：map针对单个元素进行操作，reduce针对所有元素累计操作)</p></blockquote><h2 id="使用样例-1"><a href="#使用样例-1" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()   </span><br><span class="line"><span class="type">Observable</span>.of(<span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>)</span><br><span class="line">    .<span class="built_in">reduce</span>(<span class="number">1</span>, accumulator: +)</span><br><span class="line">    .subscribe(onNext: &#123; </span><br><span class="line">                 <span class="built_in">print</span>($<span class="number">0</span>) </span><br><span class="line">             &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line">  <span class="number">1111</span></span><br></pre></td></tr></table></figure><p><span id="1.3">③concat</span></p><h1 id="③concat"><a href="#③concat" class="headerlink" title="③concat"></a>③concat</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>oncat会把多个sequence和并为一个sequence，并且当前面一个sequence发出了completed事件，才会开始下一个sequence的事件<br>在第一sequence完成之前，第二个sequence发出的事件都会被忽略，但会接收一完成之前的二发出的最后一个事件。不好解释，看例子说明</p></blockquote><h2 id="使用样例-2"><a href="#使用样例-2" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> subject1 = <span class="type">BehaviorSubject</span>(value: <span class="string">"🍎"</span>)</span><br><span class="line"><span class="keyword">let</span> subject2 = <span class="type">BehaviorSubject</span>(value: <span class="string">"🐶"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> variable = <span class="type">Variable</span>(subject1)</span><br><span class="line">    </span><br><span class="line">variable.asObservable()</span><br><span class="line">    .concat()</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line">    </span><br><span class="line">subject1.onNext(<span class="string">"🍐"</span>)</span><br><span class="line">subject1.onNext(<span class="string">"🍊"</span>)</span><br><span class="line">    </span><br><span class="line">variable.value = subject2</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">subject2.onNext(<span class="string">"🐱"</span>)   <span class="comment">//1完成前，会被忽略</span></span><br><span class="line">subject2.onNext(<span class="string">"teng"</span>) <span class="comment">//1完成前，会被忽略</span></span><br><span class="line">subject2.onNext(<span class="string">"fei"</span>)  <span class="comment">//1完成前的最后一个，会被接收</span></span><br><span class="line">    </span><br><span class="line">subject1.onCompleted()</span><br><span class="line">    </span><br><span class="line">subject2.onNext(<span class="string">"🐭"</span>)</span><br><span class="line"></span><br><span class="line">next(🍎)</span><br><span class="line">next(🍐)</span><br><span class="line">next(🍊)</span><br><span class="line">next(fei)</span><br><span class="line">next(🐭)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-RxSwift-Combination Operators-联合操作Observable流-07-04</title>
      <link href="/2017/12/19/Swift/RxSwift/Grammar/07-04-Operators-%E8%81%94%E5%90%88%E6%93%8D%E4%BD%9CObservable%E6%B5%81/"/>
      <url>/2017/12/19/Swift/RxSwift/Grammar/07-04-Operators-%E8%81%94%E5%90%88%E6%93%8D%E4%BD%9CObservable%E6%B5%81/</url>
      <content type="html"><![CDATA[<p><span id="1">联合操作Observable流</span></p><h1 id="联合操作Observable流"><a href="#联合操作Observable流" class="headerlink" title="联合操作Observable流"></a>联合操作Observable流</h1><blockquote><p>结合操作（或者称合并操作）指的是将多个 Observable 序列进行组合，拼装成一个新的 Observable 序列<br>联合操作就是把多个<strong>Observable流</strong>合成<strong>单个Observable流</strong></p></blockquote><ul><li>①startWith (优先插入特定的事件消息)</li><li>②merge （组合成单个Observable,并且按照时间顺序发射对应事件）</li><li>③zip （一个事件对应另一个流一个事件）</li><li>④combineLatest （一个流的事件对应另一个流的最新的事件）</li><li>⑤switchLatest (事件流进行转换)</li></ul><ul><li><a href="#1">联合操作Observable流</a></li><li><a href="#①startWith">①startWith</a></li><li><a href="#②merge">②merge</a></li><li><a href="#1.3">③zip</a></li><li><a href="#1.4">④combineLatest</a></li><li><a href="#1.5">⑤switchLatest</a></li></ul><p><span id="①startWith">①startWith</span></p><p>#①startWith</p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>在发出事件消息之前，先发出某个特定的事件消息。<br>比如发出事件2 ，3然后我startWith(1)，那么就会先发出1，然后2 ，3</p></blockquote><p><img src="http://ozr735s7e.bkt.clouddn.com/startWith.png" alt="startWith"></p><h2 id="使用样例1"><a href="#使用样例1" class="headerlink" title="使用样例1"></a>使用样例1</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"2"</span>,<span class="string">"3"</span>)</span><br><span class="line">         .startWith(<span class="string">"1"</span>)</span><br><span class="line">         .subscribe(onNext:&#123;</span><br><span class="line">                      <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">                      &#125;)</span><br><span class="line">         .addDisposableTo(disposeBag)</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="使用样例2"><a href="#使用样例2" class="headerlink" title="使用样例2"></a>使用样例2</h2><blockquote><p>在Observable释放元素之前，发射指定的元素序列<br>startWith和栈类似，先进后出<br>在发送一个东西前，先发送一个指定的</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">Observable.of([&quot;C&quot;,&quot;C++&quot;,&quot;OC&quot;])</span><br><span class="line">          .startWith([&quot;今晚吃鸡，大吉大利&quot;])</span><br><span class="line">          .subscribe(&#123; (event) in</span><br><span class="line">                 print(event)</span><br><span class="line">            &#125;)</span><br><span class="line">          .disposed(by: disposeBag)</span><br><span class="line">//打印</span><br><span class="line">next([&quot;今晚吃鸡，大吉大利&quot;])</span><br><span class="line">next([&quot;C&quot;, &quot;C++&quot;, &quot;OC&quot;])</span><br><span class="line">completed</span><br></pre></td></tr></table></figure><p><span id="②merge">②merge</span></p><h1 id="②merge"><a href="#②merge" class="headerlink" title="②merge"></a>②merge</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>将多个Observable组合成单个Observable,并且按照时间顺序发射对应事件</p></blockquote><p><img src="http://ozr735s7e.bkt.clouddn.com/merge.png" alt="merge"></p><h2 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">let</span> sbj1 = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> sbj2 = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="type">Observable</span>.of(sbj1,sbj2)</span><br><span class="line">          .merge()</span><br><span class="line">          .subscribe(onNext: &#123; </span><br><span class="line">                    <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">               &#125;)</span><br><span class="line">          .addDisposableTo(disposeBag)</span><br><span class="line">subject1.onNext(<span class="string">"🅰️"</span>)</span><br><span class="line">subject1.onNext(<span class="string">"🅱️"</span>)</span><br><span class="line">subject2.onNext(<span class="string">"①"</span>)</span><br><span class="line">subject2.onNext(<span class="string">"②"</span>)</span><br><span class="line">subject1.onNext(<span class="string">"🆎"</span>)</span><br><span class="line">subject2.onNext(<span class="string">"③"</span>)</span><br><span class="line">   </span><br><span class="line"><span class="comment">//</span></span><br><span class="line">🅰️</span><br><span class="line">🅱️</span><br><span class="line">①</span><br><span class="line">②</span><br><span class="line">🆎</span><br><span class="line">③</span><br></pre></td></tr></table></figure><p><span id="③zip">③zip</span></p><h2 id="③zip"><a href="#③zip" class="headerlink" title="③zip"></a>③zip</h2><h2 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>绑定超过最多不超过8个的Observable流，结合在一起处理<br>注意Zip是一个事件对应另一个流一个事件<br>将多个Observable(注意：必须是要成对)组合成单个Observable，当有事件到达时，会在每个序列中对应的索引上对应的元素发出。(ps:之前版本的RxSwift好像最多只能组合8个Observable)</p></blockquote><p><a href="http://reactivex.io/documentation/operators/zip.html" target="_blank" rel="noopener">zip-文档</a></p><h2 id="使用样例-1"><a href="#使用样例-1" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> strSbj = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> intSbj = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">   </span><br><span class="line"><span class="type">Observable</span>.<span class="built_in">zip</span>(strSbj, intSbj)&#123;</span><br><span class="line">  strElement,intElement  <span class="keyword">in</span> </span><br><span class="line">  <span class="string">"<span class="subst">\(strElement)</span> <span class="subst">\(intElement)</span>"</span></span><br><span class="line"> &#125;</span><br><span class="line">         .subscribe(<span class="type">OnNext</span>: &#123;</span><br><span class="line">                   pint($<span class="number">0</span>)</span><br><span class="line">              &#125;)</span><br><span class="line">         .addDisposableTo(disposeBag)</span><br><span class="line">   </span><br><span class="line">strSbj.onNext(<span class="string">"🅰️"</span>)</span><br><span class="line">strSbj.onNext(<span class="string">"🅱️"</span>)</span><br><span class="line">   </span><br><span class="line">intSbj.onNext(<span class="number">1</span>)</span><br><span class="line">intSbj.onNext(<span class="number">2</span>)</span><br><span class="line">   </span><br><span class="line">strSbj.onNext(<span class="string">"🆎"</span>)</span><br><span class="line">intSbj.onNext(<span class="number">2</span>)</span><br><span class="line">   </span><br><span class="line"><span class="comment">//</span></span><br><span class="line">🅰️ <span class="number">1</span>   将stringSubject和intSubject压缩到一起共同处理</span><br><span class="line">🅱️ <span class="number">2</span></span><br><span class="line">🆎 <span class="number">3</span></span><br></pre></td></tr></table></figure><p><span id="④combineLatest">④combineLatest</span></p><h1 id="④combineLatest"><a href="#④combineLatest" class="headerlink" title="④combineLatest"></a>④combineLatest</h1><h2 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>绑定超过最多不超过8个的Observable流，结合在一起处理<br>和Zip不同的是combineLatest是一个流的事件对应另一个流的最新的事件，两个事件都会是最新的事件，可将下图与Zip的图进行对比<br>邻近事件一起处理</p></blockquote><p><img src="http://ozr735s7e.bkt.clouddn.com/combineLatest.png" alt="combineLatest"></p><h2 id="使用样例-2"><a href="#使用样例-2" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">let</span> strSbj = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> intSbj = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">   </span><br><span class="line"><span class="type">Observable</span>.combineLatest(strSbj, intSbj)&#123; strElement,intElement <span class="keyword">in</span></span><br><span class="line">                     <span class="string">"<span class="subst">\(strElement)</span> <span class="subst">\(intElement)</span>"</span></span><br><span class="line">              &#125;</span><br><span class="line">         .addscribe(onNext: &#123;<span class="built_in">print</span>(</span><br><span class="line">                   $<span class="number">0</span>)</span><br><span class="line">                 &#125;)</span><br><span class="line">         .addDisposableTo(disposeBag)</span><br><span class="line">   </span><br><span class="line">strSbj.onNext(<span class="string">"🅰️"</span>)</span><br><span class="line">strSbj.onNext(<span class="string">"🅱️"</span>)</span><br><span class="line">intSbj.onNext(<span class="number">1</span>)</span><br><span class="line">intSbj.onNext(<span class="number">2</span>)</span><br><span class="line">strSbj.onNext(<span class="string">"🆎"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">🅱️ <span class="number">1</span></span><br><span class="line">🅱️ <span class="number">2</span></span><br><span class="line">🆎 <span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p>当一个项目由两个Observables发射时，通过一个指定的功能将每个Observable观察到的最新项目组合起来，并根据该功能的结果发射事件</p></blockquote><p><img src="http://ot0mms4k8.bkt.clouddn.com/Combination-Operators-4-2.png" alt=""></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> subject1 = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> subject2 = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>.combineLatest(subject1, subject2) &#123; string1,string2 <span class="keyword">in</span></span><br><span class="line">                <span class="string">"<span class="subst">\(string1)</span>--<span class="subst">\(string2)</span>"</span></span><br><span class="line">              &#125;</span><br><span class="line">    .subscribe(onNext: &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">    </span><br><span class="line">subject1.onNext(<span class="string">"A"</span>)</span><br><span class="line">    </span><br><span class="line">subject2.onNext(<span class="string">"1"</span>)</span><br><span class="line">subject2.onNext(<span class="string">"2"</span>)</span><br><span class="line">    </span><br><span class="line">subject1.onNext(<span class="string">"B"</span>)</span><br><span class="line">subject1.onNext(<span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="type">A</span>--<span class="number">1</span></span><br><span class="line"><span class="type">A</span>--<span class="number">2</span></span><br><span class="line"><span class="type">B</span>--<span class="number">2</span></span><br><span class="line"><span class="type">C</span>--<span class="number">2</span></span><br></pre></td></tr></table></figure><p><span id="⑤switchLatest">⑤switchLatest</span></p><p>#⑤switchLatest</p><h2 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>切换Observable队列<br>switchLatest可以对事件流进行转换，本来监听的sbj1，可以通过更改variable里面的value更换事件源—&gt;变成监听sbj2<br>witchLatest 有点像其他语言的 switch 方法，可以对事件流进行转换</p></blockquote><p><img src="http://ozr735s7e.bkt.clouddn.com/switchLatest.png" alt="hexo"></p><h2 id="使用样例-3"><a href="#使用样例-3" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sbj1 = <span class="type">BehaviorSubject</span>(value: <span class="string">"⚽️"</span>)</span><br><span class="line"><span class="keyword">let</span> sbj2 = <span class="type">BehaviorSubject</span>(value: <span class="string">"🍎"</span>)</span><br><span class="line">   </span><br><span class="line"><span class="keyword">let</span> variable = <span class="type">Variable</span>(sbj1)</span><br><span class="line">variable.asObservable()</span><br><span class="line">        .switchLatest()</span><br><span class="line">        .subscribe(onNext: &#123; </span><br><span class="line">                     <span class="built_in">print</span>($<span class="number">0</span>) </span><br><span class="line">                 &#125;)</span><br><span class="line">        .addDisposableTo(disposeBag)</span><br><span class="line">    </span><br><span class="line">sbj1.onNext(<span class="string">"🏈"</span>)</span><br><span class="line">sbj1.onNext(<span class="string">"🏀"</span>)</span><br><span class="line">    </span><br><span class="line">variable.value = sbj1</span><br><span class="line">    </span><br><span class="line">subject1.onNext(<span class="string">"⚾️"</span>)</span><br><span class="line">    </span><br><span class="line">sbj2.onNext(<span class="string">"🍐"</span>)</span><br><span class="line">variable.value = sbj1</span><br><span class="line">sbj2.onNext(<span class="string">"54321"</span>)</span><br><span class="line">sbj1.onNext(<span class="string">"12345"</span>)</span><br><span class="line">   <span class="comment">///</span></span><br><span class="line">⚽️</span><br><span class="line">🏈</span><br><span class="line">🏀</span><br><span class="line">🍎</span><br><span class="line">🍐</span><br><span class="line">⚾️</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><blockquote><p>例子分析</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> et disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> subject1 = <span class="type">BehaviorSubject</span>(value: <span class="string">"1"</span>)</span><br><span class="line"><span class="keyword">let</span> subject2 = <span class="type">BehaviorSubject</span>(value: <span class="string">"A"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> variable = <span class="type">Variable</span>(subject1)</span><br><span class="line">    </span><br><span class="line">variable.asObservable()</span><br><span class="line">        .switchLatest()</span><br><span class="line">        .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br><span class="line">    </span><br><span class="line">subject1.onNext(<span class="string">"2"</span>)</span><br><span class="line">subject1.onNext(<span class="string">"3"</span>)</span><br><span class="line">    </span><br><span class="line">variable.value = subject2</span><br><span class="line">    </span><br><span class="line">subject1.onNext(<span class="string">"4"</span>)</span><br><span class="line">subject2.onNext(<span class="string">"B"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="type">A</span></span><br><span class="line"><span class="type">B</span></span><br></pre></td></tr></table></figure><p><img src="http://ot0mms4k8.bkt.clouddn.com/switchLatest-002.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-Conditional  Boolean Operators过滤操作符-07-03</title>
      <link href="/2017/12/19/Swift/RxSwift/Grammar/07-03-%E6%93%8D%E4%BD%9C%E7%AC%A6-%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%B8%83%E5%B0%94/"/>
      <url>/2017/12/19/Swift/RxSwift/Grammar/07-03-%E6%93%8D%E4%BD%9C%E7%AC%A6-%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%B8%83%E5%B0%94/</url>
      <content type="html"><![CDATA[<blockquote><p>条件和布尔操作会根据条件发射或变换 Observables，或者对他们做布尔运算</p></blockquote><ul><li><a href="#①amb">①amb</a></li><li><a href="#②takeWhile">②takeWhile</a></li><li><a href="#③takeUntil">③takeUntil</a></li><li><a href="#④skipWhile]">④skipWhile</a></li><li><a href="#⑤skipUntil">⑤skipUntil</a></li></ul><p><span id="①amb">①amb</span></p><h1 id="①amb"><a href="#①amb" class="headerlink" title="①amb"></a>①amb</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>当传入多个 Observables 到 amb 操作符时，它将取第一个发出元素或产生事件的 Observable，然后只发出它的元素。并忽略掉其他的 Observables</p></blockquote><h2 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> subject1 = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> subject2 = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> subject3 = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"> </span><br><span class="line">subject1</span><br><span class="line">    .amb(subject2)</span><br><span class="line">    .amb(subject3)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"> </span><br><span class="line">subject2.onNext(<span class="number">1</span>)</span><br><span class="line">subject1.onNext(<span class="number">20</span>)</span><br><span class="line">subject2.onNext(<span class="number">2</span>)</span><br><span class="line">subject1.onNext(<span class="number">40</span>)</span><br><span class="line">subject3.onNext(<span class="number">0</span>)</span><br><span class="line">subject2.onNext(<span class="number">3</span>)</span><br><span class="line">subject1.onNext(<span class="number">60</span>)</span><br><span class="line">subject3.onNext(<span class="number">0</span>)</span><br><span class="line">subject3.onNext(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><span id="②takeWhile">②takeWhile</span></p><h1 id="②takeWhile"><a href="#②takeWhile" class="headerlink" title="②takeWhile"></a>②takeWhile</h1><blockquote><p>该方法依次判断 Observable 序列的每一个值是否满足给定的条件。 当第一个不满足条件的值出现时，它便自动完成</p></blockquote><h2 id="使用样例-1"><a href="#使用样例-1" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"> </span><br><span class="line"><span class="type">Observable</span>.of(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">    .takeWhile &#123; $<span class="number">0</span> &lt; <span class="number">4</span> &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"><span class="comment">//print</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><span id="③takeUntil">③takeUntil</span></p><h1 id="③takeUntil"><a href="#③takeUntil" class="headerlink" title="③takeUntil"></a>③takeUntil</h1><blockquote><p>除了订阅源 Observable 外，通过 takeUntil 方法我们还可以监视另外一个 Observable， 即 notifier。<br>如果 notifier 发出值或 complete 通知，那么源 Observable 便自动完成，停止发送事件</p></blockquote><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><h2 id="使用样例-2"><a href="#使用样例-2" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> source = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> notifier = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"> </span><br><span class="line">source</span><br><span class="line">    .takeUntil(notifier)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"> </span><br><span class="line">source.onNext(<span class="string">"a"</span>)</span><br><span class="line">source.onNext(<span class="string">"b"</span>)</span><br><span class="line">source.onNext(<span class="string">"c"</span>)</span><br><span class="line">source.onNext(<span class="string">"d"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//停止接收消息</span></span><br><span class="line">notifier.onNext(<span class="string">"z"</span>)</span><br><span class="line"> </span><br><span class="line">source.onNext(<span class="string">"e"</span>)</span><br><span class="line">source.onNext(<span class="string">"f"</span>)</span><br><span class="line">source.onNext(<span class="string">"g"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line"><span class="built_in">c</span></span><br><span class="line">d</span><br></pre></td></tr></table></figure><p><span id="④skipWhile">④skipWhile</span></p><h1 id="④skipWhile"><a href="#④skipWhile" class="headerlink" title="④skipWhile"></a>④skipWhile</h1><h2 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>该方法用于跳过前面所有满足条件的事件。<br>一旦遇到不满足条件的事件，之后就不会再跳过了</p></blockquote><h2 id="使用样例-3"><a href="#使用样例-3" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"> </span><br><span class="line"><span class="type">Observable</span>.of(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">    .skipWhile &#123; $<span class="number">0</span> &lt; <span class="number">4</span> &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p><span id="⑤skipUntil">⑤skipUntil</span></p><h1 id="⑤skipUntil"><a href="#⑤skipUntil" class="headerlink" title="⑤skipUntil"></a>⑤skipUntil</h1><h2 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>同上面的 takeUntil 一样，skipUntil 除了订阅源 Observable 外，通过 skipUntil 方法我们还可以监视另外一个 Observable， 即 notifier 。<br>与 takeUntil 相反的是。源 Observable 序列事件默认会一直跳过，直到 notifier 发出值或 complete 通知。</p></blockquote><h2 id="使用样例-4"><a href="#使用样例-4" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> source = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> notifier = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"> </span><br><span class="line">source</span><br><span class="line">    .skipUntil(notifier)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"> </span><br><span class="line">source.onNext(<span class="number">1</span>)</span><br><span class="line">source.onNext(<span class="number">2</span>)</span><br><span class="line">source.onNext(<span class="number">3</span>)</span><br><span class="line">source.onNext(<span class="number">4</span>)</span><br><span class="line">source.onNext(<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//开始接收消息</span></span><br><span class="line">notifier.onNext(<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">source.onNext(<span class="number">6</span>)</span><br><span class="line">source.onNext(<span class="number">7</span>)</span><br><span class="line">source.onNext(<span class="number">8</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//仍然接收消息</span></span><br><span class="line">notifier.onNext(<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">source.onNext(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-RxSwift-连接性操作</title>
      <link href="/2017/12/19/Swift/RxSwift/Grammar/Operators-%E8%BF%9E%E6%8E%A5%E6%80%A7%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/12/19/Swift/RxSwift/Grammar/Operators-%E8%BF%9E%E6%8E%A5%E6%80%A7%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h1 id="连接性操作"><a href="#连接性操作" class="headerlink" title="连接性操作"></a>连接性操作</h1><ul><li><a href="#1.1">①publish</a></li><li><a href="#1.2">②replay</a></li><li><a href="#1.3">③multicast</a></li></ul><blockquote><p>Connectable Observable有订阅时不开始发射事件消息，而是仅当调用它们的connect（）方法时。这样就可以等待所有我们想要的订阅者都已经订阅了以后，再开始发出事件消息，这样能保证我们想要的所有订阅者都能接收到事件消息。其实也就是等大家都就位以后，开始发出消息</p></blockquote><p><span id="1.1">①publish</span></p><h2 id="①publish"><a href="#①publish" class="headerlink" title="①publish"></a>①publish</h2><blockquote><p>将一个正常的sequence转换成一个connectable sequence</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> intSequence = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.interval(<span class="number">1</span>, scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">    .publish()</span><br><span class="line">    </span><br><span class="line"><span class="number">_</span> = intSequence</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>(<span class="string">"Subscription 1:, Event: <span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;)</span><br><span class="line">    </span><br><span class="line">delay(<span class="number">2</span>) &#123; <span class="number">_</span> = intSequence.connect() &#125; <span class="comment">//相当于把事件消息推迟了两秒</span></span><br><span class="line">    </span><br><span class="line">delay(<span class="number">4</span>) &#123;</span><br><span class="line">    <span class="number">_</span> = intSequence</span><br><span class="line">        .subscribe(onNext: &#123; <span class="built_in">print</span>(<span class="string">"Subscription 2:, Event: <span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">delay(<span class="number">6</span>) &#123;</span><br><span class="line">    <span class="number">_</span> = intSequence</span><br><span class="line">        .subscribe(onNext: &#123; <span class="built_in">print</span>(<span class="string">"Subscription 3:, Event: <span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">Subscription</span> <span class="number">1</span>:, <span class="type">Event</span>: <span class="number">0</span></span><br><span class="line"><span class="type">Subscription</span> <span class="number">1</span>:, <span class="type">Event</span>: <span class="number">1</span></span><br><span class="line"><span class="type">Subscription</span> <span class="number">2</span>:, <span class="type">Event</span>: <span class="number">1</span></span><br><span class="line"><span class="type">Subscription</span> <span class="number">1</span>:, <span class="type">Event</span>: <span class="number">2</span></span><br><span class="line"><span class="type">Subscription</span> <span class="number">2</span>:, <span class="type">Event</span>: <span class="number">2</span></span><br><span class="line"><span class="type">Subscription</span> <span class="number">1</span>:, <span class="type">Event</span>: <span class="number">3</span></span><br><span class="line"><span class="type">Subscription</span> <span class="number">3</span>:, <span class="type">Event</span>: <span class="number">3</span></span><br><span class="line"><span class="type">Subscription</span> <span class="number">2</span>:, <span class="type">Event</span>: <span class="number">3</span></span><br><span class="line"><span class="type">Subscription</span> <span class="number">1</span>:, <span class="type">Event</span>: <span class="number">4</span></span><br><span class="line"><span class="type">Subscription</span> <span class="number">3</span>:, <span class="type">Event</span>: <span class="number">4</span></span><br></pre></td></tr></table></figure><p><span id="1.2">②replay</span></p><h2 id="②replay"><a href="#②replay" class="headerlink" title="②replay"></a>②replay</h2><blockquote><p>将一个正常的sequence转换成一个connectable sequence，然后和replaySubject相似，能接收到订阅之前的事件消息</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> intSequence = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.interval(<span class="number">1</span>, scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">    .replay(<span class="number">5</span>)  <span class="comment">//接收到订阅之前的5条事件消息</span></span><br><span class="line">    </span><br><span class="line"><span class="number">_</span> = intSequence</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>(<span class="string">"Subscription 1:, Event: <span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;)</span><br><span class="line">    </span><br><span class="line">delay(<span class="number">2</span>) &#123; <span class="number">_</span> = intSequence.connect() &#125;</span><br><span class="line">    </span><br><span class="line">delay(<span class="number">4</span>) &#123;</span><br><span class="line">    <span class="number">_</span> = intSequence</span><br><span class="line">        .subscribe(onNext: &#123; <span class="built_in">print</span>(<span class="string">"Subscription 2:, Event: <span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">delay(<span class="number">8</span>) &#123;</span><br><span class="line">    <span class="number">_</span> = intSequence</span><br><span class="line">        .subscribe(onNext: &#123; <span class="built_in">print</span>(<span class="string">"Subscription 3:, Event: <span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="1.3">③multicast</span></p><h2 id="③multicast"><a href="#③multicast" class="headerlink" title="③multicast"></a>③multicast</h2><blockquote><p>将一个正常的sequence转换成一个connectable sequence，并且通过特性的subject发送出去，比如PublishSubject，或者replaySubject，behaviorSubject等。不同的Subject会有不同的结果</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> subject = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    </span><br><span class="line"><span class="number">_</span> = subject</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>(<span class="string">"Subject: <span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> intSequence = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.interval(<span class="number">1</span>, scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">    .multicast(subject)</span><br><span class="line">    </span><br><span class="line"><span class="number">_</span> = intSequence</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>(<span class="string">"\tSubscription 1:, Event: <span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;)</span><br><span class="line">    </span><br><span class="line">delay(<span class="number">2</span>) &#123; <span class="number">_</span> = intSequence.connect() &#125;</span><br><span class="line">    </span><br><span class="line">delay(<span class="number">4</span>) &#123;</span><br><span class="line">    <span class="number">_</span> = intSequence</span><br><span class="line">        .subscribe(onNext: &#123; <span class="built_in">print</span>(<span class="string">"\tSubscription 2:, Event: <span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-RxSwift-错误处理操作</title>
      <link href="/2017/12/19/Swift/RxSwift/Grammar/Operators-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/12/19/Swift/RxSwift/Grammar/Operators-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h1 id="错误处理操作"><a href="#错误处理操作" class="headerlink" title="错误处理操作"></a>错误处理操作</h1><ul><li><a href="#1.1">①catchErrorJustReturn</a></li><li><a href="#1.2">②catchError</a></li><li><a href="#1.3">③retry</a></li><li><a href="#1.4">④debug</a></li></ul><p><span id="1.1">①catchErrorJustReturn</span></p><h2 id="①catchErrorJustReturn"><a href="#①catchErrorJustReturn" class="headerlink" title="①catchErrorJustReturn"></a>①catchErrorJustReturn</h2><blockquote><p>遇到error事件的时候，就return一个值，然后结束</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> sequenceThatFails = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    </span><br><span class="line">sequenceThatFails</span><br><span class="line">    .catchErrorJustReturn(<span class="string">"😊"</span>)</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line">    </span><br><span class="line">sequenceThatFails.onNext(<span class="string">"😬"</span>)</span><br><span class="line">sequenceThatFails.onNext(<span class="string">"😨"</span>)</span><br><span class="line">sequenceThatFails.onNext(<span class="string">"😡"</span>)</span><br><span class="line">sequenceThatFails.onNext(<span class="string">"🔴"</span>)</span><br><span class="line">sequenceThatFails.onError(<span class="type">TestError</span>.test)</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line">next(😬)</span><br><span class="line">next(😨)</span><br><span class="line">next(😡)</span><br><span class="line">next(🔴)</span><br><span class="line">next(😊)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure><p><span id="1.2">②catchError</span></p><h2 id="②catchError"><a href="#②catchError" class="headerlink" title="②catchError"></a>②catchError</h2><blockquote><p>捕获error进行处理，可以返回另一个sequence进行订阅</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> sequenceThatFails = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> recoverySequence = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    </span><br><span class="line">sequenceThatFails</span><br><span class="line">    .catchError &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Error:"</span>, $<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> recoverySequence</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line">    </span><br><span class="line">sequenceThatFails.onNext(<span class="string">"😬"</span>)</span><br><span class="line">sequenceThatFails.onNext(<span class="string">"😨"</span>)</span><br><span class="line">sequenceThatFails.onNext(<span class="string">"😡"</span>)</span><br><span class="line">sequenceThatFails.onNext(<span class="string">"🔴"</span>)</span><br><span class="line">sequenceThatFails.onError(<span class="type">TestError</span>.test)</span><br><span class="line">    </span><br><span class="line">recoverySequence.onNext(<span class="string">"😊"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">next(😬)</span><br><span class="line">next(😨)</span><br><span class="line">next(😡)</span><br><span class="line">next(🔴)</span><br><span class="line"><span class="type">Error</span>: test</span><br><span class="line">next(😊)</span><br></pre></td></tr></table></figure><p><span id="1.3">③retry</span></p><h2 id="③retry"><a href="#③retry" class="headerlink" title="③retry"></a>③retry</h2><blockquote><p>遇见error事件可以进行重试，比如网络请求失败，可以进行重新连接</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> sequenceThatErrors = <span class="type">Observable</span>&lt;<span class="type">String</span>&gt;.create &#123; observer <span class="keyword">in</span></span><br><span class="line">    observer.onNext(<span class="string">"🍎"</span>)</span><br><span class="line">    observer.onNext(<span class="string">"🍐"</span>)</span><br><span class="line">    observer.onNext(<span class="string">"🍊"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">count</span> == <span class="number">1</span> &#123;</span><br><span class="line">        observer.onError(<span class="type">TestError</span>.test)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Error encountered"</span>)</span><br><span class="line">        <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    observer.onNext(<span class="string">"🐶"</span>)</span><br><span class="line">    observer.onNext(<span class="string">"🐱"</span>)</span><br><span class="line">    observer.onNext(<span class="string">"🐭"</span>)</span><br><span class="line">    observer.onCompleted()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">sequenceThatErrors</span><br><span class="line">    .retry(<span class="number">3</span>)       <span class="comment">//不传入数字的话，只会重试一次</span></span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><p><span id="1.4">④debug</span></p><h1 id="④debug"><a href="#④debug" class="headerlink" title="④debug"></a>④debug</h1><blockquote><p>打印所有的订阅, 事件和disposals</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line"></span><br><span class="line">sequenceThatErrors</span><br><span class="line">    .retry(<span class="number">3</span>)</span><br><span class="line">    .debug()</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><h1 id="RxSwift-Resources-total"><a href="#RxSwift-Resources-total" class="headerlink" title="RxSwift.Resources.total"></a>RxSwift.Resources.total</h1><blockquote><p>查看RxSwift所有资源的占用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="type">RxSwift</span>.<span class="type">Resources</span>.total)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-RxSwift-过滤和条件操作符</title>
      <link href="/2017/12/19/Swift/RxSwift/Grammar/Operators-%E8%BF%87%E6%BB%A4%E5%92%8C%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2017/12/19/Swift/RxSwift/Grammar/Operators-%E8%BF%87%E6%BB%A4%E5%92%8C%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      <content type="html"><![CDATA[<h1 id="过滤和条件操作符"><a href="#过滤和条件操作符" class="headerlink" title="过滤和条件操作符"></a>过滤和条件操作符</h1><p><a href="#1.1">①filter</a><br><a href="#1.2">②distinctUntilChanged</a><br><a href="#1.3">③elementAt</a><br><a href="#1.4">④single</a><br><a href="#1.5">⑤take</a><br><a href="#1.6">⑥takeLast</a><br><a href="#1.7">⑦takeWhile</a><br><a href="#1.8">⑧takeUntil</a><br><a href="#1.9">⑨skip</a><br><a href="#1.10">⑩ skipWhile</a><br><a href="#1.11">⑪skipWhileWithIndex</a><br><a href="#1.12">⑫skipUntil</a> </p><p><span id="1.1">①filter </span></p><h2 id="①filter"><a href="#①filter" class="headerlink" title="①filter"></a>①filter</h2><blockquote><p>过滤掉某些不符合要求的事件<br>在Observable序列中只发出满足过滤条件的事件</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>.of(</span><br><span class="line">    <span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>,</span><br><span class="line">    <span class="string">"🐸"</span>, <span class="string">"🐱"</span>, <span class="string">"🐰"</span>,</span><br><span class="line">    <span class="string">"🐹"</span>, <span class="string">"🐸"</span>, <span class="string">"🐱"</span>)</span><br><span class="line">    .<span class="built_in">filter</span> &#123;</span><br><span class="line">        $<span class="number">0</span> == <span class="string">"🐱"</span></span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line"><span class="comment">///</span></span><br><span class="line">🐱</span><br><span class="line">🐱</span><br><span class="line">🐱</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line">  <span class="type">Observable</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">            .<span class="built_in">filter</span>(</span><br><span class="line">                   &#123;$<span class="number">0</span> &gt; <span class="number">2</span>&#125;</span><br><span class="line">                   )</span><br><span class="line">            .subscribe(</span><br><span class="line">                       onNext: &#123;<span class="built_in">print</span>($<span class="number">0</span>)&#125;</span><br><span class="line">                      )</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p><span id="1.2">②distinctUntilChanged </span></p><h2 id="②distinctUntilChanged"><a href="#②distinctUntilChanged" class="headerlink" title="②distinctUntilChanged"></a>②distinctUntilChanged</h2><blockquote><p>过滤连续发出的相同事件<br>distinctUntilChanged就是当下一个事件与前一个事件是不同事件的事件才进行处理操作</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"🐱"</span>, <span class="string">"🐷"</span>, <span class="string">"🐱"</span>, <span class="string">"🐱"</span>, <span class="string">"🐱"</span>, <span class="string">"🐵"</span>, <span class="string">"🐱"</span>)</span><br><span class="line">    .distinctUntilChanged()</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line">🐱</span><br><span class="line">🐷</span><br><span class="line">🐱</span><br><span class="line">🐵</span><br><span class="line">🐱</span><br></pre></td></tr></table></figure><p><span id="1.3">③elementAt </span></p><h2 id="③elementAt"><a href="#③elementAt" class="headerlink" title="③elementAt"></a>③elementAt</h2><blockquote><p>只处理在指定位置的事件</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>, <span class="string">"🐸"</span>, <span class="string">"🐷"</span>, <span class="string">"🐵"</span>)</span><br><span class="line">    .elementAt(<span class="number">3</span>)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">🐸</span><br></pre></td></tr></table></figure><p><span id="1.4">④single</span></p><h2 id="④single"><a href="#④single" class="headerlink" title="④single"></a>④single</h2><blockquote><p>用法一：检测Observable序列是否发射一个元素。如果发射多个，会报错</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// error:Sequence contains more than one element</span></span><br><span class="line"><span class="comment">// Observable.of(1,2,3).single().subscribe(onNext: &#123;print($0)&#125;).disposed(by: disposeBag)</span></span><br><span class="line"></span><br><span class="line"><span class="type">Observable</span>.of(<span class="number">1</span>)</span><br><span class="line">          .single()</span><br><span class="line">          .subscribe(</span><br><span class="line">                     onNext: &#123;<span class="built_in">print</span>($<span class="number">0</span>)&#125;</span><br><span class="line">                    )</span><br><span class="line">          .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><blockquote><p>用法二:检测Observable序列发射的元素里面是否包含多个指定的元素，如果有多个或者没有，会报错。</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>, <span class="string">"🐸"</span>, <span class="string">"🐷"</span>, <span class="string">"🐵"</span>)</span><br><span class="line">    .single &#123; $<span class="number">0</span> == <span class="string">"🐸"</span> &#125;</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>, <span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>)</span><br><span class="line">    .single &#123; $<span class="number">0</span> == <span class="string">"🐒"</span> &#125;</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>, <span class="string">"🐶"</span>,<span class="string">"🐸"</span>)</span><br><span class="line">    .single &#123; $<span class="number">0</span> == <span class="string">"🐶"</span> &#125;</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//打印结果</span></span><br><span class="line">next(🐸)</span><br><span class="line">completed</span><br><span class="line">error(<span class="type">Sequence</span> doesn't contain any elements.)</span><br><span class="line">next(🐶)</span><br><span class="line">error(<span class="type">Sequence</span> <span class="built_in">contains</span> more than one element.)</span><br></pre></td></tr></table></figure><blockquote><p>出在sequence只发出一次的事件，如果超过一个就会发出error错误</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.of(<span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>, <span class="string">"🐸"</span>, <span class="string">"🐷"</span>, <span class="string">"🐵"</span>)</span><br><span class="line"> .single()</span><br><span class="line"> .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line"> .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  🐱  <span class="comment">//单一信号超过了一个</span></span><br><span class="line"><span class="type">Received</span> unhandled error: /<span class="keyword">var</span>/folders/hz/v15ld5mj0nqf83d21j13y0tw0000gn/<span class="type">T</span>/./lldb/<span class="number">7229</span>/playground107.swift:<span class="number">69</span>:__lldb_expr_107 -&gt; <span class="type">Sequence</span> <span class="built_in">contains</span> more than one element.</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.of(<span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>, <span class="string">"🐸"</span>, <span class="string">"🐷"</span>, <span class="string">"🐵"</span>)</span><br><span class="line"> .single &#123; $<span class="number">0</span> == <span class="string">"🐸"</span> &#125;      <span class="comment">//青蛙只有一个，completed</span></span><br><span class="line"> .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line"> .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.of(<span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>, <span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>)</span><br><span class="line"> .single &#123; $<span class="number">0</span> == <span class="string">"🐰"</span> &#125; <span class="comment">//兔子有两个，会发出error</span></span><br><span class="line"> .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line"> .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.of(<span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>, <span class="string">"🐸"</span>, <span class="string">"🐷"</span>, <span class="string">"🐵"</span>)</span><br><span class="line"> .single &#123; $<span class="number">0</span> == <span class="string">"🔵"</span> &#125; <span class="comment">//没有蓝色球，会发出error</span></span><br><span class="line"> .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line"> .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><p><span id="1.5">⑤take</span></p><h2 id="⑤take"><a href="#⑤take" class="headerlink" title="⑤take"></a>⑤take</h2><blockquote><p>只处理前几个事件信号</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>, <span class="string">"🐸"</span>, <span class="string">"🐷"</span>, <span class="string">"🐵"</span>)</span><br><span class="line">    .take(<span class="number">3</span>)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">🐱</span><br><span class="line">🐰</span><br><span class="line">🐶</span><br></pre></td></tr></table></figure><blockquote><p>从Observable序列开始点起只处理前几个事件</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">         .take(<span class="number">2</span>)</span><br><span class="line">         .subscribe(</span><br><span class="line">                    onNext: &#123;<span class="built_in">print</span>($<span class="number">0</span>)&#125;</span><br><span class="line">                   )</span><br><span class="line">         .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果:</span></span><br><span class="line"> <span class="number">1</span></span><br><span class="line"> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><span id="1.6">⑥takeLast</span></p><h2 id="⑥takeLast"><a href="#⑥takeLast" class="headerlink" title="⑥takeLast"></a>⑥takeLast</h2><blockquote><p>只处理后几个事件信号<br>与take相反，从Observable序列的结束位置起，只处理前几个事件</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>, <span class="string">"🐸"</span>, <span class="string">"🐷"</span>, <span class="string">"🐵"</span>)</span><br><span class="line">    .takeLast(<span class="number">3</span>)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">🐸</span><br><span class="line">🐷</span><br><span class="line">🐵</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()    </span><br><span class="line"><span class="type">Observable</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">          .takeLast(<span class="number">2</span>)</span><br><span class="line">          .subscribe(onNext: &#123;<span class="built_in">print</span>($<span class="number">0</span>)&#125;)</span><br><span class="line">          .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><span id="1.7">⑦takeWhile</span></p><h2 id="⑦takeWhile"><a href="#⑦takeWhile" class="headerlink" title="⑦takeWhile"></a>⑦takeWhile</h2><blockquote><p>只处理满足条件的事件。感觉和filter没什么区别</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">   </span><br><span class="line"><span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">    .takeWhile &#123; $<span class="number">0</span> &lt; <span class="number">4</span> &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line">   <span class="comment">//打印结果：</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="type">Observable</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">          .takeWhile&#123;$<span class="number">0</span> &lt; <span class="number">3</span>&#125;</span><br><span class="line">          .subscribe(onNext: &#123;<span class="built_in">print</span>($<span class="number">0</span>)&#125;)</span><br><span class="line">          .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p><span id="1.8">⑧takeUntil</span></p><h2 id="⑧takeUntil"><a href="#⑧takeUntil" class="headerlink" title="⑧takeUntil"></a>⑧takeUntil</h2><blockquote><p>接收事件消息，直到另一个sequence发出事件消息的时候</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">   </span><br><span class="line"><span class="keyword">let</span> sourceSequence = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> referenceSequence = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">   </span><br><span class="line">sourceSequence</span><br><span class="line">    .takeUntil(referenceSequence)</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line">   </span><br><span class="line">sourceSequence.onNext(<span class="string">"🐱"</span>)</span><br><span class="line">sourceSequence.onNext(<span class="string">"🐰"</span>)</span><br><span class="line">sourceSequence.onNext(<span class="string">"🐶"</span>)</span><br><span class="line">    </span><br><span class="line">referenceSequence.onNext(<span class="string">"🔴"</span>)  <span class="comment">//停止接收消息</span></span><br><span class="line">    </span><br><span class="line">sourceSequence.onNext(<span class="string">"🐸"</span>)</span><br><span class="line">sourceSequence.onNext(<span class="string">"🐷"</span>)</span><br><span class="line">sourceSequence.onNext(<span class="string">"🐵"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line">next(🐱)</span><br><span class="line">next(🐰)</span><br><span class="line">next(🐶)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure><blockquote><p>直到另一个Observable序列发出一个信号，则原序列终</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">   </span><br><span class="line"><span class="keyword">let</span> orinSubject = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> refreSubject = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    </span><br><span class="line">orinSubject.takeUntil(refreSubject)</span><br><span class="line">           .subscribe(onNext: &#123;<span class="built_in">print</span>($<span class="number">0</span>)&#125;)</span><br><span class="line">           .disposed(by: disposeBag)</span><br><span class="line">    </span><br><span class="line">orinSubject.onNext(<span class="number">1</span>)</span><br><span class="line">orinSubject.onNext(<span class="number">2</span>)</span><br><span class="line">refreSubject.onNext(<span class="number">10</span>)</span><br><span class="line">orinSubject.onNext(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p><span id="1.9">⑨skip</span></p><h2 id="⑨skip"><a href="#⑨skip" class="headerlink" title="⑨skip"></a>⑨skip</h2><blockquote><p>取消前几个事件</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">   </span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>, <span class="string">"🐸"</span>, <span class="string">"🐷"</span>, <span class="string">"🐵"</span>)</span><br><span class="line">    .skip(<span class="number">2</span>)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> 🐶</span><br><span class="line"> 🐸</span><br><span class="line"> 🐷</span><br><span class="line"> 🐵</span><br></pre></td></tr></table></figure><blockquote><p>从Observable序列的元素跳过指定个数</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="type">Observable</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">          .skip(<span class="number">2</span>)</span><br><span class="line">          .subscribe(onNext: &#123;<span class="built_in">print</span>($<span class="number">0</span>)&#125;)</span><br><span class="line">          .disposed(by: disposeBag)</span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p><span id="1.10">⑩skipWhile</span></p><h2 id="⑩-skipWhile"><a href="#⑩-skipWhile" class="headerlink" title="⑩ skipWhile"></a>⑩ skipWhile</h2><blockquote><p>满足条件的事件消息都取消</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">    .skipWhile &#123; $<span class="number">0</span> &lt; <span class="number">4</span> &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><blockquote><p>跳过满足条件的事件，只要遇见不满足条件的事件，则该事件以及之后的事件（不管是否满足条件）都会发出</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()    </span><br><span class="line"><span class="type">Observable</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">          .skipWhile&#123;$<span class="number">0</span> &lt; <span class="number">3</span>&#125;</span><br><span class="line">          .subscribe(onNext: &#123;<span class="built_in">print</span>($<span class="number">0</span>)&#125;)</span><br><span class="line">          .disposed(by: disposeBag)</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p><span id="1.11">⑪skipWhileWithIndex</span></p><h2 id="⑪skipWhileWithIndex"><a href="#⑪skipWhileWithIndex" class="headerlink" title="⑪skipWhileWithIndex"></a>⑪skipWhileWithIndex</h2><blockquote><p>满足条件的都被取消，传入的闭包同skipWhile有点区别而已</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>, <span class="string">"🐸"</span>, <span class="string">"🐷"</span>, <span class="string">"🐵"</span>)</span><br><span class="line">    .skipWhileWithIndex &#123; element, index <span class="keyword">in</span></span><br><span class="line">        index &lt; <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><blockquote><p>跳过索引满足条件的事件</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="type">Observable</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>).skipWhileWithIndex(&#123; (element, index) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">        index &lt; <span class="number">3</span></span><br><span class="line">    &#125;).subscribe(onNext: &#123;<span class="built_in">print</span>($<span class="number">0</span>)&#125;).disposed(by: disposeBag)</span><br><span class="line">  <span class="comment">//打印结果:</span></span><br><span class="line">  <span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p><span id="1.12">⑫skipUntil</span></p><h2 id="⑫skipUntil"><a href="#⑫skipUntil" class="headerlink" title="⑫skipUntil"></a>⑫skipUntil</h2><blockquote><p>直到某个sequence发出了事件消息，才开始接收当前sequence发出的事件消息</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">   </span><br><span class="line"><span class="keyword">let</span> sourceSequence = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> referenceSequence = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    </span><br><span class="line">sourceSequence</span><br><span class="line">    .skipUntil(referenceSequence)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line">    </span><br><span class="line">sourceSequence.onNext(<span class="string">"🐱"</span>)</span><br><span class="line">sourceSequence.onNext(<span class="string">"🐰"</span>)</span><br><span class="line">sourceSequence.onNext(<span class="string">"🐶"</span>)</span><br><span class="line">    </span><br><span class="line">referenceSequence.onNext(<span class="string">"🔴"</span>)</span><br><span class="line">    </span><br><span class="line">sourceSequence.onNext(<span class="string">"🐸"</span>)</span><br><span class="line">sourceSequence.onNext(<span class="string">"🐷"</span>)</span><br><span class="line">sourceSequence.onNext(<span class="string">"🐵"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>跳过另一个Observable序列发出事件之前的所有事件<br>与takeUntil相反。</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">let</span> oriSubject = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">  <span class="keyword">let</span> refreSubject = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">   </span><br><span class="line">oriSubject.skipUntil(refreSubject)</span><br><span class="line">          .subscribe(onNext: &#123;<span class="built_in">print</span>($<span class="number">0</span>)&#125;)</span><br><span class="line">          .disposed(by: disposeBag)</span><br><span class="line">    </span><br><span class="line">oriSubject.onNext(<span class="number">1</span>)</span><br><span class="line">oriSubject.onNext(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">refreSubject.onNext(<span class="number">10</span>)</span><br><span class="line">oriSubject.onNext(<span class="number">3</span>)</span><br><span class="line">oriSubject.onNext(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果:</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> RxSwift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-Filtering Observables过滤操作符-07-02</title>
      <link href="/2017/12/19/Swift/RxSwift/Grammar/07-02-%E6%93%8D%E4%BD%9C%E7%AC%A6-%E8%BF%87%E6%BB%A4%E6%93%8D/"/>
      <url>/2017/12/19/Swift/RxSwift/Grammar/07-02-%E6%93%8D%E4%BD%9C%E7%AC%A6-%E8%BF%87%E6%BB%A4%E6%93%8D/</url>
      <content type="html"><![CDATA[<ul><li><a href="#①filter">①filter</a></li><li><a href="#②distinctUntilChanged">②distinctUntilChanged</a></li><li><a href="#③elementAt">③elementAt</a></li><li><a href="#④single]">④single</a></li><li><a href="#⑤take">⑤take</a></li><li><a href="#⑥takeLast">⑥takeLast</a></li><li><a href="#⑦ignoreElements">⑦ignoreElements</a></li><li><a href="#⑧skip">⑧skip</a></li><li><a href="#⑨Sample">⑨Sample</a></li><li><a href="#⑩Sample">⑩Sample</a></li></ul><h1 id="变换操作"><a href="#变换操作" class="headerlink" title="变换操作"></a>变换操作</h1><blockquote><p>过滤操作指的是从源 Observable 中选择特定的数据发送</p></blockquote><p><span id="①filter">①filter</span></p><h1 id="①filter"><a href="#①filter" class="headerlink" title="①filter"></a>①filter</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>该操作符就是用来过滤掉某些不符合要求的事件<br>过滤掉某些不符合要求的事件<br>在Observable序列中只发出满足过滤条件的事件</p></blockquote><h2 id="使用样例1"><a href="#使用样例1" class="headerlink" title="使用样例1"></a>使用样例1</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>.of(</span><br><span class="line">    <span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>,</span><br><span class="line">    <span class="string">"🐸"</span>, <span class="string">"🐱"</span>, <span class="string">"🐰"</span>,</span><br><span class="line">    <span class="string">"🐹"</span>, <span class="string">"🐸"</span>, <span class="string">"🐱"</span>)</span><br><span class="line">    .<span class="built_in">filter</span> &#123;</span><br><span class="line">        $<span class="number">0</span> == <span class="string">"🐱"</span></span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line"><span class="comment">///</span></span><br><span class="line">🐱</span><br><span class="line">🐱</span><br><span class="line">🐱</span><br></pre></td></tr></table></figure><h2 id="使用样例2"><a href="#使用样例2" class="headerlink" title="使用样例2"></a>使用样例2</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.of(<span class="number">2</span>, <span class="number">30</span>, <span class="number">22</span>, <span class="number">5</span>, <span class="number">60</span>, <span class="number">3</span>, <span class="number">40</span> ,<span class="number">9</span>)</span><br><span class="line">    .<span class="built_in">filter</span> &#123;</span><br><span class="line">        $<span class="number">0</span> &gt; <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//print</span></span><br><span class="line"> <span class="number">30</span></span><br><span class="line"> <span class="number">22</span></span><br><span class="line"> <span class="number">60</span></span><br><span class="line"> <span class="number">40</span></span><br></pre></td></tr></table></figure><p><span id="②distinctUntilChanged">②distinctUntilChanged</span></p><h1 id="②distinctUntilChanged"><a href="#②distinctUntilChanged" class="headerlink" title="②distinctUntilChanged"></a>②distinctUntilChanged</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>过滤连续发出的相同事件(<strong>连续重复</strong>的事件)<br>distinctUntilChanged就是当下一个事件与前一个事件是不同事件的事件才进行处理操作</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"🐱"</span>, <span class="string">"🐷"</span>, <span class="string">"🐱"</span>, <span class="string">"🐱"</span>, <span class="string">"🐱"</span>, <span class="string">"🐵"</span>, <span class="string">"🐱"</span>)</span><br><span class="line">    .distinctUntilChanged()</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line">🐱</span><br><span class="line">🐷</span><br><span class="line">🐱</span><br><span class="line">🐵</span><br><span class="line">🐱</span><br></pre></td></tr></table></figure><p><span id="③elementAt">③elementAt</span></p><h1 id="③elementAt"><a href="#③elementAt" class="headerlink" title="③elementAt"></a>③elementAt</h1><h2 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>只处理在指定位置的事件</p></blockquote><h2 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>, <span class="string">"🐸"</span>, <span class="string">"🐷"</span>, <span class="string">"🐵"</span>)</span><br><span class="line">    .elementAt(<span class="number">3</span>)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">🐸</span><br></pre></td></tr></table></figure><p><span id="④single">④single</span></p><h1 id="④single"><a href="#④single" class="headerlink" title="④single"></a>④single</h1><h2 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>限制只发送一次事件，或者满足条件的第一个事件。<br>如果存在有多个事件或者没有事件都会发出一个 error 事件。<br>如果只有一个事件，则不会发出 error 事件</p></blockquote><h2 id="使用样例-1"><a href="#使用样例-1" class="headerlink" title="使用样例"></a>使用样例</h2><blockquote><p>用法一：检测Observable序列是否发射一个元素。如果发射多个，会报错</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// error:Sequence contains more than one element</span></span><br><span class="line"><span class="comment">// Observable.of(1,2,3).single().subscribe(onNext: &#123;print($0)&#125;).disposed(by: disposeBag)</span></span><br><span class="line"></span><br><span class="line"><span class="type">Observable</span>.of(<span class="number">1</span>)</span><br><span class="line">          .single()</span><br><span class="line">          .subscribe(</span><br><span class="line">                     onNext: &#123;<span class="built_in">print</span>($<span class="number">0</span>)&#125;</span><br><span class="line">                    )</span><br><span class="line">          .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><blockquote><p>用法二:检测Observable序列发射的元素里面是否包含多个指定的元素，如果有多个或者没有，会报错。</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>, <span class="string">"🐸"</span>, <span class="string">"🐷"</span>, <span class="string">"🐵"</span>)</span><br><span class="line">    .single &#123; $<span class="number">0</span> == <span class="string">"🐸"</span> &#125;</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>, <span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>)</span><br><span class="line">    .single &#123; $<span class="number">0</span> == <span class="string">"🐒"</span> &#125;</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>, <span class="string">"🐶"</span>,<span class="string">"🐸"</span>)</span><br><span class="line">    .single &#123; $<span class="number">0</span> == <span class="string">"🐶"</span> &#125;</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//打印结果</span></span><br><span class="line">next(🐸)</span><br><span class="line">completed</span><br><span class="line">error(<span class="type">Sequence</span> doesn't contain any elements.)</span><br><span class="line">next(🐶)</span><br><span class="line">error(<span class="type">Sequence</span> <span class="built_in">contains</span> more than one element.)</span><br></pre></td></tr></table></figure><blockquote><p>出在sequence只发出一次的事件，如果超过一个就会发出error错误</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.of(<span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>, <span class="string">"🐸"</span>, <span class="string">"🐷"</span>, <span class="string">"🐵"</span>)</span><br><span class="line"> .single()</span><br><span class="line"> .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line"> .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  🐱  <span class="comment">//单一信号超过了一个</span></span><br><span class="line"><span class="type">Received</span> unhandled error: /<span class="keyword">var</span>/folders/hz/v15ld5mj0nqf83d21j13y0tw0000gn/<span class="type">T</span>/./lldb/<span class="number">7229</span>/playground107.swift:<span class="number">69</span>:__lldb_expr_107 -&gt; <span class="type">Sequence</span> <span class="built_in">contains</span> more than one element.</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.of(<span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>, <span class="string">"🐸"</span>, <span class="string">"🐷"</span>, <span class="string">"🐵"</span>)</span><br><span class="line"> .single &#123; $<span class="number">0</span> == <span class="string">"🐸"</span> &#125;      <span class="comment">//青蛙只有一个，completed</span></span><br><span class="line"> .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line"> .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.of(<span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>, <span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>)</span><br><span class="line"> .single &#123; $<span class="number">0</span> == <span class="string">"🐰"</span> &#125; <span class="comment">//兔子有两个，会发出error</span></span><br><span class="line"> .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line"> .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.of(<span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>, <span class="string">"🐸"</span>, <span class="string">"🐷"</span>, <span class="string">"🐵"</span>)</span><br><span class="line"> .single &#123; $<span class="number">0</span> == <span class="string">"🔵"</span> &#125; <span class="comment">//没有蓝色球，会发出error</span></span><br><span class="line"> .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line"> .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><p><span id="⑤take">⑤take</span></p><h1 id="⑤take"><a href="#⑤take" class="headerlink" title="⑤take"></a>⑤take</h1><h2 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>该方法实现仅发送 Observable 序列中的前 n 个事件，在满足数量之后会自动 .completed</p></blockquote><p>##使用样例</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>, <span class="string">"🐸"</span>, <span class="string">"🐷"</span>, <span class="string">"🐵"</span>)</span><br><span class="line">    .take(<span class="number">3</span>)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">🐱</span><br><span class="line">🐰</span><br><span class="line">🐶</span><br></pre></td></tr></table></figure><blockquote><p>从Observable序列开始点起只处理前几个事件</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">         .take(<span class="number">2</span>)</span><br><span class="line">         .subscribe(</span><br><span class="line">                    onNext: &#123;<span class="built_in">print</span>($<span class="number">0</span>)&#125;</span><br><span class="line">                   )</span><br><span class="line">         .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果:</span></span><br><span class="line"> <span class="number">1</span></span><br><span class="line"> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><span id="⑥takeLast">⑥takeLast</span></p><h1 id="⑥takeLast"><a href="#⑥takeLast" class="headerlink" title="⑥takeLast"></a>⑥takeLast</h1><h2 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>只处理后几个事件信号<br>与take相反，从Observable序列的结束位置起，只处理前几个事件</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"🐱"</span>, <span class="string">"🐰"</span>, <span class="string">"🐶"</span>, <span class="string">"🐸"</span>, <span class="string">"🐷"</span>, <span class="string">"🐵"</span>)</span><br><span class="line">    .takeLast(<span class="number">3</span>)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">🐸</span><br><span class="line">🐷</span><br><span class="line">🐵</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()    </span><br><span class="line"><span class="type">Observable</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">          .takeLast(<span class="number">2</span>)</span><br><span class="line">          .subscribe(onNext: &#123;<span class="built_in">print</span>($<span class="number">0</span>)&#125;)</span><br><span class="line">          .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><span id="⑦ignoreElementst">⑦ignoreElements</span></p><h1 id="⑦ignoreElements"><a href="#⑦ignoreElements" class="headerlink" title="⑦ignoreElements"></a>⑦ignoreElements</h1><h2 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li>该操作符可以忽略掉所有的元素，只发出 error 或 completed 事件。<ul><li>如果我们并不关心 Observable 的任何元素，只想知道 Observable 在什么时候终止，那就可以使用 ignoreElements 操作符</li></ul></li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"> </span><br><span class="line"><span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    .ignoreElements()</span><br><span class="line">    .subscribe&#123;</span><br><span class="line">        <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//print</span></span><br><span class="line">completed</span><br></pre></td></tr></table></figure><p><span id="⑧skip">⑧skip</span></p><h1 id="⑧skip"><a href="#⑧skip" class="headerlink" title="⑧skip"></a>⑧skip</h1><h2 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>该方法用于跳过源 Observable 序列发出的前 n 个事件</p></blockquote><h2 id="使用样例-2"><a href="#使用样例-2" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"> </span><br><span class="line"><span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    .skip(<span class="number">2</span>)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//print</span></span><br><span class="line">  <span class="number">3</span></span><br><span class="line">  <span class="number">4</span></span><br></pre></td></tr></table></figure><p><span id="⑨Sample">⑨Sample</span></p><h1 id="⑨Sample"><a href="#⑨Sample" class="headerlink" title="⑨Sample"></a>⑨Sample</h1><h2 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li>Sample 除了订阅源 Observable 外，还可以监视另外一个 Observable， 即 notifier 。</li><li>每当收到 notifier 事件，就会从源序列取一个最新的事件并发送。而如果两次 notifier 事件之间没有源序列的事件，则不发送值</li></ul><h2 id="使用样例-3"><a href="#使用样例-3" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> source = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> notifier = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"> </span><br><span class="line">source</span><br><span class="line">    .sample(notifier)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"> </span><br><span class="line">source.onNext(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//让源序列接收接收消息</span></span><br><span class="line">notifier.onNext(<span class="string">"A"</span>)</span><br><span class="line"> </span><br><span class="line">source.onNext(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//让源序列接收接收消息</span></span><br><span class="line">notifier.onNext(<span class="string">"B"</span>)</span><br><span class="line">notifier.onNext(<span class="string">"C"</span>)</span><br><span class="line"> </span><br><span class="line">source.onNext(<span class="number">3</span>)</span><br><span class="line">source.onNext(<span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//让源序列接收接收消息</span></span><br><span class="line">notifier.onNext(<span class="string">"D"</span>)</span><br><span class="line"> </span><br><span class="line">source.onNext(<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//让源序列接收接收消息</span></span><br><span class="line">notifier.onCompleted()</span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p><span id="⑩debounce"></span></p><h1 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h1><p>debounce和throttle其实是一样的，队列中的元素如果和下一个元素的间隔小于了指定的时间间隔，那么这个元素将被过滤掉</p><h2 id="基本介绍-9"><a href="#基本介绍-9" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li>debounce 操作符可以用来过滤掉高频产生的元素，它只会发出这种元素：该元素产生后，一段时间内没有新元素产生。</li><li>换句话说就是，队列中的元素如果和下一个元素的间隔小于了指定的时间间隔，那么这个元素将被过滤掉。</li><li>debounce 常用在用户输入的时候，不需要每个字母敲进去都发送一个事件，而是稍等一下取最后一个事件</li></ul><h2 id="使用样例-4"><a href="#使用样例-4" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> RxCocoa</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//定义好每个事件里的值以及发送的时间</span></span><br><span class="line">        <span class="keyword">let</span> times = [</span><br><span class="line">            [ <span class="string">"value"</span>: <span class="number">1</span>, <span class="string">"time"</span>: <span class="number">0.1</span> ],</span><br><span class="line">            [ <span class="string">"value"</span>: <span class="number">2</span>, <span class="string">"time"</span>: <span class="number">1.1</span> ],</span><br><span class="line">            [ <span class="string">"value"</span>: <span class="number">3</span>, <span class="string">"time"</span>: <span class="number">1.2</span> ],</span><br><span class="line">            [ <span class="string">"value"</span>: <span class="number">4</span>, <span class="string">"time"</span>: <span class="number">1.2</span> ],</span><br><span class="line">            [ <span class="string">"value"</span>: <span class="number">5</span>, <span class="string">"time"</span>: <span class="number">1.4</span> ],</span><br><span class="line">            [ <span class="string">"value"</span>: <span class="number">6</span>, <span class="string">"time"</span>: <span class="number">2.1</span> ]</span><br><span class="line">        ]</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//生成对应的 Observable 序列并订阅</span></span><br><span class="line">        <span class="type">Observable</span>.from(times)</span><br><span class="line">            .flatMap &#123; item <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">return</span> <span class="type">Observable</span>.of(<span class="type">Int</span>(item[<span class="string">"value"</span>]!))</span><br><span class="line">                    .delaySubscription(<span class="type">Double</span>(item[<span class="string">"time"</span>]!),</span><br><span class="line">                                       scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">            &#125;</span><br><span class="line">            .debounce(<span class="number">0.5</span>, scheduler: <span class="type">MainScheduler</span>.instance) <span class="comment">//只发出与下一个间隔超过0.5秒的元素</span></span><br><span class="line">            .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/3bdb246881d4" target="_blank" rel="noopener">https://www.jianshu.com/p/3bdb246881d4</a></p>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-RxSwift-线程</title>
      <link href="/2017/12/19/Swift/RxSwift/Grammar/%E7%BA%BF%E7%A8%8B/"/>
      <url>/2017/12/19/Swift/RxSwift/Grammar/%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>#线程</p><h2 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h2><blockquote><p>RxSwift 中切换线程</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">sequence1</span><br><span class="line">.observeOn(backgroundScheduler) <span class="comment">// 切换到后台线程</span></span><br><span class="line">.<span class="built_in">map</span> &#123; n <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"在 background scheduler 执行"</span>)</span><br><span class="line">&#125;</span><br><span class="line">.observeOn(<span class="type">MainScheduler</span>.instance) <span class="comment">// 切换到主线程</span></span><br><span class="line">.<span class="built_in">map</span> &#123; n <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"在 main scheduler"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>调用一下 observeOn 就切换到我们想要的线程了<br>当前的线程切换支持 GCD 和 NSOperation<br>在线程这部分主要有两个操作符：observeOn 和 subscribeOn ，常用的还是 observeOn</p></blockquote><ul><li>调用 observeOn 指定接下来的操作在哪个线程</li><li>调用 subscribeOn 决定订阅者的操作执行在哪个线程</li></ul><blockquote><p>当然，如果我们没有明确调用这两个操作，后面的操作都是在当前线程执行的</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">extension</span> <span class="title">ObservableType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">observeOn</span><span class="params">(scheduler: ImmediateSchedulerType)</span></span> -&gt; <span class="type">RxSwift</span>.<span class="type">Observable</span>&lt;<span class="type">Self</span>.<span class="type">E</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribeOn</span><span class="params">(scheduler: ImmediateSchedulerType)</span></span> -&gt; <span class="type">RxSwift</span>.<span class="type">Observable</span>&lt;<span class="type">Self</span>.<span class="type">E</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>两个方法的声明几乎都是一样的，我们只需要传入一个满足 ImmediateSchedulerType 协议的东西</p></blockquote><h2 id="MainScheduler-串行"><a href="#MainScheduler-串行" class="headerlink" title="MainScheduler 串行"></a>MainScheduler 串行</h2><blockquote><p>在 Rx 中我们已经有主线程切换</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.observeOn(<span class="type">MainScheduler</span>.instance)<span class="comment">//切换到了主线程</span></span><br></pre></td></tr></table></figure><blockquote><p>MainScheduler 有一个很有用的功能</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">ensureExecutingOnScheduler</span>()</span></span><br></pre></td></tr></table></figure><blockquote><p>可以在需要保证代码一定执行在主线程的地方调用 MainScheduler.ensureExecutingOnScheduler()<br>特别是在线程切换来切换去的情况下，或者是调用其他的库，我们不确定当前是否在执行在主线程<br>毕竟 UI 的更新还是要在主线程执行的</p></blockquote><h2 id="SerialDispatchQueueScheduler-串行"><a href="#SerialDispatchQueueScheduler-串行" class="headerlink" title="SerialDispatchQueueScheduler 串行"></a>SerialDispatchQueueScheduler 串行</h2><ul><li>SerialDispatchQueueScheduler ，这个就是一个串行的调度器，上面的 MainScheduler 就是继承的这个</li></ul><blockquote><p>DispatchQueueSchedulerQOS<br>iOS 8 新增加了 QOS ，分别有以下五种等级：</p></blockquote><ul><li>QOS_CLASS_USER_INTERACTIVE</li><li>QOS_CLASS_USER_INITIATED</li><li>QOS_CLASS_DEFAULT</li><li>QOS_CLASS_UTILITY</li><li>QOS_CLASS_BACKGROUND</li></ul><blockquote><p>在 Rx 中，我们用 enum 创建了 DispatchQueueSchedulerQOS ：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">DispatchQueueSchedulerQOS</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">UserInteractive</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">UserInitiated</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Default</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Utility</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Background</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>和上面的等级是一一对应的<br>用 QOS 创建一个 DispatchQueueSchedulerQOS 非常方便</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(globalConcurrentQueueQOS: <span class="type">DispatchQueueSchedulerQOS</span>, </span><br><span class="line">internalSerialQueueName: <span class="type">String</span> = <span class="string">"rx.global_dispatch_queue.serial"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>用一个初始化就 OK ：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">SerialDispatchQueueScheduler</span>(globalConcurrentQueueQOS: .<span class="type">Background</span>)</span><br></pre></td></tr></table></figure><ul><li>更推荐你使用已有的 QOS 管理多线程问题，毕竟这是一个线程等级更明确的方案。即便是创建自己的 GCD 我也建议直接使用 SerialDispatchQueueScheduler ，毕竟自己再去实现那些协议很麻烦不是吗</li></ul><blockquote><p>可以通过以下两种方式创建自己的 GCD ：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(internalSerialQueueName: <span class="type">String</span>, serialQueueConfiguration: ((dispatch_queue_t) -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(queue: dispatch_queue_t, internalSerialQueueName: <span class="type">String</span>)</span><br></pre></td></tr></table></figure><blockquote><p>MainScheduler 是继承 SerialDispatchQueueScheduler 的</p></blockquote><h2 id="ConcurrentDispatchQueueScheduler-并行"><a href="#ConcurrentDispatchQueueScheduler-并行" class="headerlink" title="ConcurrentDispatchQueueScheduler 并行"></a>ConcurrentDispatchQueueScheduler 并行</h2><blockquote><p>同样我们还有一个并行的 Scheduler ：ConcurrentDispatchQueueScheduler<br>API 的使用和 SerialDispatchQueueScheduler 是一样的</p></blockquote><h2 id="OperationQueueScheduler-并行"><a href="#OperationQueueScheduler-并行" class="headerlink" title="OperationQueueScheduler 并行"></a>OperationQueueScheduler 并行</h2><blockquote><p>使用 NSOperationQueue 最大的好处就是我们可以很方便的定制最大并发线程数量，即设置 maxConcurrentOperationCount<br>创建方法也很简单，只需要传入一个 NSOperationQueue</p></blockquote><p>难懂啊</p><p><a href="http://t.swift.gg/t/rxswift-course" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-RxSwift-Transforming Observables</title>
      <link href="/2017/12/19/Swift/RxSwift/Grammar/07-01-%E6%93%8D%E4%BD%9C%E7%AC%A6-%E8%BD%AC%E6%8D%A2/"/>
      <url>/2017/12/19/Swift/RxSwift/Grammar/07-01-%E6%93%8D%E4%BD%9C%E7%AC%A6-%E8%BD%AC%E6%8D%A2/</url>
      <content type="html"><![CDATA[<ul><li><a href="#①map">①map</a></li><li><a href="#②flatMap">②flatMap</a></li><li><a href="#③flatMapLatest">③flatMapLatest</a></li><li><a href="#④scan]">④scan</a></li><li><a href="#⑤groupBy">⑤groupBy</a></li></ul><h1 id="变换操作"><a href="#变换操作" class="headerlink" title="变换操作"></a>变换操作</h1><p><span id="①map">①map </span></p><h1 id="①map"><a href="#①map" class="headerlink" title="①map"></a>①map</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>通过使用一个闭包函数将原来的Observable序列sequence转换为一个新的Observable序列sequence</p></blockquote><p><img src="http://ot0mms4k8.bkt.clouddn.com/map-001.png" alt="map"></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="type">Observable</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">.<span class="built_in">map</span>(&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">10</span> * $<span class="number">0</span></span><br><span class="line">     &#125;)</span><br><span class="line">.subscribe(&#123;<span class="built_in">print</span>($<span class="number">0</span>)&#125;)</span><br><span class="line">.disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line">next(<span class="number">10</span>)</span><br><span class="line">next(<span class="number">20</span>)</span><br><span class="line">next(<span class="number">30</span>)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure><p><span id="②flatMap">②flatMap </span></p><p>#②flatMap</p><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>将一个sequence转换为一个sequences，当你接收一个sequence的事件，你还想接收其他sequence发出的事件的话可以使用flatMap，她会将每一个sequence事件进行处理以后，然后再以一个sequence形式发出事件<br>而且flatMap有一次拆包动作<br>将一个Observable序列转换为另一个Observable序列，并且合并两个Observable序列。会按时间顺序接收两个序列发出的元素</p></blockquote><ul><li>map 在做转换的时候容易出现“升维”的情况。即转变之后，从一个序列变成了一个序列的序列。</li><li>而 flatMap 操作符会对源 Observable 的每一个元素应用一个转换方法，将他们转换成 Observables。 然后将这些 Observables 的元素合并之后再发送出来。即又将其 “拍扁”（降维）成一个 Observable 序列。</li><li>这个操作符是非常有用的。比如当 Observable 的元素本生拥有其他的 Observable 时，我们可以将所有子 Observables 的元素发送出来</li></ul><p><img src="" alt="flatMap"></p><h2 id="使用样例1"><a href="#使用样例1" class="headerlink" title="使用样例1"></a>使用样例1</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">sttuct <span class="type">Player</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> score: <span class="type">Variable</span>&lt;<span class="type">Int</span>&gt; <span class="comment">//里面是一个Variable</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> 👦🏻 = <span class="type">Player</span>(score: <span class="type">Variable</span>(<span class="number">80</span>))      </span><br><span class="line"><span class="keyword">let</span> 👧🏼 = <span class="type">Player</span>(score: <span class="type">Variable</span>(<span class="number">90</span>))</span><br><span class="line"><span class="keyword">let</span> 😂 = <span class="type">Player</span>(score: <span class="type">Variable</span>(<span class="number">550</span>))</span><br><span class="line"><span class="keyword">let</span> player = <span class="type">Variable</span>(👦🏻)  <span class="comment">//将player转为Variable</span></span><br><span class="line">player.asObservable()       <span class="comment">//拆箱转成可被监听的sequence</span></span><br><span class="line">     .flatMap &#123;</span><br><span class="line">              $<span class="number">0</span>.score.asObservable() </span><br><span class="line">             &#125; <span class="comment">// flatMap有一次拆包动作，$0本来应该是一个BehaviorSubject类型，但是直接访问了score。所以猜想flatMap对behaviorSubject进行了onNext拆包取数据</span></span><br><span class="line">    .subscribe(onNext: &#123; </span><br><span class="line">                <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">               &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line">    👦🏻.score.value = <span class="number">85</span></span><br><span class="line">player.value = 👧🏼 <span class="comment">//更换了value，相当于又添加了一个sequence，两个sequence都可以接收</span></span><br><span class="line">👦🏻.score.value = <span class="number">95</span></span><br><span class="line">👦🏻.score.value = <span class="number">222</span></span><br><span class="line">player.value = 😂</span><br><span class="line">    </span><br><span class="line">👧🏼.score.value = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="number">80</span></span><br><span class="line"><span class="number">85</span></span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="number">95</span></span><br><span class="line"><span class="number">222</span></span><br><span class="line"><span class="number">550</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="使用样例2"><a href="#使用样例2" class="headerlink" title="使用样例2"></a>使用样例2</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> subject1 = <span class="type">BehaviorSubject</span>(value: <span class="string">"A"</span>)</span><br><span class="line"><span class="keyword">let</span> subject2 = <span class="type">BehaviorSubject</span>(value: <span class="string">"1"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> variable = <span class="type">Variable</span>(subject1)</span><br><span class="line"> </span><br><span class="line">variable.asObservable()</span><br><span class="line">    .flatMap &#123; $<span class="number">0</span> &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"> </span><br><span class="line">subject1.onNext(<span class="string">"B"</span>)</span><br><span class="line">variable.value = subject2</span><br><span class="line">subject2.onNext(<span class="string">"2"</span>)</span><br><span class="line">subject1.onNext(<span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">A</span></span><br><span class="line"><span class="type">B</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="type">C</span></span><br></pre></td></tr></table></figure><p><span id="③flatMapLatest">③flatMapLatest </span></p><h1 id="③flatMapLatest"><a href="#③flatMapLatest" class="headerlink" title="③flatMapLatest"></a>③flatMapLatest</h1><h2 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>flatMapLatest只会接收最新的value事件，将上例改为flatMapLatest。结果为</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="number">80</span></span><br><span class="line"><span class="number">85</span></span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="number">550</span></span><br></pre></td></tr></table></figure><h2 id="将上例中的-flatMap-改为-flatMapLatest"><a href="#将上例中的-flatMap-改为-flatMapLatest" class="headerlink" title="将上例中的 flatMap 改为 flatMapLatest"></a>将上例中的 flatMap 改为 flatMapLatest</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> subject1 = <span class="type">BehaviorSubject</span>(value: <span class="string">"A"</span>)</span><br><span class="line"><span class="keyword">let</span> subject2 = <span class="type">BehaviorSubject</span>(value: <span class="string">"1"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> variable = <span class="type">Variable</span>(subject1)</span><br><span class="line"> </span><br><span class="line">variable.asObservable()</span><br><span class="line">    .flatMapLatest &#123; $<span class="number">0</span> &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"> </span><br><span class="line">subject1.onNext(<span class="string">"B"</span>)</span><br><span class="line">variable.value = subject2</span><br><span class="line">subject2.onNext(<span class="string">"2"</span>)</span><br><span class="line">subject1.onNext(<span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">A</span></span><br><span class="line"><span class="type">B</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p><span id="④scan">④scan </span></p><h1 id="④scan"><a href="#④scan" class="headerlink" title="④scan"></a>④scan</h1><h2 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>scan就是给一个初始化的数，然后不断的拿前一个结果和最新的值进行处理操作</p></blockquote><h2 id="使用样例1-1"><a href="#使用样例1-1" class="headerlink" title="使用样例1"></a>使用样例1</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="type">Observable</span>.of(<span class="number">10</span>,<span class="number">100</span>,<span class="number">1000</span>)</span><br><span class="line">         .scan(<span class="number">1</span>)&#123;aggregateValue, newValue <span class="keyword">in</span></span><br><span class="line">    aggregateValue + newValue&#125;</span><br><span class="line">         .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">         .addDisposableTo(disposeBag)</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">111</span></span><br><span class="line"><span class="number">1111</span></span><br></pre></td></tr></table></figure><h2 id="使用样例2-1"><a href="#使用样例2-1" class="headerlink" title="使用样例2"></a>使用样例2</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"> </span><br><span class="line"><span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    .scan(<span class="number">0</span>) &#123; acum, elem <span class="keyword">in</span></span><br><span class="line">        acum + elem</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"><span class="comment">//print</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure><h1 id="⑤groupBy"><a href="#⑤groupBy" class="headerlink" title="⑤groupBy"></a>⑤groupBy</h1><h2 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>groupBy 操作符将源 Observable 分解为多个子 Observable，然后将这些子 Observable 发送出来<br>也就是说该操作符会将元素通过某个键进行分组，然后将分组后的元素序列以 Observable 的形态发送出来</p></blockquote><h2 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//将奇数偶数分成两组</span></span><br><span class="line"><span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.of(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    .groupBy(keySelector: &#123; (element) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> element % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">"偶数"</span> : <span class="string">"基数"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">switch</span> event &#123;</span><br><span class="line">        <span class="keyword">case</span> .next(<span class="keyword">let</span> group):</span><br><span class="line">            group.asObservable().subscribe(&#123; (event) <span class="keyword">in</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"key：<span class="subst">\(group.key)</span>    event：<span class="subst">\(event)</span>"</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">.disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line">key: 偶数 event: next(<span class="number">0</span>)</span><br><span class="line">key: 奇数 event: next(<span class="number">1</span>)</span><br><span class="line">key: 偶数 event: next(<span class="number">2</span>)</span><br><span class="line">key: 奇数 event: next(<span class="number">3</span>)</span><br><span class="line">key: 偶数 event: next(<span class="number">4</span>)</span><br><span class="line">key: 奇数 event: next(<span class="number">5</span>)</span><br><span class="line">key: 偶数 event: completed</span><br><span class="line">key: 奇数 event: completed</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-RxSwift-进阶理解</title>
      <link href="/2017/12/18/Swift/RxSwift/Grammar/%E8%BF%9B%E9%98%B6%E7%90%86%E8%A7%A3/"/>
      <url>/2017/12/18/Swift/RxSwift/Grammar/%E8%BF%9B%E9%98%B6%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/431f645cb805" target="_blank" rel="noopener">https://www.jianshu.com/p/431f645cb805</a></p><h1 id="Disposing"><a href="#Disposing" class="headerlink" title="Disposing"></a>Disposing</h1><blockquote><p>当监听一个事件序列的时候，有消息事件来了，做某些事情<br>but,这个事件序列不再发出消息，监听也就没有存在价值，so,需要释放监听资源(内存资源释放)<br>不需要用某些变量时，把这些变量所占用的内存空间释放掉<br>释放某一个监听的时可手动调用释放方法，但是这个貌似一般不常用：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> subscription = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.interval(<span class="number">0.3</span>,</span><br><span class="line">                                            scheduler: <span class="type">SerialDispatchQueueScheduler</span>.<span class="keyword">init</span>(internalSerialQueueName: <span class="string">"test"</span>))<span class="comment">//关于scheduler，我们会在下面讲到</span></span><br><span class="line">                                  .observeOn(<span class="type">MainScheduler</span>.instance)  <span class="comment">//observeOn也会在下面讲到</span></span><br><span class="line">                                  .subscribe &#123; </span><br><span class="line">                                         event <span class="keyword">in</span></span><br><span class="line">                                             <span class="built_in">print</span>(event)</span><br><span class="line">                                     &#125;</span><br><span class="line">    </span><br><span class="line"><span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">2.0</span>)</span><br><span class="line">subscription.dispose()</span><br><span class="line"></span><br><span class="line"><span class="comment">//--</span></span><br><span class="line">next(<span class="number">0</span>)</span><br><span class="line">next(<span class="number">1</span>)</span><br><span class="line">next(<span class="number">2</span>)</span><br><span class="line">next(<span class="number">3</span>)</span><br><span class="line">next(<span class="number">4</span>)</span><br><span class="line">next(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><blockquote><p>创建了一个subscription监听，2s后不需要了，手动调用dispose()方法，释放监听资源，不再打印信息<br>subscription不伦是在哪个线程中监听，就算在主线程中调用的dispose()方法一样会销毁资源</p></blockquote><h1 id="Dispose-Bag"><a href="#Dispose-Bag" class="headerlink" title="Dispose Bag"></a>Dispose Bag</h1><blockquote><p>自动的方式<br>推荐使用，ARC方式相似，会自动去释放资源</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()   </span><br><span class="line"><span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.empty()</span><br><span class="line">  .subscribe &#123; </span><br><span class="line">       event <span class="keyword">in</span></span><br><span class="line">         <span class="built_in">print</span>(event)</span><br><span class="line">      &#125;</span><br><span class="line">               .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><blockquote><p>创建一个disposeBag来盛放需要管理的资源，然后把新建的监听都放进去，会在适当的时候销毁这些资源<br>如需要立即释放资源，只需要新建一个DisposeBag()，那么上一个DisposeBag就会被销毁</p></blockquote><h1 id="observeOn-和subscribeOn"><a href="#observeOn-和subscribeOn" class="headerlink" title="observeOn()和subscribeOn()"></a>observeOn()和subscribeOn()</h1><blockquote><p>subscribeOn()设置起点在哪个线程<br>observeOn()设置了后续工作在哪个线程</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">someObservable </span><br><span class="line"> .doOneThing() ①</span><br><span class="line"> .observeOn(<span class="type">MainRouteScheduler</span>.instance) ②</span><br><span class="line"> .subscribeOn(<span class="type">OtherScheduler</span>.instance) ③</span><br><span class="line"> .subscribeNext &#123; ④</span><br><span class="line"> ......</span><br><span class="line"> &#125;</span><br><span class="line"> .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><ul><li>① 所有动作都发生在当前的默认线程</li><li>② observeOn转换线程到主线程，下面所有的操作都是在主线程中</li><li>③ subscribeOn规定动作一开始不是发生在默认线程了，而是在OtherScheduler了</li><li>④ 如果我们之前没有调用observeOn，那么这边会在OtherScheduler发生，但是我们前面调用了observeOn，所以这个动作会在主线程中调用</li><li>subscribeOn只是影响事件链开始默认的线程，而observeOn规定了下一步动作发生在哪个线程中</li></ul><h1 id="shareReplay"><a href="#shareReplay" class="headerlink" title="shareReplay"></a>shareReplay</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> testReplay = <span class="type">Observable</span>.just(<span class="string">"😂"</span>)</span><br><span class="line">                           .<span class="built_in">map</span> &#123; </span><br><span class="line">                               <span class="built_in">print</span>($<span class="number">0</span>) </span><br><span class="line">                            &#125;</span><br><span class="line">    </span><br><span class="line">testReplay.subscribe &#123; </span><br><span class="line">                      event <span class="keyword">in</span></span><br><span class="line">                        <span class="built_in">print</span>(event)</span><br><span class="line">                   &#125;</span><br><span class="line">          .addDisposableTo(disposeBag)</span><br><span class="line">    </span><br><span class="line">testReplay.subscribe &#123; </span><br><span class="line">                      event <span class="keyword">in</span></span><br><span class="line">                       <span class="built_in">print</span>(event)</span><br><span class="line">                      &#125;</span><br><span class="line">         .addDisposableTo(disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">///---</span></span><br><span class="line">   😂</span><br><span class="line">next(())</span><br><span class="line">completed</span><br><span class="line">😂</span><br><span class="line">next(())</span><br><span class="line">completed</span><br></pre></td></tr></table></figure><blockquote><p>map函数执行了两遍，但是有些时候不需要map函数里的东西执行两遍<br>比如map函数里面如果执行的是网络请求，只需要一次请求结果供大家使用就行了，多余的请求没啥用，浪费时间<br>所以这时候就需要shareReplay(1)了。这里面的数字一般都是1，只执行一次。你可以改为2，3看看结果有啥不同哦</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> testReplay = <span class="type">Observable</span>.just(<span class="string">"😂"</span>)</span><br><span class="line">                           .<span class="built_in">map</span> &#123;  <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">                           .shareReplay(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">testReplay.subscribe &#123; </span><br><span class="line">                       event <span class="keyword">in</span></span><br><span class="line">                          <span class="built_in">print</span>(event)</span><br><span class="line">                     &#125;</span><br><span class="line">          .addDisposableTo(disposeBag)</span><br><span class="line">    </span><br><span class="line">testReplay.subscribe &#123;</span><br><span class="line">                        event <span class="keyword">in</span></span><br><span class="line">                         <span class="built_in">print</span>(event)</span><br><span class="line">                     &#125;</span><br><span class="line">         .addDisposableTo(disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">///--</span></span><br><span class="line">  😂 <span class="comment">//只执行了一次</span></span><br><span class="line">  next(())</span><br><span class="line">  completed</span><br><span class="line">  next(())</span><br><span class="line">  completed</span><br></pre></td></tr></table></figure><h1 id="自定义operator"><a href="#自定义operator" class="headerlink" title="自定义operator"></a>自定义operator</h1><blockquote><p>自定义操作符很简单，官方推荐尽量用标准的操作符，但是你也可以自定义自己的操作符，文档上说有两种方法，这里我们只说一下最常用的一种方法</p></blockquote><blockquote><p>自定义一个map操作符</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">extension</span> <span class="title">ObservableType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">myMap</span>&lt;R&gt;<span class="params">(transform: E -&gt; R)</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">R</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Observable</span>.create &#123; observer <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> subscription = <span class="keyword">self</span>.subscribe &#123; e <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">switch</span> e &#123;</span><br><span class="line">                    <span class="keyword">case</span> .next(<span class="keyword">let</span> value):</span><br><span class="line">                        <span class="keyword">let</span> result = transform(value)</span><br><span class="line">                        observer.on(.next(result))</span><br><span class="line">                    <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">                        observer.on(.error(error))</span><br><span class="line">                    <span class="keyword">case</span> .completed:</span><br><span class="line">                        observer.on(.completed)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">return</span> subscription</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参数是一个闭包，其中闭包参数是E类型返回值是R类型，map函数的返回值是一个Observable类型</p></blockquote><h1 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> results = query.rx</span><br><span class="line">                   .text</span><br><span class="line">                   .throttle(<span class="number">0.3</span>, scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">                   .flatMapLatest &#123; </span><br><span class="line">                      query <span class="keyword">in</span></span><br><span class="line">                        fetchAutoCompleteItems(query)</span><br><span class="line">                    &#125;</span><br><span class="line">results.<span class="built_in">map</span> &#123; <span class="string">"<span class="subst">\($<span class="number">0</span>.<span class="built_in">count</span>)</span>"</span> &#125;</span><br><span class="line">       .bindTo(resultCount.rx.text)</span><br><span class="line">       .addDisposableTo(disposeBag)</span><br><span class="line">results.bindTo(resultsTableView.rx</span><br><span class="line">                               .items(cellIdentifier: <span class="string">"Cell"</span>)) &#123; (<span class="number">_</span>, result, cell) <span class="keyword">in</span></span><br><span class="line">        cell.textLabel?.text = <span class="string">"<span class="subst">\(result)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><ul><li>首先创建一个可监听序列results，其中flatMapLatest怎么用我们下面讲</li><li>然后将results绑定到resultCount.rx.text上</li><li>将results绑定到resultsTableView上</li></ul><blockquote><p>上面程序会有下面几个异常情况</p></blockquote><ul><li>如果上面fetchAutoCompleteItems出错了，那么他绑定的UI将不再收到任何事件消息</li><li>如果上面fetchAutoCompleteItems是在后台某个线程中运行的，那么事件绑定也是发生在后台某个线程，这样更新UI的时候会造成crash</li><li>有两次绑定fetchAutoCompleteItems会执行两次</li></ul><blockquote><p>当然针对上面问题我们也有解决方案，我们可以使用神器shareReplay(1)保证不会执行两次，可以使用observeOn()保证后面所有操作在主线程完成</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> results = query.rx.text</span><br><span class="line">    .throttle(<span class="number">0.3</span>, scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">    .flatMapLatest &#123; query <span class="keyword">in</span></span><br><span class="line">        fetchAutoCompleteItems(query)</span><br><span class="line">            .observeOn(<span class="type">MainScheduler</span>.instance)</span><br><span class="line">            .catchErrorJustReturn([])           </span><br><span class="line">    &#125;</span><br><span class="line">    .shareReplay(<span class="number">1</span>)                             </span><br><span class="line">results</span><br><span class="line">    .<span class="built_in">map</span> &#123; <span class="string">"<span class="subst">\($<span class="number">0</span>.<span class="built_in">count</span>)</span>"</span> &#125;</span><br><span class="line">    .bindTo(resultCount.rx.text)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line">results</span><br><span class="line">    .bindTo(resultTableView.rx.items(cellIdentifier: <span class="string">"Cell"</span>)) &#123; (<span class="number">_</span>, result, cell) <span class="keyword">in</span></span><br><span class="line">        cell.textLabel?.text = <span class="string">"<span class="subst">\(result)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><blockquote><p>但是,也可以使用Driver</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> results = query.rx.text.asDriver()<span class="comment">//转换成一个Driver序列</span></span><br><span class="line">    .throttle(<span class="number">0.3</span>, scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">    .flatMapLatest &#123; query <span class="keyword">in</span></span><br><span class="line">        fetchAutoCompleteItems(query)</span><br><span class="line">            .asDriver(onErrorJustReturn: [])  <span class="comment">//当遇见错误需要返回什么</span></span><br><span class="line">    &#125;<span class="comment">//不需要添加shareReplay(1)</span></span><br><span class="line">results</span><br><span class="line">    .<span class="built_in">map</span> &#123; <span class="string">"<span class="subst">\($<span class="number">0</span>.<span class="built_in">count</span>)</span>"</span> &#125;</span><br><span class="line">    .drive(resultCount.rx.text)<span class="comment">//和bingTo()功能一样</span></span><br><span class="line">    .addDisposableTo(disposeBag) </span><br><span class="line">                                             </span><br><span class="line">results</span><br><span class="line">    .drive(resultTableView.rx.items(cellIdentifier: <span class="string">"Cell"</span>)) &#123; (<span class="number">_</span>, result, cell) <span class="keyword">in</span></span><br><span class="line">        cell.textLabel?.text = <span class="string">"<span class="subst">\(result)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><blockquote><p>drive方法只能在Driver序列中使用，Driver有以下特点：<br>① Driver序列不允许发出error<br>② Driver序列的监听只会在主线程中<br>所以Driver是转为UI绑定量身打造的东西。以下情况你可以使用Driver替换BindTo:</p></blockquote><ul><li>不能发出error</li><li>在主线程中监听</li><li>共享事件流</li></ul><h1 id="map和flatMap何时使用"><a href="#map和flatMap何时使用" class="headerlink" title="map和flatMap何时使用"></a>map和flatMap何时使用</h1><p>官方Demo的时候，可能会迷惑为啥有的地方使用flatMapLatest为啥有些地方使用map呢？比如上面那个Driver所用的例子</p><blockquote><p>map函数，接受一个R类型的序列，返回一个R类型的序列，还是原来的序列</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;R&gt;<span class="params">(<span class="number">_</span> transform: @escaping <span class="params">(<span class="keyword">Self</span>.E)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">R</span>) -&gt; <span class="type">RxSwift</span>.<span class="type">Observable</span>&lt;<span class="type">R</span>&gt;</span><br></pre></td></tr></table></figure><blockquote><p>flatMap函数，接收一个O类型的序列，返回一个O.E类型的序列，也就是有原来序列里元素组成的新序列</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;O : ObservableConvertibleType&gt;<span class="params">(<span class="number">_</span> selector: @escaping <span class="params">(<span class="keyword">Self</span>.E)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">O</span>) -&gt; <span class="type">RxSwift</span>.<span class="type">Observable</span>&lt;<span class="type">O</span>.<span class="type">E</span>&gt;</span><br></pre></td></tr></table></figure><p>其实这里的map和flatMap在swift中的作用是一样的。map函数可以对原有序列里面的事件元素进行改造，返回的还是原来的序列。而flatMap对原有序列中的元素进行改造和处理，每一个元素返回一个新的sequence，然后把每一个元素对应的sequence合并为一个新的sequence序列</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> test = <span class="type">Observable</span>.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>)</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span> + <span class="string">"TTF"</span> &#125;</span><br><span class="line">    </span><br><span class="line">test</span><br><span class="line">    .subscribe(onNext: &#123;</span><br><span class="line">        <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">1TTF</span><br><span class="line">2TTF</span><br><span class="line">3TTF</span><br><span class="line">4TTF</span><br><span class="line">5TTF</span><br></pre></td></tr></table></figure><blockquote><p>使用map对序列中每一个元素进行了处理，返回的是一个元素，而使用flatMap需要返回的序列。那么使用map也返回一个序列看看</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> test = <span class="type">Observable</span>.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>)</span><br><span class="line">    .<span class="built_in">map</span> &#123; <span class="type">Observable</span>.just($<span class="number">0</span>) &#125;</span><br><span class="line">test</span><br><span class="line">    .subscribe(onNext: &#123;</span><br><span class="line">        <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line">    </span><br><span class="line"><span class="type">RxSwift</span>.<span class="type">Just</span>&lt;<span class="type">Swift</span>.<span class="type">String</span>&gt;</span><br><span class="line"><span class="type">RxSwift</span>.<span class="type">Just</span>&lt;<span class="type">Swift</span>.<span class="type">String</span>&gt;</span><br><span class="line"><span class="type">RxSwift</span>.<span class="type">Just</span>&lt;<span class="type">Swift</span>.<span class="type">String</span>&gt;</span><br><span class="line"><span class="type">RxSwift</span>.<span class="type">Just</span>&lt;<span class="type">Swift</span>.<span class="type">String</span>&gt;</span><br><span class="line"><span class="type">RxSwift</span>.<span class="type">Just</span>&lt;<span class="type">Swift</span>.<span class="type">String</span>&gt;</span><br></pre></td></tr></table></figure><blockquote><p>看到结果会打印出每一个序列，下面我们使用merge()方法将这几个序列进行合并</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> test = <span class="type">Observable</span>.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>)</span><br><span class="line">    .<span class="built_in">map</span> &#123; <span class="type">Observable</span>.just($<span class="number">0</span>) &#125;</span><br><span class="line">    .merge()</span><br><span class="line">    </span><br><span class="line">test</span><br><span class="line">    .subscribe(onNext: &#123;</span><br><span class="line">        <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line">    </span><br><span class="line"> <span class="comment">///</span></span><br><span class="line">  <span class="number">1</span></span><br><span class="line">  <span class="number">2</span></span><br><span class="line">  <span class="number">3</span></span><br><span class="line">  <span class="number">4</span></span><br><span class="line">  <span class="number">5</span></span><br></pre></td></tr></table></figure><blockquote><p>合并为一个新序列后我们就可以正常打印元素了。下面看看使用faltMap()函数干这件事</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> test = <span class="type">Observable</span>.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>)</span><br><span class="line">    .flatMap &#123; <span class="type">Observable</span>.just($<span class="number">0</span>) &#125;</span><br><span class="line">    </span><br><span class="line">test</span><br><span class="line">    .subscribe(onNext: &#123;</span><br><span class="line">        <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line">    </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><blockquote><p>看下对比是不是一样，这样子对比就清晰了吧</p></blockquote><ul><li>map函数只能返回原来的那一个序列，里面的参数的返回值被当做原来序列中所对应的元素。</li><li>flatMap函数返回的是一个新的序列，将原来元素进行了处理，返回这些处理后的元素组成的新序列</li><li>map函数 + 合并函数 = flatMap函数</li></ul><blockquote><p>flatMap函数在实际应用中有很多地方需要用到，比如网络请求，网络请求可能会发生错误，我们需要对这个请求过程进行监听，然后处理错误。只要继续他返回的是一个新的序列</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">validatedUsername = input.username</span><br><span class="line">          .flatMapLatest &#123; username <span class="keyword">in</span></span><br><span class="line">              <span class="keyword">return</span> validationService.validateUsername(username)</span><br><span class="line">                  .observeOn(<span class="type">MainScheduler</span>.instance)</span><br><span class="line">                  .catchErrorJustReturn(.failed(message: <span class="string">"Error contacting server"</span>))</span><br><span class="line">          &#125;</span><br><span class="line">          .shareReplay(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>flatMapLatest其实就是flatMap的另一个方式，只发送最后一个合进来的序列事件。上面认证username是一个网络请求，我们需要对这个过程进行处理<br>这个password不需要后台联网认证，只需要返回password符合不符合要求就行了，还是原来的序列就行了</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">validatedPassword = input.password</span><br><span class="line">  .<span class="built_in">map</span> &#123; password <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">return</span> validationService.validatePassword(password)</span><br><span class="line">  &#125;</span><br><span class="line">  .shareReplay(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>flatMap也解决了内嵌多个subscribe的问题，官方不建议内嵌多个subscribe。比如：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   textField.rx_text.subscribe(onNext: &#123; text <span class="keyword">in</span></span><br><span class="line">    performURLRequest(text).subscribe(onNext: &#123; result <span class="keyword">in</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;)</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br><span class="line">&#125;)</span><br><span class="line">.addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><blockquote><p>改写为flatMap</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">textField.rx_text</span><br><span class="line"> .flatMapLatest &#123; text <span class="keyword">in</span></span><br><span class="line">     <span class="keyword">return</span> performURLRequest(text) <span class="comment">//因为flatMap返回一个新的sequence</span></span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line"> .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><p>再举一个例子，当我们网络请求得到json数据的时候，我们可以使用flatmap进行序列转换，解析成Model序列，然后我们订阅这个带有Model的序列，代码就会变得很优雅</p><h1 id="UIBindingObserver"><a href="#UIBindingObserver" class="headerlink" title="UIBindingObserver"></a>UIBindingObserver</h1><blockquote><p>UIBindingObserver这个东西很有用的，创建我们自己的监听者，有时候RxCocoa(RxSwiftz中对UIKit的一个扩展库)给的扩展不够我们使用，比如一个UITextField有个isEnabled属性，我想把这个isEnabled变为一个observer，我们可以这样做：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UITextField</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inputEnabled: <span class="type">UIBindingObserver</span>&lt;<span class="type">Base</span>, <span class="type">Result</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIBindingObserver</span>(<span class="type">UIElement</span>: base) &#123; textFiled, result <span class="keyword">in</span></span><br><span class="line">            textFiled.isEnabled = result.isValid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>UIBindingObserver是一个类，他的初始化方法中，有两个参数，第一个参数是一个元素本身，第一个参数是一个闭包，闭包参数是元素本身，还有他的一个性</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(<span class="type">UIElement</span>: <span class="type">UIElementType</span>, binding: @escaping (<span class="type">UIElementType</span>, <span class="type">Value</span>) -&gt; <span class="type">Swift</span>.<span class="type">Void</span>)</span><br></pre></td></tr></table></figure><blockquote><p>自定义了一个inputEnabled Observer里面关联的UITextField的isEnabled属性</p></blockquote>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Grammar </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-RxSwift-Subject</title>
      <link href="/2017/12/16/Swift/RxSwift/Grammar/06-Subject/"/>
      <url>/2017/12/16/Swift/RxSwift/Grammar/06-Subject/</url>
      <content type="html"><![CDATA[<h1 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h1><h2 id="Subjects-既是订阅者，也是Observable"><a href="#Subjects-既是订阅者，也是Observable" class="headerlink" title="Subjects 既是订阅者，也是Observable"></a>Subjects 既是订阅者，也是Observable</h2><blockquote><p>Subject是observable和Observer之间的桥梁<br>说它是订阅者，是因为它能够动态地接收新的值。<br>作为一个 Observer ，它可以订阅序列<br>说它又是一个 Observable，是因为当 Subjects 有了新的值之后，就会通过 Event 将新值发出给他的所有订阅者<br>同时作为一个 Observable ，它可以转发或者发射数据</p></blockquote><h2 id="Subject-有以下几种"><a href="#Subject-有以下几种" class="headerlink" title="Subject 有以下几种"></a>Subject 有以下几种</h2><ul><li>①PublishSubject 只发射给观察者订阅后的数据</li><li>②ReplaySubject</li><li>③BehaviorSubject</li><li>④Variable</li></ul><blockquote><p>区别</p></blockquote><ul><li>PublishSubject, ReplaySubject和BehaviorSubject是不会自动发出completed事件的</li></ul><blockquote><p>相同之处：</p></blockquote><ul><li>首先他们都是 Observable，他们的订阅者都能收到他们发出的新的 Event</li><li>直到 Subject 发出 .complete 或者 .error 的 Event 后，该 Subject 便终结了，同时它也就不会再发出 .next 事件</li><li>对于那些在 Subject 终结后再订阅他的订阅者，也能收到 subject 发出的一条 .complete 或 .error 的 event，告诉这个新的订阅者它已经终结了。</li><li>他们之间最大的区别只是在于：当一个新的订阅者刚订阅它的时候，能不能收到 Subject 以前发出过的旧 Event，如果能的话又能收到多少个</li></ul><h2 id="Subject-常用的几个方法"><a href="#Subject-常用的几个方法" class="headerlink" title="Subject 常用的几个方法"></a>Subject 常用的几个方法</h2><ul><li>onNext(:)：是 on(.next(:)) 的简便写法。该方法相当于 subject 接收到一个 .next 事件</li><li>onError(:)：是 on(.error(:)) 的简便写法。该方法相当于 subject 接收到一个 .error 事件</li><li>onCompleted()：是 on(.completed) 的简便写法。该方法相当于 subject 接收到一个 .completed 事件</li></ul><h1 id="①PublishSubject"><a href="#①PublishSubject" class="headerlink" title="①PublishSubject"></a>①PublishSubject</h1><h2 id="❶基本介绍"><a href="#❶基本介绍" class="headerlink" title="❶基本介绍"></a>❶基本介绍</h2><blockquote><p>PublishSubject 是最普通的 Subject，它不需要初始值就能创建<br>当有观察者订阅 PublishSubject 时，PublishSubject 会发射订阅之后的数据给这个观察者,<strong><em>只能接收到订阅他之后发生的事件</em></strong><br>PublishSubject 的订阅者从他们开始订阅的时间点起，可以收到订阅后 Subject 发出的新 Event，而不会收到他们在订阅前已发出的 Even<br>于是这里存在丢失数据的问题，如需全部数据，推荐改用 ReplaySubject<br>subject.onNext()发出onNext事件<br>对应的还有onError()和onCompleted()事件</p></blockquote><h2 id="❷时序图"><a href="#❷时序图" class="headerlink" title="❷时序图"></a>❷时序图</h2><blockquote><p>最上面一条是 PublishSubject<br>下面两条分别表示两个新的订阅，它们订阅的时间点不同，可以发现 PublishSubject 的订阅者只能收到他们订阅后的 Even<br>如果序列因为错误终止发射序列，此时 PublishSubject 就不会发射数据，只是传递这次错误事件</p></blockquote><p><img src="http://ozr735s7e.bkt.clouddn.com/Swift-RxSwift-Subject-001.png" alt="001"></p><h2 id="❸使用样例"><a href="#❸使用样例" class="headerlink" title="❸使用样例"></a>❸使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建一个PublishSubject</span></span><br><span class="line"><span class="keyword">let</span> subject = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//由于当前没有任何订阅者，所以这条信息不会输出到控制台</span></span><br><span class="line">subject.onNext(<span class="string">"111"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//第1次订阅subject</span></span><br><span class="line">subject.subscribe(onNext: &#123; string <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"第1次订阅："</span>, string)</span><br><span class="line">&#125;, onCompleted:&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"第1次订阅：onCompleted"</span>)</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//当前有1个订阅，则该信息会输出到控制台</span></span><br><span class="line">subject.onNext(<span class="string">"222"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//第2次订阅subject</span></span><br><span class="line">subject.subscribe(onNext: &#123; string <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"第2次订阅："</span>, string)</span><br><span class="line">&#125;, onCompleted:&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"第2次订阅：onCompleted"</span>)</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//当前有2个订阅，则该信息会输出到控制台</span></span><br><span class="line">subject.onNext(<span class="string">"333"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//让subject结束</span></span><br><span class="line">subject.onCompleted()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//subject完成后会发出.next事件了。</span></span><br><span class="line">subject.onNext(<span class="string">"444"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//subject完成后它的所有订阅（包括结束后的订阅），都能收到subject的.completed事件，</span></span><br><span class="line">subject.subscribe(onNext: &#123; string <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"第3次订阅："</span>, string)</span><br><span class="line">&#125;, onCompleted:&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"第3次订阅：onCompleted"</span>)</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line">  第一次订阅： <span class="number">222</span></span><br><span class="line">  第一次订阅： <span class="number">333</span></span><br><span class="line">  第一次订阅： <span class="number">333</span></span><br><span class="line">  第一次订阅： onCompleted</span><br><span class="line">  第一次订阅： onCompleted</span><br><span class="line">  第一次订阅： onCompleted</span><br></pre></td></tr></table></figure><h2 id="②ReplaySubject"><a href="#②ReplaySubject" class="headerlink" title="②ReplaySubject"></a>②ReplaySubject</h2><h2 id="❶基本介绍-1"><a href="#❶基本介绍-1" class="headerlink" title="❶基本介绍"></a>❶基本介绍</h2><ul><li>和 PushblishSubject 不同，不论观察者什么时候订阅， ReplaySubject 都会发射完整的数据给观察者</li><li>ReplaySubject和PublishSubject不同的是，Observer有可能接收到订阅之前的值</li><li>ReplaySubject 在创建时候需要设置一个 bufferSize，表示它对于它发送过的 event 的缓存个数</li><li>比如一个 ReplaySubject 的 bufferSize 设置为 2，它发出了 3 个 .next 的 event，那么它会将后两个（最近的两个）event 给缓存起来。此时如果有一个 subscriber 订阅了这个 ReplaySubject，那么这个 subscriber 就会立即收到前面缓存的两个 .next 的 event</li><li>如果一个 subscriber 订阅已经结束的 ReplaySubject，除了会收到缓存的 .next 的 event 外，还会收到那个终结的 .error 或者 .complete 的 event</li></ul><h2 id="❷时序图-1"><a href="#❷时序图-1" class="headerlink" title="❷时序图"></a>❷时序图</h2><ul><li>最上面一条是 ReplaySubject（bufferSize 设为为 2）<ul><li>下面两条分别表示两个新的订阅，它们订阅的时间点不同。可以发现 ReplaySubject 的订阅者一开始就能收到 ReplaySubject 之前发出的两个 Event（如果有的话）</li></ul></li></ul><p><img src="http://ozr735s7e.bkt.clouddn.com/Swift-RxSwift-Subject-003.png" alt="003"></p><h2 id="❷使用样例"><a href="#❷使用样例" class="headerlink" title="❷使用样例"></a>❷使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建一个bufferSize为2的ReplaySubject</span></span><br><span class="line"><span class="keyword">let</span> subject = <span class="type">ReplaySubject</span>&lt;<span class="type">String</span>&gt;.create(bufferSize: <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//连续发送3个next事件</span></span><br><span class="line">subject.onNext(<span class="string">"111"</span>)</span><br><span class="line">subject.onNext(<span class="string">"222"</span>)</span><br><span class="line">subject.onNext(<span class="string">"333"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//第1次订阅subject</span></span><br><span class="line">subject.subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"第1次订阅："</span>, event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//再发送1个next事件</span></span><br><span class="line">subject.onNext(<span class="string">"444"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//第2次订阅subject</span></span><br><span class="line">subject.subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"第2次订阅："</span>, event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//让subject结束</span></span><br><span class="line">subject.onCompleted()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//第3次订阅subject</span></span><br><span class="line">subject.subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"第3次订阅："</span>, event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">//print </span></span><br><span class="line">第<span class="number">1</span>次订阅: next(<span class="number">222</span>)</span><br><span class="line">第<span class="number">1</span>次订阅: next(<span class="number">333</span>)</span><br><span class="line">第<span class="number">1</span>次订阅: next(<span class="number">444</span>)</span><br><span class="line">第<span class="number">2</span>次订阅: next(<span class="number">333</span>)</span><br><span class="line">第<span class="number">2</span>次订阅: next(<span class="number">444</span>)</span><br><span class="line">第<span class="number">1</span>次订阅: completed</span><br><span class="line">第<span class="number">2</span>次订阅: completed</span><br><span class="line">第<span class="number">3</span>次订阅: next(<span class="number">333</span>)</span><br><span class="line">第<span class="number">3</span>次订阅: next(<span class="number">44</span>)</span><br><span class="line">第<span class="number">3</span>次订阅: completed</span><br></pre></td></tr></table></figure><h1 id="③BehaviorSubject"><a href="#③BehaviorSubject" class="headerlink" title="③BehaviorSubject"></a>③BehaviorSubject</h1><h2 id="❶基本介绍-2"><a href="#❶基本介绍-2" class="headerlink" title="❶基本介绍"></a>❶基本介绍</h2><blockquote><p>BehaviorSubject 需要通过一个默认初始值来创建<br>当一个订阅者来订阅它的时候，这个订阅者会立即收到 BehaviorSubjects 上一个发出的 event。之后就跟正常的情况一样，它也会接收到 BehaviorSubject 之后发出的新的 event。</p></blockquote><h2 id="❷时序图-2"><a href="#❷时序图-2" class="headerlink" title="❷时序图"></a>❷时序图</h2><blockquote><p>最上面一条是 BehaviorSubject<br>下面两条分别表示两个新的订阅，它们订阅的时间点不同，可以发现 BehaviorSubject 的订阅者一开始就能收到 BehaviorSubjects 之前发出的一个 Event</p></blockquote><p><img src="http://ozr735s7e.bkt.clouddn.com/Swift-RxSwift-Subject-004.png" alt="002"></p><h2 id="❸使用样例-1"><a href="#❸使用样例-1" class="headerlink" title="❸使用样例"></a>❸使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建一个BehaviorSubject</span></span><br><span class="line"><span class="keyword">let</span> subject = <span class="type">BehaviorSubject</span>(value: <span class="string">"111"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//第1次订阅subject</span></span><br><span class="line">subject.subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"第1次订阅："</span>, event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//发送next事件</span></span><br><span class="line">subject.onNext(<span class="string">"222"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//发送error事件</span></span><br><span class="line">subject.onError(<span class="type">NSError</span>(domain: <span class="string">"local"</span>, code: <span class="number">0</span>, userInfo: <span class="literal">nil</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment">//第2次订阅subject</span></span><br><span class="line">subject.subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"第2次订阅："</span>, event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line">第<span class="number">1</span>次订阅: next(<span class="number">111</span>)</span><br><span class="line">第<span class="number">1</span>次订阅: next(<span class="number">222</span>)</span><br><span class="line">第<span class="number">1</span>次订阅: next(<span class="type">Error</span> <span class="type">Domain</span>=local <span class="type">Code</span>=<span class="number">0</span> <span class="string">"null"</span>)</span><br><span class="line">第<span class="number">2</span>次订阅: next(<span class="type">Error</span> <span class="type">Domain</span>=local <span class="type">Code</span>=<span class="number">0</span> <span class="string">"null"</span>)</span><br></pre></td></tr></table></figure><h1 id="④Variable"><a href="#④Variable" class="headerlink" title="④Variable"></a>④Variable</h1><h2 id="❶基本介绍-3"><a href="#❶基本介绍-3" class="headerlink" title="❶基本介绍"></a>❶基本介绍</h2><ul><li>Variable 是 BehaviorSubject 的一个封装</li><li>相比 BehaviorSubject ，它不会因为错误终止也不会正常终止，是一个无限序列</li><li>Variable是BehaviorSubject一个包装箱，就像是一个箱子一样，使用的时候需要调用asObservable()拆箱，里面的value是一个BehaviorSubject，他不会发出error事件，但是会自动发出completed事件</li><li>Variable 其实就是对 BehaviorSubject 的封装，所以它也必须要通过一个默认的初始值进行创建。<br>Variable 具有 BehaviorSubject 的功能，能够向它的订阅者发出上一个 event 以及之后新创建的 event。<br>不同的是，Variable 还把会把当前发出的值保存为自己的状态。同时它会在销毁时自动发送 .complete 的 event，不需要也不能手动给 Variables 发送 completed 或者 error 事件来结束它。<br>简单地说就是 Variable 有一个 value 属性，我们改变这个 value 属性的值就相当于调用一般 Subjects 的 onNext() 方法，而这个最新的 onNext() 的值就被保存在 value 属性里了，直到我们再次修改它</li></ul><blockquote><p>注意：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Variables 本身没有 subscribe() 方法，但是所有 Subjects 都有一个 asObservable() 方法。我们可以使用这个方法返回这个 Variable 的 Observable 类型，拿到这个 Observable 类型我们就能订阅它了。</span><br></pre></td></tr></table></figure><h2 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> RxCocoa</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//创建一个初始值为111的Variable</span></span><br><span class="line">        <span class="keyword">let</span> variable = <span class="type">Variable</span>(<span class="string">"111"</span>)</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//修改value值</span></span><br><span class="line">        variable.value = <span class="string">"222"</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//第1次订阅</span></span><br><span class="line">        variable.asObservable().subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"第1次订阅："</span>, $<span class="number">0</span>)</span><br><span class="line">        &#125;.disposed(by: disposeBag)</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//修改value值</span></span><br><span class="line">        variable.value = <span class="string">"333"</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//第2次订阅</span></span><br><span class="line">        variable.asObservable().subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"第2次订阅："</span>, $<span class="number">0</span>)</span><br><span class="line">        &#125;.disposed(by: disposeBag)</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//修改value值</span></span><br><span class="line">        variable.value = <span class="string">"444"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果如下：<br>注意：由于 Variable 对象在 viewDidLoad() 方法内初始化，所以它的生命周期就被限制在该方法内。当这个方法执行完毕后，这个 Variable 对象就会被销毁，同时它也就自动地向它的所有订阅者发出 .completed 事件</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">第<span class="number">1</span>次订阅: next(<span class="number">222</span>)</span><br><span class="line">第<span class="number">1</span>次订阅: next(<span class="number">333</span>)</span><br><span class="line">第<span class="number">2</span>次订阅: next(<span class="number">333</span>)</span><br><span class="line">第<span class="number">1</span>次订阅: next(<span class="number">444</span>)</span><br><span class="line">第<span class="number">2</span>次订阅: next(<span class="number">444</span>)</span><br><span class="line">第<span class="number">1</span>次订阅: completed</span><br><span class="line">第<span class="number">1</span>次订阅: completed</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-RxSwift-Observable订阅&amp;事件监听&amp;订阅销毁-05</title>
      <link href="/2017/12/16/Swift/RxSwift/Grammar/05-Observer%E8%A7%82%E5%AF%9F%E8%80%85/"/>
      <url>/2017/12/16/Swift/RxSwift/Grammar/05-Observer%E8%A7%82%E5%AF%9F%E8%80%85/</url>
      <content type="html"><![CDATA[<ul><li><a href="#①1">①Observer观察者</a></li><li><a href="#②2">②直接在 subscribe、bind 方法中创建观察者</a></li><li><a href="#③3">③使用 AnyObserver 创建观察者</a></li><li><a href="#④4">④使用 Binder 创建观察者</a></li><li><a href="#⑤5">⑤自定义可绑定属性</a></li><li><a href="#⑥6">⑥RxSwift 自带的可绑定属性（UI 观察者）</a></li></ul><p><span id="①1">①1</span></p><h1 id="①Observer观察者"><a href="#①Observer观察者" class="headerlink" title="①Observer观察者"></a>①Observer观察者</h1><blockquote><p>观察者（Observer）的作用就是监听事件，然后对这个事件做出响应。或者说任何响应事件的行为都是观察者</p></blockquote><ul><li>当我们点击按钮，弹出一个提示框。那么这个“弹出一个提示框”就是观察者 Observer<void></void></li><li>当我们请求一个远程的 json 数据后，将其打印出来。那么这个“打印 json 数据”就是观察者 Observer<json></json></li></ul><p><img src="http://ozr735s7e.bkt.clouddn.com/Observer-001.png" alt=""></p><p><span id="②2">②2</span></p><h1 id="②直接在-subscribe、bind-方法中创建观察者"><a href="#②直接在-subscribe、bind-方法中创建观察者" class="headerlink" title="②直接在 subscribe、bind 方法中创建观察者"></a>②直接在 subscribe、bind 方法中创建观察者</h1><blockquote><p>❶在 subscribe 方法中创建</p></blockquote><ul><li>创建观察者最直接的方法就是在 Observable 的 subscribe 方法后面描述当事件发生时，需要如何做出响应</li><li>比如下面的样例，观察者就是由后面的 onNext，onError，onCompleted 这些闭包构建出来的</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>)</span><br><span class="line">          </span><br><span class="line">observable.subscribe(onNext: &#123; element <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(element)</span><br><span class="line">&#125;, onError: &#123; error <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"completed"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line"><span class="type">A</span></span><br><span class="line"><span class="type">B</span></span><br><span class="line"><span class="type">C</span></span><br><span class="line">completed</span><br></pre></td></tr></table></figure><blockquote><p>❷在 bind 方法中创建</p></blockquote><ul><li>创建一个定时生成索引数的 Observable 序列，并将索引数不断显示在 label 标签上</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> RxCocoa</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> label: <span class="type">UILabel</span>!</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//Observable序列（每隔1秒钟发出一个索引数）</span></span><br><span class="line">        <span class="keyword">let</span> observable = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.interval(<span class="number">1</span>, scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line"> </span><br><span class="line">        observable</span><br><span class="line">            .<span class="built_in">map</span> &#123; <span class="string">"当前索引数：<span class="subst">\($<span class="number">0</span> )</span>"</span>&#125;</span><br><span class="line">            .bind &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>](text) <span class="keyword">in</span></span><br><span class="line">                <span class="comment">//收到发出的索引数后显示到label上</span></span><br><span class="line">                <span class="keyword">self</span>?.label.text = text</span><br><span class="line">            &#125;</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="③3">③3</span></p><h1 id="③使用-AnyObserver-创建观察者"><a href="#③使用-AnyObserver-创建观察者" class="headerlink" title="③使用 AnyObserver 创建观察者"></a>③使用 AnyObserver 创建观察者</h1><ul><li>AnyObserver 可以用来描叙任意一种观察者</li></ul><h2 id="❶配合-subscribe-方法使用"><a href="#❶配合-subscribe-方法使用" class="headerlink" title="❶配合 subscribe 方法使用"></a>❶配合 subscribe 方法使用</h2><blockquote><p>比如上面第一个样例我们可以改成如下代码</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//观察者</span></span><br><span class="line"><span class="keyword">let</span> observer: <span class="type">AnyObserver</span>&lt;<span class="type">String</span>&gt; = <span class="type">AnyObserver</span> &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> event &#123;</span><br><span class="line">    <span class="keyword">case</span> .next(<span class="keyword">let</span> data):</span><br><span class="line">        <span class="built_in">print</span>(data)</span><br><span class="line">    <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">    <span class="keyword">case</span> .completed:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"completed"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>)</span><br><span class="line">observable.subscribe(observer)</span><br></pre></td></tr></table></figure><h2 id="❷配合-bindTo-方法使用"><a href="#❷配合-bindTo-方法使用" class="headerlink" title="❷配合 bindTo 方法使用"></a>❷配合 bindTo 方法使用</h2><blockquote><p>也可配合 Observable 的数据绑定方法（bindTo）使用。比如上面的第二个样例我可以改成如下代码</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> RxCocoa</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> label: <span class="type">UILabel</span>!</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//观察者</span></span><br><span class="line">        <span class="keyword">let</span> observer: <span class="type">AnyObserver</span>&lt;<span class="type">String</span>&gt; = <span class="type">AnyObserver</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (event) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">switch</span> event &#123;</span><br><span class="line">            <span class="keyword">case</span> .next(<span class="keyword">let</span> text):</span><br><span class="line">                <span class="comment">//收到发出的索引数后显示到label上</span></span><br><span class="line">                <span class="keyword">self</span>?.label.text = text</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//Observable序列（每隔1秒钟发出一个索引数）</span></span><br><span class="line">        <span class="keyword">let</span> observable = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.interval(<span class="number">1</span>, scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">        observable</span><br><span class="line">            .<span class="built_in">map</span> &#123; <span class="string">"当前索引数：<span class="subst">\($<span class="number">0</span> )</span>"</span>&#125;</span><br><span class="line">            .bind(to: observer)</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="④4">④4</span></p><h1 id="④使用-Binder-创建观察者"><a href="#④使用-Binder-创建观察者" class="headerlink" title="④使用 Binder 创建观察者"></a>④使用 Binder 创建观察者</h1><h2 id="❶基本介绍"><a href="#❶基本介绍" class="headerlink" title="❶基本介绍"></a>❶基本介绍</h2><blockquote><p>相较于 AnyObserver 的大而全，Binder 更专注于特定的场景。Binder 主要有以下两个特征：</p></blockquote><ul><li>不会处理错误事件</li><li>确保绑定都是在给定 Scheduler 上执行（默认 MainScheduler）</li></ul><blockquote><p>一旦产生错误事件，在调试环境下将执行 fatalError，在发布环境下将打印错误信息</p></blockquote><h2 id="❷使用样例"><a href="#❷使用样例" class="headerlink" title="❷使用样例"></a>❷使用样例</h2><blockquote><p>在上面序列数显示样例中，label 标签的文字显示就是一个典型的 UI 观察者。它在响应事件时，只会处理 next 事件，而且更新 UI 的操作需要在主线程上执行。那么这种情况下更好的方案就是使用 Binder<br>上面的样例我们改用 Binder 会简单许多：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> RxCocoa</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> label: <span class="type">UILabel</span>!</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">                 </span><br><span class="line">        <span class="comment">//观察者</span></span><br><span class="line">        <span class="keyword">let</span> observer: <span class="type">Binder</span>&lt;<span class="type">String</span>&gt; = <span class="type">Binder</span>(label) &#123; (view, text) <span class="keyword">in</span></span><br><span class="line">            <span class="comment">//收到发出的索引数后显示到label上</span></span><br><span class="line">            view.text = text</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//Observable序列（每隔1秒钟发出一个索引数）</span></span><br><span class="line">        <span class="keyword">let</span> observable = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.interval(<span class="number">1</span>, scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">        observable</span><br><span class="line">            .<span class="built_in">map</span> &#123; <span class="string">"当前索引数：<span class="subst">\($<span class="number">0</span> )</span>"</span>&#125;</span><br><span class="line">            .bind(to: observer)</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="⑤5">⑤5</span></p><h1 id="⑤自定义可绑定属性"><a href="#⑤自定义可绑定属性" class="headerlink" title="⑤自定义可绑定属性"></a>⑤自定义可绑定属性</h1><blockquote><p>有时我们想让 UI 控件创建出来后默认就有一些观察者，而不必每次都为它们单独去创建观察者。比如我们想要让所有的 UIlabel 都有个 fontSize 可绑定属性，它会根据事件值自动改变标签的字体大小</p></blockquote><h2 id="❶方式一-通过对-UI-类进行扩展"><a href="#❶方式一-通过对-UI-类进行扩展" class="headerlink" title="❶方式一:通过对 UI 类进行扩展"></a>❶方式一:通过对 UI 类进行扩展</h2><blockquote><p>通过对 UILabel 进行扩展，增加了一个 fontSize 可绑定属性</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> RxCocoa</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> label: <span class="type">UILabel</span>!</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//Observable序列（每隔0.5秒钟发出一个索引数）</span></span><br><span class="line">        <span class="keyword">let</span> observable = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.interval(<span class="number">0.5</span>, scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">        observable</span><br><span class="line">            .<span class="built_in">map</span> &#123; <span class="type">CGFloat</span>($<span class="number">0</span>) &#125;</span><br><span class="line">            .bind(to: label.fontSize) <span class="comment">//根据索引数不断变放大字体</span></span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UILabel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> fontSize: <span class="type">Binder</span>&lt;<span class="type">CGFloat</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Binder</span>(<span class="keyword">self</span>) &#123; label, fontSize <span class="keyword">in</span></span><br><span class="line">            label.font = <span class="type">UIFont</span>.systemFont(ofSize: fontSize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="❷通过对-Reactive-类进行扩展"><a href="#❷通过对-Reactive-类进行扩展" class="headerlink" title="❷通过对 Reactive 类进行扩展"></a>❷通过对 Reactive 类进行扩展</h2><blockquote><p>既然使用了 RxSwift，那么更规范的写法应该是对 Reactive 进行扩展。这里同样是给 UILabel 增加了一个 fontSize 可绑定属性</p></blockquote><ul><li>（注意：这种方式下，我们绑定属性时要写成 label.rx.fontSize）</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> RxCocoa</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> label: <span class="type">UILabel</span>!</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//Observable序列（每隔0.5秒钟发出一个索引数）</span></span><br><span class="line">        <span class="keyword">let</span> observable = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.interval(<span class="number">0.5</span>, scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">        observable</span><br><span class="line">            .<span class="built_in">map</span> &#123; <span class="type">CGFloat</span>($<span class="number">0</span>) &#125;</span><br><span class="line">            .bind(to: label.rx.fontSize) <span class="comment">//根据索引数不断变放大字体</span></span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UILabel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> fontSize: <span class="type">Binder</span>&lt;<span class="type">CGFloat</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Binder</span>(<span class="keyword">self</span>.base) &#123; label, fontSize <span class="keyword">in</span></span><br><span class="line">            label.font = <span class="type">UIFont</span>.systemFont(ofSize: fontSize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="⑥6">⑥6</span></p><h1 id="⑥RxSwift-自带的可绑定属性（UI-观察者）"><a href="#⑥RxSwift-自带的可绑定属性（UI-观察者）" class="headerlink" title="⑥RxSwift 自带的可绑定属性（UI 观察者）"></a>⑥RxSwift 自带的可绑定属性（UI 观察者）</h1><blockquote><p>其实 RxSwift 已经为我们提供许多常用的可绑定属性。比如 UILabel 就有 text 和 attributedText 这两个可绑定属性。</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UILabel</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/// Bindable sink for `text` property.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> text: <span class="type">Binder</span>&lt;<span class="type">String</span>?&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Binder</span>(<span class="keyword">self</span>.base) &#123; label, text <span class="keyword">in</span></span><br><span class="line">            label.text = text</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/// Bindable sink for `attributedText` property.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> attributedText: <span class="type">Binder</span>&lt;<span class="type">NSAttributedString</span>?&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Binder</span>(<span class="keyword">self</span>.base) &#123; label, text <span class="keyword">in</span></span><br><span class="line">            label.attributedText = text</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>那么上文那个定时显示索引数的样例，我们其实不需要自定义 UI 观察者，直接使用 RxSwift 提供的绑定属性即可。</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> RxCocoa</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> label: <span class="type">UILabel</span>!</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//Observable序列（每隔1秒钟发出一个索引数）</span></span><br><span class="line">        <span class="keyword">let</span> observable = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.interval(<span class="number">1</span>, scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">        observable</span><br><span class="line">            .<span class="built_in">map</span> &#123; <span class="string">"当前索引数：<span class="subst">\($<span class="number">0</span> )</span>"</span>&#125;</span><br><span class="line">            .bind(to: label.rx.text) <span class="comment">//收到发出的索引数后显示到label上</span></span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-响应式编程对比</title>
      <link href="/2017/12/16/Swift/RxSwift/Grammar/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AF%B9%E6%AF%94/"/>
      <url>/2017/12/16/Swift/RxSwift/Grammar/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AF%B9%E6%AF%94/</url>
      <content type="html"><![CDATA[<p>#Rx 介绍</p><h2 id="Rx"><a href="#Rx" class="headerlink" title="Rx"></a>Rx</h2><ul><li>Rx 是 ReactiveX 的缩写，简单来说就是基于异步 Event（事件）序列的响应式编程</li><li>Rx 可以简化异步编程方法，并提供更优雅的数据绑定。让我们可以时刻响应新的数据同时顺序地处理它们</li></ul><h2 id="Rx-库"><a href="#Rx-库" class="headerlink" title="Rx 库"></a>Rx 库</h2><ul><li>Rx 本身可以说是一种跨平台的标准，它有自己的社区论坛，不管是 web 还是移动开发，都能用 Rx 的思维和方法来完成你的工作</li><li>作为一种跨平台标准，目前已经有许多基于不同开发语言的 Rx 的库。除了我后面会着重介绍的 RxSwift 之外，还有 RxJava, RxJS, RxKotlin, Rx.NET…等等</li><li>这些 Rx 库虽然用的语言不同，但它们之间其实都是相通的，都有相同的 API。所以说如果以后你使用别的语言做其他的方面的开发，同样是可以使用相同的思维甚至相同的方法接口（除了语言不同）来编程</li></ul><p>##Rx 主页</p><ul><li>如果想了解整个 Rx 大家庭的成员，<a href="http://reactivex.io" target="_blank" rel="noopener">可以访问它的主页</a></li></ul><h1 id="RxSwift-介绍"><a href="#RxSwift-介绍" class="headerlink" title="RxSwift 介绍"></a>RxSwift 介绍</h1><h2 id="RxSwift-的作用"><a href="#RxSwift-的作用" class="headerlink" title="RxSwift 的作用"></a>RxSwift 的作用</h2><blockquote><p>经常需要检测某些值的变化（比如：textFiled 输入值的变化、数据请求完成或失败的变化），然后进行相应的处理</p></blockquote><ul><li>过去针对不同的情况，我们需要采用不同的事件传递方法去处理，比如：delegate、notifinotion、target-action、KVO 等等</li><li>而 RectiveX 机制（由 RxSwift 实现）的出现，让程序里的事件传递响应方法做到统一。将之前那些常用的事件传递方法（比如：delegate、notification、target-action 等等），全部替换成 Rx 的“信号链”方式</li><li>如果使用的是 MVVM 开发模式的话，通过 RxSwift 可以获得更加方便的数据绑定的方法，使得 MVVM 开发更加如虎添翼</li></ul><h2 id="RxSwift-的安装与配置"><a href="#RxSwift-的安装与配置" class="headerlink" title="RxSwift 的安装与配置"></a>RxSwift 的安装与配置</h2><blockquote><p><a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">GitHub 上下载</a><br>或 cocopods 导入</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> RxCocoa</span><br></pre></td></tr></table></figure><h2 id="RxSwift-与-RxCocoa"><a href="#RxSwift-与-RxCocoa" class="headerlink" title="RxSwift 与 RxCocoa"></a>RxSwift 与 RxCocoa</h2><ul><li>RxSwift：它只是基于 Swift 语言的 Rx 标准实现接口库，所以 RxSwift 里不包含任何 Cocoa 或者 UI 方面的类</li><li>RxCocoa：是基于 RxSwift 针对于 iOS 开发的一个库，它通过 Extension 的方法给原生的比如 UI 控件添加了 Rx 的特性，使得我们更容易订阅和响应这些控件的事件</li></ul>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Grammar </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-RxSwift-Observable订阅&amp;事件监听&amp;订阅销毁-04</title>
      <link href="/2017/12/16/Swift/RxSwift/Grammar/04-Observable%E8%AE%A2%E9%98%85&amp;%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC&amp;%E8%AE%A2%E9%98%85%E9%94%80%E6%AF%81/"/>
      <url>/2017/12/16/Swift/RxSwift/Grammar/04-Observable%E8%AE%A2%E9%98%85&amp;%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC&amp;%E8%AE%A2%E9%98%85%E9%94%80%E6%AF%81/</url>
      <content type="html"><![CDATA[<p>❶❷❸❹❺❼❽❾①②③④⑤⑥⑦⑧⑨⑩⑪⑫</p><ul><li><a href="#①just">①just</a></li><li><a href="#②of">②of</a></li></ul><p><span id="①just">①just</span></p><h1 id="订阅-Observable"><a href="#订阅-Observable" class="headerlink" title="订阅 Observable"></a>订阅 Observable</h1><blockquote><p>有了 Observable，我们还要使用 subscribe() 方法来订阅它，接收它发出的 Event</p></blockquote><h2 id="第一种用法"><a href="#第一种用法" class="headerlink" title="第一种用法"></a>第一种用法</h2><blockquote><p>❶使用 subscribe() 订阅了一个 Observable 对象，该方法的 block 的回调参数就是被发出的 event 事件，我们将其直接打印出来</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>)</span><br><span class="line">         </span><br><span class="line">observable.subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line">next(<span class="type">A</span>)</span><br><span class="line">next(<span class="type">B</span>)</span><br><span class="line">next(<span class="type">C</span>)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure><ul><li>初始化 Observable 序列时设置的默认值都按顺序通过 .next 事件发送出来。</li><li>当 Observable 序列的初始数据都发送完毕，它还会自动发一个 .completed 事件出来</li></ul><blockquote><p>❷如果想要获取到这个事件里的数据，可以通过 event.element 得到</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>)</span><br><span class="line">         </span><br><span class="line">observable.subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event.element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line"><span class="type">Optional</span>(<span class="string">"A"</span>)</span><br><span class="line"><span class="type">Optional</span>(<span class="string">"B"</span>)</span><br><span class="line"><span class="type">Optional</span>(<span class="string">"C"</span>)</span><br><span class="line"><span class="literal">nil</span></span><br></pre></td></tr></table></figure><h2 id="第二种用法"><a href="#第二种用法" class="headerlink" title="第二种用法"></a>第二种用法</h2><blockquote><p>RxSwift 还提供了另一个 subscribe 方法，它可以把 event 进行分类</p></blockquote><ul><li>通过不同的 block 回调处理不同类型的 event。（其中 onDisposed 表示订阅行为被 dispose 后的回调，这个我后面会说）</li><li>同时会把 event 携带的数据直接解包出来作为参数，方便我们使用</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>)</span><br><span class="line">         </span><br><span class="line">observable.subscribe(onNext: &#123; element <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(element)</span><br><span class="line">&#125;, onError: &#123; error <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"completed"</span>)</span><br><span class="line">&#125;, onDisposed: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"disposed"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line"><span class="type">A</span></span><br><span class="line"><span class="type">B</span></span><br><span class="line"><span class="type">C</span></span><br><span class="line">completed</span><br><span class="line">disposed</span><br></pre></td></tr></table></figure><blockquote><p>subscribe() 方法的 onNext、onError、onCompleted 和 onDisposed 这四个回调 block 参数都是有默认值的，即它们都是可选的。所以我们也可以只处理 onNext 而不管其他的情况</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>)</span><br><span class="line">         </span><br><span class="line">observable.subscribe(onNext: &#123; element <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(element)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line"><span class="type">A</span></span><br><span class="line"><span class="type">B</span></span><br><span class="line"><span class="type">C</span></span><br></pre></td></tr></table></figure><h1 id="监听事件的生命周期"><a href="#监听事件的生命周期" class="headerlink" title="监听事件的生命周期"></a>监听事件的生命周期</h1><h2 id="doOn-介绍"><a href="#doOn-介绍" class="headerlink" title="doOn 介绍"></a>doOn 介绍</h2><blockquote><p>可以使用 doOn 方法来监听事件的生命周期，它会在每一次事件发送前被调用<br>同时它和 subscribe 一样，可以通过不同的 block 回调处理不同类型的 event。比如</p></blockquote><ul><li>do(onNext:) 方法就是在 subscribe(onNext:) 前调用</li><li>而 do(onCompleted:) 方法则会在 subscribe(onCompleted:) 前面调用</li></ul><h2 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>)</span><br><span class="line"> </span><br><span class="line">observable</span><br><span class="line">    .<span class="keyword">do</span>(onNext: &#123; element <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Intercepted Next："</span>, element)</span><br><span class="line">    &#125;, onError: &#123; error <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Intercepted Error："</span>, error)</span><br><span class="line">    &#125;, onCompleted: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Intercepted Completed"</span>)</span><br><span class="line">    &#125;, onDispose: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Intercepted Disposed"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(onNext: &#123; element <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(element)</span><br><span class="line">    &#125;, onError: &#123; error <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">    &#125;, onCompleted: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"completed"</span>)</span><br><span class="line">    &#125;, onDisposed: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"disposed"</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h1 id="Observable-的销毁（Dispose）"><a href="#Observable-的销毁（Dispose）" class="headerlink" title="Observable 的销毁（Dispose）"></a>Observable 的销毁（Dispose）</h1><h2 id="Observable-从创建到终结流程"><a href="#Observable-从创建到终结流程" class="headerlink" title="Observable 从创建到终结流程"></a>Observable 从创建到终结流程</h2><blockquote><p>一个 Observable 序列被创建出来后它不会马上就开始被激活从而发出 Event，而是要等到它被某个人订阅了才会激活它。<br>而 Observable 序列激活之后要一直等到它发出了 .error 或者 .completed 的 event 后，它才被终结</p></blockquote><h2 id="dispose-方法"><a href="#dispose-方法" class="headerlink" title="dispose() 方法"></a>dispose() 方法</h2><blockquote><p>除了 dispose() 方法之外，我们更经常用到的是一个叫 DisposeBag 的对象来管理多个订阅行为的销毁</p></blockquote><ul><li>以把一个 DisposeBag 对象看成一个垃圾袋，把用过的订阅行为都放进去</li><li>而这个 DisposeBag 就会在自己快要 dealloc 的时候，对它里面的所有订阅行为都调用 dispose() 方法</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">         </span><br><span class="line"><span class="comment">//第1个Observable，及其订阅</span></span><br><span class="line"><span class="keyword">let</span> observable1 = <span class="type">Observable</span>.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>)</span><br><span class="line">observable1.subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//第2个Observable，及其订阅</span></span><br><span class="line"><span class="keyword">let</span> observable2 = <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">observable2.subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-RxSwift-Grammar- 资料</title>
      <link href="/2017/12/15/Swift/RxSwift/Grammar/RxSwift-%E8%B5%84%E6%96%99/"/>
      <url>/2017/12/15/Swift/RxSwift/Grammar/RxSwift-%E8%B5%84%E6%96%99/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Grammar </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-RxSwift-UI控件的扩展</title>
      <link href="/2017/12/15/Swift/RxSwift/Grammar/%E5%9F%BA%E6%9C%ACUI%E6%8E%A7%E4%BB%B6%E7%9A%84%E6%89%A9%E5%B1%95/"/>
      <url>/2017/12/15/Swift/RxSwift/Grammar/%E5%9F%BA%E6%9C%ACUI%E6%8E%A7%E4%BB%B6%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h1 id="UITextField-UITextView"><a href="#UITextField-UITextView" class="headerlink" title="UITextField / UITextView"></a>UITextField / UITextView</h1><h2 id="监听多个UITextField"><a href="#监听多个UITextField" class="headerlink" title="监听多个UITextField"></a>监听多个UITextField</h2><blockquote><p>监听三个UITextField随便哪个的text变化了，都会引起代码执行，并且结果赋值到result的text</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> number1: <span class="type">UITextField</span>!</span><br><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> number2: <span class="type">UITextField</span>!</span><br><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> number3: <span class="type">UITextField</span>!</span><br><span class="line"></span><br><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> result: <span class="type">UILabel</span>!</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="type">Observable</span>.combineLatest(number1.rx.text.orEmpty, number2.rx.text.orEmpty, number3.rx.text.orEmpty) &#123; textValue1, textValue2, textValue3 -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">Int</span>(textValue1) ?? <span class="number">0</span>) + (<span class="type">Int</span>(textValue2) ?? <span class="number">0</span>) + (<span class="type">Int</span>(textValue3) ?? <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span>.description &#125;</span><br><span class="line">    .bindTo(result.rx.text)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单个UITextField变化监听"><a href="#单个UITextField变化监听" class="headerlink" title="单个UITextField变化监听"></a>单个UITextField变化监听</h2><blockquote><p>官方：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// also test two way binding</span></span><br><span class="line"><span class="keyword">let</span> textValue = <span class="type">Variable</span>(<span class="string">""</span>)</span><br><span class="line"><span class="number">_</span> = textField.rx.textInput &lt;-&gt; textValue</span><br><span class="line"></span><br><span class="line">textValue.asObservable()</span><br><span class="line">    .subscribe(onNext: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] x <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>?.debug(<span class="string">"UITextField text <span class="subst">\(x)</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><blockquote><p>例子：单个UITextField事件监听</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">usernameTF.rx.controlEvent([.editingDidBegin]) <span class="comment">//状态可以组合</span></span><br><span class="line"> .asObservable()</span><br><span class="line"> .subscribe(onNext: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">"begin edit"</span>)</span><br><span class="line"> &#125;).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h2 id="UITextField遇到键盘Next-Go按钮时，焦点的切换"><a href="#UITextField遇到键盘Next-Go按钮时，焦点的切换" class="headerlink" title="UITextField遇到键盘Next/Go按钮时，焦点的切换"></a>UITextField遇到键盘Next/Go按钮时，焦点的切换</h2><blockquote><p>这里有个小坑，如果usernameTF和passwordTF用了Observable.combineLatest然后订阅的话，你会发现下面的delegate代码没用了，在usernameTF点击Next/Go不能切换到passwordTF了</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">textFieldShouldReturn</span><span class="params">(<span class="number">_</span> textField: UITextField)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> textField == usernameTF &#123;</span><br><span class="line">        passwordTF.becomeFirstResponder()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        passwordTF.resignFirstResponder()</span><br><span class="line">        <span class="type">Log</span>(<span class="string">"view become"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>用事件监听即可，监听return key结束编辑的事件(editingDidEndOnExit)：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/* editingDidEndOnExit: UIControlEvents // 'return key' ending editing */</span></span><br><span class="line"></span><br><span class="line">usernameTF.rx.controlEvent(.editingDidEndOnExit).subscribe(onNext: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (<span class="number">_</span>) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>?.passwordTF.becomeFirstResponder()</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">passwordTF.rx.controlEvent(.editingDidEndOnExit).subscribe(onNext: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (<span class="number">_</span>) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>?.passwordTF.resignFirstResponder()</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h1 id="UITextView变化监听"><a href="#UITextView变化监听" class="headerlink" title="UITextView变化监听"></a>UITextView变化监听</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   / also test two way binding</span><br><span class="line"><span class="keyword">let</span> textViewValue = <span class="type">Variable</span>(<span class="string">""</span>)</span><br><span class="line"><span class="number">_</span> = textView.rx.textInput &lt;-&gt; textViewValue</span><br><span class="line"></span><br><span class="line">textViewValue.asObservable()</span><br><span class="line">    .subscribe(onNext: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] x <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>?.debug(<span class="string">"UITextView text <span class="subst">\(x)</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h1 id="UIButton-UIBarButtonItem"><a href="#UIButton-UIBarButtonItem" class="headerlink" title="UIButton / UIBarButtonItem"></a>UIButton / UIBarButtonItem</h1><h2 id="监听按钮的点击（touchUpInside）"><a href="#监听按钮的点击（touchUpInside）" class="headerlink" title="监听按钮的点击（touchUpInside）"></a>监听按钮的点击（touchUpInside）</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> doSomethingOutlet: <span class="type">UIButton</span>!</span><br><span class="line">    </span><br><span class="line">doSomethingOutlet.rx.tap</span><br><span class="line">    .subscribe(onNext: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span> </span><br><span class="line">        <span class="keyword">self</span>?.showAlert() <span class="comment">//这里self指vc</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><blockquote><p>也可以这样：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">button.rx.tap</span><br><span class="line">  .bindNext &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">self</span>?.openAppPreferences()</span><br><span class="line">  &#125;</span><br><span class="line">  .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h1 id="UISegmentedControl-UISwitch"><a href="#UISegmentedControl-UISwitch" class="headerlink" title="UISegmentedControl / UISwitch"></a>UISegmentedControl / UISwitch</h1><blockquote><p>监听状态切换</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// also test two way binding</span></span><br><span class="line"><span class="keyword">let</span> segmentedValue = <span class="type">Variable</span>(<span class="number">0</span>)</span><br><span class="line"><span class="number">_</span> = segmentedControl.rx.value &lt;-&gt; segmentedValue</span><br><span class="line"></span><br><span class="line">segmentedValue.asObservable()</span><br><span class="line">    .subscribe(onNext: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] x <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>?.debug(<span class="string">"UISegmentedControl value <span class="subst">\(x)</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// also test two way binding</span></span><br><span class="line"><span class="keyword">let</span> switchValue = <span class="type">Variable</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="number">_</span> = switcher.rx.value &lt;-&gt; switchValue</span><br><span class="line"></span><br><span class="line">switchValue.asObservable()</span><br><span class="line">    .subscribe(onNext: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] x <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>?.debug(<span class="string">"UISwitch value <span class="subst">\(x)</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h1 id="UIActivityIndicatorView"><a href="#UIActivityIndicatorView" class="headerlink" title="UIActivityIndicatorView"></a>UIActivityIndicatorView</h1><blockquote><p>状态指示器根据UISwitch的状态来决定是否显示旋转</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">switcher.rx.value</span><br><span class="line"> .bindTo(activityIndicator.rx.isAnimating)</span><br><span class="line"> .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h1 id="UISlider"><a href="#UISlider" class="headerlink" title="UISlider"></a>UISlider</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// also test two way binding</span></span><br><span class="line"><span class="keyword">let</span> sliderValue = <span class="type">Variable</span>&lt;<span class="type">Float</span>&gt;(<span class="number">1.0</span>)</span><br><span class="line"><span class="number">_</span> = slider.rx.value &lt;-&gt; sliderValue</span><br><span class="line"></span><br><span class="line">sliderValue.asObservable()</span><br><span class="line">    .subscribe(onNext: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] x <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>?.debug(<span class="string">"UISlider value <span class="subst">\(x)</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h1 id="UIDatePicker"><a href="#UIDatePicker" class="headerlink" title="UIDatePicker"></a>UIDatePicker</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// also test two way binding</span></span><br><span class="line"><span class="keyword">let</span> dateValue = <span class="type">Variable</span>(<span class="type">Date</span>(timeIntervalSince1970: <span class="number">0</span>))</span><br><span class="line"><span class="number">_</span> = datePicker.rx.date &lt;-&gt; dateValue</span><br><span class="line"></span><br><span class="line">dateValue.asObservable()</span><br><span class="line">    .subscribe(onNext: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] x <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>?.debug(<span class="string">"UIDatePicker date <span class="subst">\(x)</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h1 id="UIGestureRecognizer"><a href="#UIGestureRecognizer" class="headerlink" title="UIGestureRecognizer"></a>UIGestureRecognizer</h1><blockquote><p>手势回调，x是UIPanGestureRecognizer对象</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   mypan.rx.event</span><br><span class="line">.subscribe(onNext: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] x <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>?.debug(<span class="string">"UIGestureRecognizer event <span class="subst">\(x.state)</span>"</span>)</span><br><span class="line">    <span class="keyword">let</span> p = x.location(<span class="keyword">in</span>: x.view)</span><br><span class="line">    <span class="keyword">self</span>?.debug(<span class="string">"pan ges point: <span class="subst">\(p)</span>"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h1 id="CLLocationManager"><a href="#CLLocationManager" class="headerlink" title="CLLocationManager"></a>CLLocationManager</h1><blockquote><p>还有一堆didxxx方法，自己Command点进去看</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  manager.requestWhenInUseAuthorization()</span><br><span class="line"></span><br><span class="line">manager.rx.didUpdateLocations</span><br><span class="line">    .subscribe(onNext: &#123; x <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"rx.didUpdateLocations <span class="subst">\(x)</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="number">_</span> = manager.rx.didFailWithError</span><br><span class="line">    .subscribe(onNext: &#123; x <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"rx.didFailWithError <span class="subst">\(x)</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">manager.rx.didChangeAuthorizationStatus</span><br><span class="line">    .subscribe(onNext: &#123; status <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Authorization status <span class="subst">\(status)</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">    </span><br><span class="line">manager.startUpdatingLocation()</span><br></pre></td></tr></table></figure><h1 id="UITableView的扩展"><a href="#UITableView的扩展" class="headerlink" title="UITableView的扩展"></a>UITableView的扩展</h1><h2 id="单个section的情况"><a href="#单个section的情况" class="headerlink" title="单个section的情况"></a>单个section的情况</h2><blockquote><p>除了下面几个最常用的，还有itemDeselected、itemInserted、itemDeleted等等行为可以订阅，自己Command点进去看</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">SimpleTableViewExampleViewController</span> : <span class="title">ViewController</span>, <span class="title">UITableViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> tableView: <span class="type">UITableView</span>!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> items = <span class="type">Observable</span>.just(</span><br><span class="line">            (<span class="number">0</span>..&lt;<span class="number">20</span>).<span class="built_in">map</span> &#123; <span class="string">"<span class="subst">\($<span class="number">0</span>)</span>"</span> &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">//大概是对cellForRowAtIndexPath的封装</span></span><br><span class="line">        items</span><br><span class="line">            .bindTo(tableView.rx.items(cellIdentifier: <span class="string">"Cell"</span>, cellType: <span class="type">UITableViewCell</span>.<span class="keyword">self</span>)) &#123;</span><br><span class="line">                (row, element, cell) <span class="keyword">in</span></span><br><span class="line">                <span class="comment">//element 是 items[row]元素</span></span><br><span class="line">                cell.textLabel?.text = <span class="string">"<span class="subst">\(element)</span> @ row <span class="subst">\(row)</span>"</span></span><br><span class="line">            &#125;</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//点击某个cell触发, value 是 items[row]，类似的是tableView.rx.itemSelected，都是对didSelectRowAtIndexPath的封装</span></span><br><span class="line">        tableView.rx</span><br><span class="line">            .modelSelected(<span class="type">String</span>.<span class="keyword">self</span>)</span><br><span class="line">            .subscribe(onNext:  &#123; value <span class="keyword">in</span></span><br><span class="line">                <span class="type">DefaultWireframe</span>.presentAlert(<span class="string">"Tapped `<span class="subst">\(value)</span>`"</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//accessoryButtonTappedForRowWithIndexPath</span></span><br><span class="line">        tableView.rx</span><br><span class="line">            .itemAccessoryButtonTapped</span><br><span class="line">            .subscribe(onNext: &#123; indexPath <span class="keyword">in</span></span><br><span class="line">                <span class="type">DefaultWireframe</span>.presentAlert(<span class="string">"Tapped Detail @ <span class="subst">\(indexPath.section)</span>,<span class="subst">\(indexPath.row)</span>"</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多section的情况"><a href="#多section的情况" class="headerlink" title="多section的情况"></a>多section的情况</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">SimpleTableViewExampleSectionedViewController</span> : <span class="title">ViewController</span>, <span class="title">UITableViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> tableView: <span class="type">UITableView</span>!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> dataSource = <span class="type">RxTableViewSectionedReloadDataSource</span>&lt;<span class="type">SectionModel</span>&lt;<span class="type">String</span>, <span class="type">Double</span>&gt;&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> dataSource = <span class="keyword">self</span>.dataSource</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> items = <span class="type">Observable</span>.just([</span><br><span class="line">            <span class="type">SectionModel</span>(model: <span class="string">"First section"</span>, items: [</span><br><span class="line">                    <span class="number">11.0</span>,</span><br><span class="line">                    <span class="number">12.0</span>,</span><br><span class="line">                    <span class="number">13.0</span></span><br><span class="line">                ]),</span><br><span class="line">            <span class="type">SectionModel</span>(model: <span class="string">"Second section"</span>, items: [</span><br><span class="line">                    <span class="number">21.0</span>,</span><br><span class="line">                    <span class="number">22.0</span>,</span><br><span class="line">                    <span class="number">23.0</span></span><br><span class="line">                ]),</span><br><span class="line">            <span class="type">SectionModel</span>(model: <span class="string">"Third section"</span>, items: [</span><br><span class="line">                    <span class="number">31.0</span>,</span><br><span class="line">                    <span class="number">32.0</span>,</span><br><span class="line">                    <span class="number">33.0</span></span><br><span class="line">                ]),</span><br><span class="line">            ])</span><br><span class="line"></span><br><span class="line">        dataSource.configureCell = &#123; (<span class="number">_</span>, tv, indexPath, element) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> cell = tv.dequeueReusableCell(withIdentifier: <span class="string">"Cell"</span>)!</span><br><span class="line">            cell.textLabel?.text = <span class="string">"<span class="subst">\(element)</span> @ row <span class="subst">\(indexPath.row)</span>"</span></span><br><span class="line">            <span class="keyword">return</span> cell</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        items</span><br><span class="line">            .bindTo(tableView.rx.items(dataSource: dataSource))</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">        tableView.rx</span><br><span class="line">            .itemSelected</span><br><span class="line">            .<span class="built_in">map</span> &#123; indexPath <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">return</span> (indexPath, dataSource[indexPath])</span><br><span class="line">            &#125;</span><br><span class="line">            .subscribe(onNext: &#123; indexPath, model <span class="keyword">in</span></span><br><span class="line">                <span class="type">DefaultWireframe</span>.presentAlert(<span class="string">"Tapped `<span class="subst">\(model)</span>` @ <span class="subst">\(indexPath)</span>"</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">        tableView.rx</span><br><span class="line">            .setDelegate(<span class="keyword">self</span>)</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, viewForHeaderInSection section: Int)</span></span> -&gt; <span class="type">UIView</span>? &#123;</span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: <span class="type">CGRect</span>.zero)</span><br><span class="line">        label.text = dataSource[section].model</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, heightForHeaderInSection section: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// to prevent swipe to delete behavior</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, editingStyleForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCellEditingStyle</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .<span class="keyword">none</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.darkhandz.com/2017/02/06/%E5%AD%A6%E4%B9%A0RxSwift%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-RxSwift-创建Observable序列</title>
      <link href="/2017/12/15/Swift/RxSwift/Grammar/%E5%88%9B%E5%BB%BAObservable%E5%BA%8F%E5%88%97/"/>
      <url>/2017/12/15/Swift/RxSwift/Grammar/%E5%88%9B%E5%BB%BAObservable%E5%BA%8F%E5%88%97/</url>
      <content type="html"><![CDATA[<ul><li><a href="#①just">①just</a></li><li><a href="#②of">②of</a></li><li><a href="#③from">③from</a></li><li><a href="#④empty">④empty</a></li><li><a href="#⑤never">⑤never</a></li><li><a href="#⑥error">⑥error</a></li><li><a href="#⑦range">⑦range</a></li><li><a href="#⑧repeatElement">⑧repeatElement</a></li><li><a href="#⑨generatet">⑨generate</a></li><li><a href="#⑩create">⑩create</a></li><li><a href="#⑪deferredt">⑪deferred</a></li><li><a href="#⑫intervalt">⑫interval</a></li><li><a href="#⑬timer">⑬timer</a></li></ul><p><span id="①just"></span></p><h1 id="①just"><a href="#①just" class="headerlink" title="①just"></a>①just</h1><blockquote><p>just() 方法<br>该方法通过传入一个默认值来初始化<br>只创建包含一个元素的序列。换言之，只发送一个值和 .Completed：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.just(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><span id="②of"></span></p><h1 id="②of"><a href="#②of" class="headerlink" title="②of"></a>②of</h1><blockquote><p>通过一组元素创建一个序列<br>该方法可以接受可变数量的参数（必需要是同类型的）</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>)</span><br></pre></td></tr></table></figure><p><span id="③from"></span></p><h1 id="③from"><a href="#③from" class="headerlink" title="③from"></a>③from</h1><blockquote><p>需要一个数组参数<br>数据里的元素就会被当做这个 Observable 所发出 event 携带的数据内容，最终效果同上面 of 样例是一样的</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>.from([<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>])</span><br></pre></td></tr></table></figure><p><span id="④empty"></span></p><h1 id="④empty"><a href="#④empty" class="headerlink" title="④empty"></a>④empty</h1><blockquote><p>创建一个空内容的 Observable 序列</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.empty()</span><br></pre></td></tr></table></figure><p><span id="⑤never">⑤never</span></p><h1 id="⑤never"><a href="#⑤never" class="headerlink" title="⑤never"></a>⑤never</h1><blockquote><p>创建一个永远不会发出 Event（也不会终止）的 Observable 序列</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.never()</span><br></pre></td></tr></table></figure><p><span id="⑥error"></span></p><h1 id="⑥error"><a href="#⑥error" class="headerlink" title="⑥error"></a>⑥error</h1><blockquote><p>创建一个不做任何操作，而是直接发送一个错误的 Observable 序列</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MyError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">A</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">B</span></span><br><span class="line">&#125;</span><br><span class="line">         </span><br><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.error(<span class="type">MyError</span>.<span class="type">A</span>)</span><br></pre></td></tr></table></figure><p><span id="⑦range"></span></p><h1 id="⑦range"><a href="#⑦range" class="headerlink" title="⑦range"></a>⑦range</h1><blockquote><p>通过指定起始和结束数值，创建一个以这个范围内所有值作为初始值的 Observable 序列。<br>下面样例中，两种方法创建的 Observable 序列都是一样的</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用range()</span></span><br><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>.range(start: <span class="number">1</span>, <span class="built_in">count</span>: <span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用of()</span></span><br><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><span id="⑧repeatElement"></span></p><h1 id="⑧repeatElement"><a href="#⑧repeatElement" class="headerlink" title="⑧repeatElement"></a>⑧repeatElement</h1><blockquote><p>法创建一个可以无限发出给定元素的 Event 的 Observable 序列（永不终止）</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>.repeatElement(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><span id="⑨generate"></span></p><p>#⑨generate</p><blockquote><p>该方法创建一个只有当提供的所有的判断条件都为 true 的时候，才会给出动作的 Observable 序列<br>两种方法创建的 Observable 序列都是一样的</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用generate()方法</span></span><br><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>.generate(</span><br><span class="line">    initialState: <span class="number">0</span>,</span><br><span class="line">    condition: &#123; $<span class="number">0</span> &lt;= <span class="number">10</span> &#125;,</span><br><span class="line">    iterate: &#123; $<span class="number">0</span> + <span class="number">2</span> &#125;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用of()方法</span></span><br><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>.of(<span class="number">0</span> , <span class="number">2</span> ,<span class="number">4</span> ,<span class="number">6</span> ,<span class="number">8</span> ,<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><span id="⑩create"></span></p><p>#⑩create</p><blockquote><p>接受一个 block 形式的参数，任务是对每一个过来的订阅进行处理<br>方便演示，这里增加了订阅相关代码</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//这个block有一个回调参数observer就是订阅这个Observable对象的订阅者</span><br><span class="line">//当一个订阅者订阅这个Observable对象的时候，就会将订阅者作为参数传入这个block来执行一些内容</span><br><span class="line">let observable = Observable&lt;String&gt;.create&#123;observer in</span><br><span class="line">    //对订阅者发出了.next事件，且携带了一个数据&quot;hangge.com&quot;</span><br><span class="line">    observer.onNext(&quot;hangge.com&quot;)</span><br><span class="line">    //对订阅者发出了.completed事件</span><br><span class="line">    observer.onCompleted()</span><br><span class="line">    //因为一个订阅行为会有一个Disposable类型的返回值，所以在结尾一定要returen一个Disposable</span><br><span class="line">    return Disposables.create()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//订阅测试</span><br><span class="line">observable.subscribe &#123;</span><br><span class="line">    print($0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//打印</span><br><span class="line"> next(hangge.com)</span><br><span class="line"> completed</span><br></pre></td></tr></table></figure><p><span id="⑪deferred"></span></p><p>#⑪deferred</p><blockquote><p>该个方法相当于是创建一个 Observable 工厂，通过传入一个 block 来执行延迟 Observable 序列创建的行为，而这个 block 里就是真正的实例化序列对象的地方</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于标记是奇数、还是偶数</span></span><br><span class="line"><span class="keyword">var</span> isOdd = <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用deferred()方法延迟Observable序列的初始化，通过传入的block来实现Observable序列的初始化并且返回。</span></span><br><span class="line"><span class="keyword">let</span> factory : <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; = <span class="type">Observable</span>.deferred &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//让每次执行这个block时候都会让奇、偶数进行交替</span></span><br><span class="line">    isOdd = !isOdd</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//根据isOdd参数，决定创建并返回的是奇数Observable、还是偶数Observable</span></span><br><span class="line">    <span class="keyword">if</span> isOdd &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span> ,<span class="number">7</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Observable</span>.of(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//第1次订阅测试</span></span><br><span class="line">factory.subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(isOdd)</span>"</span>, event)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//第2次订阅测试</span></span><br><span class="line">factory.subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(isOdd)</span>"</span>, event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print</span></span><br><span class="line"><span class="literal">false</span> next(<span class="number">2</span>)</span><br><span class="line"><span class="literal">false</span> next(<span class="number">4</span>)</span><br><span class="line"><span class="literal">false</span> next(<span class="number">6</span>)</span><br><span class="line"><span class="literal">false</span> next(<span class="number">8</span>)</span><br><span class="line"><span class="literal">false</span> completed</span><br><span class="line"><span class="literal">true</span> next(<span class="number">1</span>)</span><br><span class="line"><span class="literal">true</span> next(<span class="number">3</span>)</span><br><span class="line"><span class="literal">true</span> next(<span class="number">5</span>)</span><br><span class="line"><span class="literal">true</span> next(<span class="number">7</span>)</span><br><span class="line"><span class="literal">true</span> completed</span><br></pre></td></tr></table></figure><p><span id="⑫interval"></span></p><p>#⑫interval</p><blockquote><p>创建的 Observable 序列每隔一段设定的时间，会发出一个索引数的元素。而且它会一直发送下去<br>创建的 Observable 序列每隔一段设定的时间，会发出一个索引数的元素。而且它会一直发送下去</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.interval(<span class="number">1</span>, scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">observable.subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line">next(<span class="number">0</span>)</span><br><span class="line">next(<span class="number">1</span>)</span><br><span class="line">next(<span class="number">2</span>)</span><br><span class="line">next(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><span id="⑬timer"></span></p><h1 id="⑬timer"><a href="#⑬timer" class="headerlink" title="⑬timer"></a>⑬timer</h1><blockquote><p>这个方法有两种用法，一种是创建的 Observable 序列在经过设定的一段时间后，产生唯一的一个元素</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5秒种后发出唯一的一个元素0</span></span><br><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.timer(<span class="number">5</span>, scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">observable.subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line">next(<span class="number">0</span>)</span><br><span class="line">competed</span><br></pre></td></tr></table></figure><blockquote><p>另一种是创建的 Observable 序列在经过设定的一段时间后，每隔一段时间产生一个元素</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//延时5秒种后，每隔1秒钟发出一个元素</span></span><br><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.timer(<span class="number">5</span>, period: <span class="number">1</span>, scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">observable.subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line">next(<span class="number">0</span>)</span><br><span class="line">next(<span class="number">1</span>)</span><br><span class="line">next(<span class="number">2</span>)</span><br><span class="line">next(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-RxSwift-简介以及简单学习使用</title>
      <link href="/2017/12/15/Swift/RxSwift/Grammar/%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/12/15/Swift/RxSwift/Grammar/%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="Swift-RxSwift-简介以及简单学习使用"><a href="#Swift-RxSwift-简介以及简单学习使用" class="headerlink" title="Swift-RxSwift-简介以及简单学习使用"></a>Swift-RxSwift-简介以及简单学习使用</h1><blockquote><p><a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Why.md" target="_blank" rel="noopener">RxSwift 项目文档中 Why</a> 已有详细介绍</p></blockquote><h2 id="Bindings"><a href="#Bindings" class="headerlink" title="Bindings"></a>Bindings</h2><blockquote><p>[RxWhy] -&gt; [Bindings] -&gt; [BindingsViewController.swift]</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.combineLatest(firstName.rx_text, lastName.rx_text) &#123; $<span class="number">0</span> + <span class="string">" "</span> + $<span class="number">1</span> &#125; <span class="comment">// ①</span></span><br><span class="line">          .<span class="built_in">map</span> &#123; <span class="string">"Greeting <span class="subst">\($<span class="number">0</span>)</span>"</span> &#125;                                             <span class="comment">// ②</span></span><br><span class="line">          .bindTo(greetingLabel.rx_text)                                        <span class="comment">// ③</span></span><br></pre></td></tr></table></figure><ul><li>将 firstName 和 lastName 的 text 属性结合起来，并进行合并处理，也就是 $0 + “ “ + $1 这部分，用空格将两个值合并起来作为结果传递给后面使用</li><li>使用 map 的方法，将上一步得到值前面加上一个 Greeting ，并将该值传递给后面使用</li><li>bindTo 就是绑定，将上一步的值绑定到 greetingLabel 的 text</li></ul><blockquote><p>代码就是实时的执行</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">greetingLabel.text = <span class="string">"Greeting "</span> + firstName.text + <span class="string">" "</span> + lastName.text</span><br></pre></td></tr></table></figure><ul><li>要求是实时</li><li>每当 fisrtName.text 或者 lastName.text 改变时， greetingLabel.text 都要随之改变</li></ul><h2 id="ContentOffset"><a href="#ContentOffset" class="headerlink" title="ContentOffset"></a>ContentOffset</h2><blockquote><p>经常通过 delegate 处理 scrollView 的 contentOffset 变化问题</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidScroll</span><span class="params">(scrollView: UIScrollView)</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.title = <span class="string">"contentOffset.x = <span class="subst">\(scrollView.contentOffset.y)</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可能就和关联的逻辑分家了，内聚性啊…而且多个 scrollView ，还要做额外的判断处理，复杂性可想而知<br>也有写过通过 closure 来解决的，其实可以认为 Rx 自带了这些功能（而且更强大<br>[RxWhy] -&gt; [ContentOffset] -&gt; [ContentOffsetViewController.swift]<br>Note: 在使用了 rx_contentOffset 后，最好不要去更改 delegate<br>同样 button 也有类似的功能</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">tableView.rx_contentOffset</span><br><span class="line">  .<span class="built_in">map</span> &#123; $<span class="number">0</span>.y &#125;</span><br><span class="line">  .subscribeNext &#123; [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">self</span>.title = <span class="string">"contentOffset.x = <span class="subst">\($<span class="number">0</span>)</span>"</span></span><br><span class="line">  &#125;.addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><h2 id="Tap"><a href="#Tap" class="headerlink" title="Tap"></a>Tap</h2><blockquote><p>button 的点击事件是一个很棘手的问题了，建立一个 target ，同时还使用的带字符串的 Select，button 的点击也和响应逻辑分家了<br>处理方式会有两个问题</p></blockquote><ul><li>使用了带 String 的 Target</li><li>点击的关联事件代码和处理的逻辑分开了</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">button.addTarget(<span class="keyword">self</span>, action: <span class="string">"tapButton"</span>, forControlEvents: .<span class="type">TouchDragInside</span>)</span><br></pre></td></tr></table></figure><blockquote><p>Rx 已经提供了 closure 的功能</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">button.rx_tap</span><br><span class="line"> .subscribeNext &#123;</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">"Tap"</span>)</span><br><span class="line"> &#125;.addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><p><a href="http://t.swift.gg/d/2-rxswift" target="_blank" rel="noopener">资料来源</a></p>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-Grammar-Observables-02</title>
      <link href="/2017/12/15/Swift/RxSwift/Grammar/02-Observables/"/>
      <url>/2017/12/15/Swift/RxSwift/Grammar/02-Observables/</url>
      <content type="html"><![CDATA[<h1 id="①概念"><a href="#①概念" class="headerlink" title="①概念"></a>①概念</h1><h2 id="❶Observable"><a href="#❶Observable" class="headerlink" title="❶Observable"></a>❶Observable<t></t></h2><ul><li>Observable<t> 这个类就是 Rx 框架的基础，称为可观察序列。它的作用就是可以异步地产生一系列的 Event（事件），即一个 Observable<t> 对象会随着时间推移不定期地发出 event(element : T) 这样一个东西</t></t></li><li>Event 还可以携带数据，它的泛型 <t> 就是用来指定这个 Event 携带的数据的类型</t></li><li>每一个Observable的实例都是一个序列</li><li>Observable序列相比于Swift序列的关键优势点在于它能够异步地接收元素</li><li>有了可观察序列，我们还需要有一个 Observer（订阅者）来订阅它，这样这个订阅者才能收到 Observable<t> 不时发出的 Event</t></li></ul><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>Observable(ObservableType)</td><td>等效于Sequence</td><td></td></tr><tr><td>observableType.subscribe(_:)</td><td>方法等效于Sequence.makeIterator()</td><td></td></tr><tr><td>ObservableType.subscribe(_:)</td><td>接收一个观察者ObserverType参数,它将被订阅自动接收由可观察到的序列事件和元素，而不是在返回的生成器上手动调用next()</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><ul><li>如果一个Observable发出一个next事件(Event.next(Element)),它还能够继续发出更多的事件</li><li>如果一个Observable发出一个error事件(Event.error(ErrorType))或者一个completed事件(Event.completed)，那么这个Observable序列就不能给订阅者发送其他的事件了</li></ul><h2 id="❷Event"><a href="#❷Event" class="headerlink" title="❷Event"></a>❷Event</h2><blockquote><p>事件 Event 的定义</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Event</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/// Next element is produced.</span></span><br><span class="line">    <span class="keyword">case</span> next(<span class="type">Element</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/// Sequence terminated with an error.</span></span><br><span class="line">    <span class="keyword">case</span> error(<span class="type">Swift</span>.<span class="type">Error</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/// Sequence completed successfully.</span></span><br><span class="line">    <span class="keyword">case</span> completed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Event 就是一个枚举，也就是说 一个 Observable 是可以发出 3 种不同类型的 Event 事件</p></blockquote><h3 id="next"><a href="#next" class="headerlink" title="next"></a>next</h3><blockquote><p>next：next 事件就是那个可以携带数据 <t> 的事件，可以说它就是一个“最正常”的事件</t></p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>--<span class="number">2</span>--<span class="number">3</span>---&gt;</span><br></pre></td></tr></table></figure><h3 id="error"><a href="#error" class="headerlink" title="error"></a>error</h3><blockquote><p>error：error 事件表示一个错误，它可以携带具体的错误内容，一旦 Observable 发出了 error event，则这个 Observable 就等于终止了，以后它再也不会发出 event 事件了</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-------1-----2------ x</span><br></pre></td></tr></table></figure><h3 id="completed"><a href="#completed" class="headerlink" title="completed"></a>completed</h3><blockquote><p>completed：completed 事件表示 Observable 发出的事件正常地结束了，跟 error 一样，一旦 Observable 发出了 completed event，则这个 Observable 就等于终止了，以后它再也不会发出 event 事件了</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                            </span><br><span class="line">------1 ------2--------3-------|</span><br></pre></td></tr></table></figure><h2 id="❸Observable-与-Sequence比较"><a href="#❸Observable-与-Sequence比较" class="headerlink" title="❸Observable 与 Sequence比较"></a>❸Observable 与 Sequence比较</h2><blockquote><p>可以把每一个 Observable 的实例想象成于一个 Swift 中的 Sequence</p></blockquote><ul><li>即一个 Observable（ObservableType）相当于一个序列 Sequence（SequenceType）</li><li>ObservableType.subscribe(_:) 方法其实就相当于 SequenceType.generate()</li></ul><blockquote><p>区别</p></blockquote><ul><li>Swift 中的 SequenceType 是同步的循环，而 Observable 是异步的</li><li>Observable 对象会在有任何 Event 时候，自动将 Event 作为一个参数通过 ObservableType.subscribe(_:) 发出，并不需要使用 next 方法</li></ul>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>RxSwift-UIKit-UILabel-响应式扩展-01</title>
      <link href="/2017/12/15/Swift/RxSwift/UIKit/UILabel-01/"/>
      <url>/2017/12/15/Swift/RxSwift/UIKit/UILabel-01/</url>
      <content type="html"><![CDATA[<h1 id="RxSwift"><a href="#RxSwift" class="headerlink" title="RxSwift"></a>RxSwift</h1><ul><li>RxSwift 是一个用于与 Swift 语言交互的框架，但它只是基础，并不能用来进行用户交互、网络请求等。</li></ul><ul><li>而 RxCocoa 是让 Cocoa APIs 更容易使用响应式编程的一个框架。RxCocoa 能够让我们方便地进行响应式网络请求、响应式的用户交互、绑定数据模型到 UI 控件等等。而且大多数的 UIKit 控件都有响应式扩展，它们都是通过 rx 属性进行使用</li></ul><h1 id="UILabel"><a href="#UILabel" class="headerlink" title="UILabel"></a>UILabel</h1><blockquote><p>disposeBag</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br></pre></td></tr></table></figure><blockquote><p>UI- 显示时间lab</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span>  <span class="keyword">var</span> timeLabel: <span class="type">UILabel</span>  = &#123;</span><br><span class="line">    <span class="keyword">let</span> timeLabel = <span class="type">UILabel</span>()</span><br><span class="line">    timeLabel.frame = <span class="type">CGRect</span>(x:<span class="number">30</span>,y:<span class="number">40</span>,width:<span class="number">300</span>,height:<span class="number">111</span>)</span><br><span class="line">    <span class="keyword">return</span> timeLabel</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><blockquote><p>显示彩色时间lab</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span>  <span class="keyword">var</span> timeColorLabel: <span class="type">UILabel</span>  = &#123;</span><br><span class="line">    <span class="keyword">let</span> timeColorLabel = <span class="type">UILabel</span>()</span><br><span class="line">    timeColorLabel.frame = <span class="type">CGRect</span>(x:<span class="number">30</span>,y:<span class="number">40</span>+<span class="number">150</span>,width:<span class="number">300</span>,height:<span class="number">111</span>)</span><br><span class="line">    <span class="keyword">return</span> timeColorLabel</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h1 id="功能主要实现"><a href="#功能主要实现" class="headerlink" title="功能主要实现"></a>功能主要实现</h1><blockquote><p>UI- 添加UI</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">view.addSubview(timeLabel)</span><br></pre></td></tr></table></figure><blockquote><p>把时间弄到lab上显示<br>创建一个计时器（每0.1秒发送一个索引数）</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> timer = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.interval(<span class="number">0.1</span>, scheduler: <span class="type">MainScheduler</span>.instance)  </span><br><span class="line">``` </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&gt;已过去的时间格式化成想要的字符串，并绑定到label上</span><br><span class="line"></span><br><span class="line">```swift </span><br><span class="line">   <span class="comment">//普通文本     </span></span><br><span class="line">    timer.<span class="built_in">map</span>&#123;(<span class="type">String</span>(format: <span class="string">"过去多少时间:%0.2d:%0.2d.%0.1d"</span>,</span><br><span class="line">                      arguments:[($<span class="number">0</span> / <span class="number">600</span>) % <span class="number">600</span>,</span><br><span class="line">                                 ($<span class="number">0</span> % <span class="number">600</span>) / <span class="number">10</span>,</span><br><span class="line">                                 $<span class="number">0</span> % <span class="number">10</span>]))&#125;</span><br><span class="line">         .bind(to: timeLabel.rx.text)</span><br><span class="line">         .disposed(by: disposeBag)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">   <span class="comment">//MARK:UI-彩色lab</span></span><br><span class="line">    view.addSubview(timeColorLabel)</span><br><span class="line">    timer.<span class="built_in">map</span>(formatTimeInterval)</span><br><span class="line">        .bind(to: timeColorLabel.rx.attributedText)</span><br><span class="line">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><blockquote><p>将数字转成对应的富文本</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatTimeInterval</span><span class="params">(ms: NSInteger)</span></span> -&gt; <span class="type">NSMutableAttributedString</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> string = <span class="type">String</span>(format: <span class="string">"过去多少时间%0.2d:%0.2d.%0.1d"</span>,</span><br><span class="line">                        arguments: [(ms / <span class="number">600</span>) % <span class="number">600</span>,</span><br><span class="line">                                    (ms % <span class="number">600</span> ) / <span class="number">10</span>,</span><br><span class="line">                                    ms % <span class="number">10</span>])</span><br><span class="line">    <span class="comment">//富文本设置</span></span><br><span class="line">    <span class="keyword">let</span> attibuteString = <span class="type">NSMutableAttributedString</span>(string: string)</span><br><span class="line">    <span class="comment">//从文本0开始6个字符字体HelveticaNeue-Bold,16号</span></span><br><span class="line">    attibuteString.addAttributes([<span class="type">NSAttributedStringKey</span>.font : <span class="type">UIFont</span>(name: <span class="string">"HelveticaNeue-Bold"</span>,</span><br><span class="line">                                                                      size: <span class="number">16</span>)!],</span><br><span class="line">                                 range:  <span class="type">NSMakeRange</span>(<span class="number">0</span>, <span class="number">5</span>))</span><br><span class="line">    <span class="comment">//设置字体颜色</span></span><br><span class="line">    attibuteString.addAttributes([<span class="type">NSAttributedStringKey</span>.foregroundColor : <span class="type">UIColor</span>.white],</span><br><span class="line">                                 range: <span class="type">NSMakeRange</span>(<span class="number">0</span>,<span class="number">5</span>))</span><br><span class="line">    <span class="comment">//设置文字背景颜色</span></span><br><span class="line">    attibuteString.addAttributes([<span class="type">NSAttributedStringKey</span>.backgroundColor : <span class="type">UIColor</span>.orange],</span><br><span class="line">                                 range: <span class="type">NSMakeRange</span>(<span class="number">0</span>,<span class="number">5</span>))</span><br><span class="line">    <span class="keyword">return</span> attibuteString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p><img src="http://ozr735s7e.bkt.clouddn.com/Rxswift-uilabel-01.gif" alt="1"></p>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift-基本介绍&amp;安装配置-01</title>
      <link href="/2017/12/15/Swift/RxSwift/Grammar/01-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D&amp;%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/12/15/Swift/RxSwift/Grammar/01-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D&amp;%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>#Rx 介绍</p><h2 id="Rx"><a href="#Rx" class="headerlink" title="Rx"></a>Rx</h2><ul><li>Rx 是 ReactiveX 的缩写，简单来说就是基于异步 Event（事件）序列的响应式编程</li><li>Rx 可以简化异步编程方法，并提供更优雅的数据绑定。让我们可以时刻响应新的数据同时顺序地处理它们</li></ul><h2 id="Rx-库"><a href="#Rx-库" class="headerlink" title="Rx 库"></a>Rx 库</h2><ul><li>Rx 本身可以说是一种跨平台的标准，它有自己的社区论坛，不管是 web 还是移动开发，都能用 Rx 的思维和方法来完成你的工作</li><li>作为一种跨平台标准，目前已经有许多基于不同开发语言的 Rx 的库。除了我后面会着重介绍的 RxSwift 之外，还有 RxJava, RxJS, RxKotlin, Rx.NET…等等</li><li>这些 Rx 库虽然用的语言不同，但它们之间其实都是相通的，都有相同的 API。所以说如果以后你使用别的语言做其他的方面的开发，同样是可以使用相同的思维甚至相同的方法接口（除了语言不同）来编程</li></ul><p>##Rx 主页</p><ul><li>如果想了解整个 Rx 大家庭的成员，<a href="http://reactivex.io" target="_blank" rel="noopener">可以访问它的主页</a></li></ul><h1 id="RxSwift-介绍"><a href="#RxSwift-介绍" class="headerlink" title="RxSwift 介绍"></a>RxSwift 介绍</h1><h2 id="RxSwift-的作用"><a href="#RxSwift-的作用" class="headerlink" title="RxSwift 的作用"></a>RxSwift 的作用</h2><blockquote><p>经常需要检测某些值的变化（比如：textFiled 输入值的变化、数据请求完成或失败的变化），然后进行相应的处理</p></blockquote><ul><li>过去针对不同的情况，我们需要采用不同的事件传递方法去处理，比如：delegate、notifinotion、target-action、KVO 等等</li><li>而 RectiveX 机制（由 RxSwift 实现）的出现，让程序里的事件传递响应方法做到统一。将之前那些常用的事件传递方法（比如：delegate、notification、target-action 等等），全部替换成 Rx 的“信号链”方式</li><li>如果使用的是 MVVM 开发模式的话，通过 RxSwift 可以获得更加方便的数据绑定的方法，使得 MVVM 开发更加如虎添翼</li></ul><h2 id="RxSwift-的安装与配置"><a href="#RxSwift-的安装与配置" class="headerlink" title="RxSwift 的安装与配置"></a>RxSwift 的安装与配置</h2><blockquote><p><a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">GitHub 上下载</a><br>或 cocopods 导入</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> RxCocoa</span><br></pre></td></tr></table></figure><h2 id="RxSwift-与-RxCocoa"><a href="#RxSwift-与-RxCocoa" class="headerlink" title="RxSwift 与 RxCocoa"></a>RxSwift 与 RxCocoa</h2><ul><li>RxSwift：它只是基于 Swift 语言的 Rx 标准实现接口库，所以 RxSwift 里不包含任何 Cocoa 或者 UI 方面的类</li><li>RxCocoa：是基于 RxSwift 针对于 iOS 开发的一个库，它通过 Extension 的方法给原生的比如 UI 控件添加了 Rx 的特性，使得我们更容易订阅和响应这些控件的事件</li></ul><h1 id="两种编程方式的比较样例"><a href="#两种编程方式的比较样例" class="headerlink" title="两种编程方式的比较样例"></a>两种编程方式的比较样例</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><blockquote><p>以最常见的 tableView 数据展示功能为例作为演示。后面分别使用传统写法，以及使用 RxSwift 响应式写法来实现</p></blockquote><ul><li>表格中显示的是歌曲信息（歌名，以及歌手）</li><li>点击选中任意一个单元格，在控制台中打印出对应的歌曲信息</li></ul><p><img src="" alt="001"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote><p>首先我们创建一个 Music 的结构体，用来保存歌曲名称、歌手名字。此外它还遵循 CustomStringConvertible 协议，方便我们输出调试</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//歌曲结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Music</span> </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> name: <span class="type">String</span>   <span class="comment">//歌名</span></span><br><span class="line">        <span class="keyword">let</span> singer: <span class="type">String</span> <span class="comment">//演唱者</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">init</span>(name: <span class="type">String</span>, singer: <span class="type">String</span>)&#123;</span><br><span class="line">            <span class="keyword">self</span>.name = name</span><br><span class="line">            <span class="keyword">self</span>.singer = singer</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Music</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"name:<span class="subst">\(name)</span>  singer:<span class="subst">\(singer)</span>"</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传统式编程"><a href="#传统式编程" class="headerlink" title="传统式编程"></a>传统式编程</h2><blockquote><p>ViewModel</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"> </span><br><span class="line"><span class="comment">//歌曲列表数据源</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MusicListViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> data = [</span><br><span class="line">        <span class="type">Music</span>(name: <span class="string">"无条件"</span>, singer: <span class="string">"陈奕迅"</span>),</span><br><span class="line">        <span class="type">Music</span>(name: <span class="string">"你曾是少年"</span>, singer: <span class="string">"S.H.E"</span>),</span><br><span class="line">        <span class="type">Music</span>(name: <span class="string">"从前的我"</span>, singer: <span class="string">"陈洁仪"</span>),</span><br><span class="line">        <span class="type">Music</span>(name: <span class="string">"在木星"</span>, singer: <span class="string">"朴树"</span>),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>视图控制器代码（ViewController.swift</p></blockquote><ul><li>设置 UITableView 的委托，并让视图控制器实现 UITableViewDataSource 和 UITableViewDelegate 协议，及相关的协议方法</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//tableView对象</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> tableView: <span class="type">UITableView</span>!</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//歌曲列表数据源</span></span><br><span class="line">    <span class="keyword">let</span> musicListViewModel = <span class="type">MusicListViewModel</span>()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//设置代理</span></span><br><span class="line">        tableView.dataSource = <span class="keyword">self</span></span><br><span class="line">        tableView.delegate = <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDataSource</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回单元格数量</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> musicListViewModel.data.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//返回对应的单元格</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span></span><br><span class="line">        -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"musicCell"</span>)!</span><br><span class="line">        <span class="keyword">let</span> music = musicListViewModel.data[indexPath.row]</span><br><span class="line">        cell.textLabel?.text = music.name</span><br><span class="line">        cell.detailTextLabel?.text = music.singer</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">//单元格点击</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, didSelectRowAt indexPath: IndexPath)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"你选中的歌曲信息【<span class="subst">\(musicListViewModel.data[indexPath.row])</span>】"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RxSwift-进行改造（响应式编程）"><a href="#RxSwift-进行改造（响应式编程）" class="headerlink" title="RxSwift 进行改造（响应式编程）"></a>RxSwift 进行改造（响应式编程）</h2><blockquote><p>ViewModel </p></blockquote><ul><li>data 属性变成一个可观察序列对象（Observable Squence），而对象当中的内容和我们之前在数组当中所包含的内容是完全一样的</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"> </span><br><span class="line"><span class="comment">//歌曲列表数据源</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MusicListViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="type">Observable</span>.just([</span><br><span class="line">        <span class="type">Music</span>(name: <span class="string">"无条件"</span>, singer: <span class="string">"陈奕迅"</span>),</span><br><span class="line">        <span class="type">Music</span>(name: <span class="string">"你曾是少年"</span>, singer: <span class="string">"S.H.E"</span>),</span><br><span class="line">        <span class="type">Music</span>(name: <span class="string">"从前的我"</span>, singer: <span class="string">"陈洁仪"</span>),</span><br><span class="line">        <span class="type">Music</span>(name: <span class="string">"在木星"</span>, singer: <span class="string">"朴树"</span>),</span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="视图控制器代码（ViewController-swift）"><a href="#视图控制器代码（ViewController-swift）" class="headerlink" title="视图控制器代码（ViewController.swift）"></a>视图控制器代码（ViewController.swift）</h2><ul><li>DisposeBag：作用是 Rx 在视图控制器或者其持有者将要销毁的时候，自动释法掉绑定在它上面的资源。它是通过类似“订阅处置机制”方式实现（类似于 NotificationCenter 的 removeObserver）。</li><li>rx.items(cellIdentifier:）:这是 Rx 基于 cellForRowAt 数据源方法的一个封装。传统方式中我们还要有个 numberOfRowsInSection 方法，使用 Rx 后就不再需要了（Rx 已经帮我们完成了相关工作）。</li><li>rx.modelSelected： 这是 Rx 基于 UITableView 委托回调方法 didSelectRowAt 的一个封装。</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> RxCocoa</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//tableView对象</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> tableView: <span class="type">UITableView</span>!</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//歌曲列表数据源</span></span><br><span class="line">    <span class="keyword">let</span> musicListViewModel = <span class="type">MusicListViewModel</span>()</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//负责对象销毁</span></span><br><span class="line">    <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//将数据源数据绑定到tableView上</span></span><br><span class="line">        musicListViewModel.data</span><br><span class="line">            .bind(to: tableView.rx.items(cellIdentifier:<span class="string">"musicCell"</span>)) &#123; <span class="number">_</span>, music, cell <span class="keyword">in</span></span><br><span class="line">                cell.textLabel?.text = music.name</span><br><span class="line">                cell.detailTextLabel?.text = music.singer</span><br><span class="line">            &#125;.disposed(by: disposeBag)</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//tableView点击响应</span></span><br><span class="line">        tableView.rx.modelSelected(<span class="type">Music</span>.<span class="keyword">self</span>).subscribe(onNext: &#123; music <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"你选中的歌曲信息【<span class="subst">\(music)</span>】"</span>)</span><br><span class="line">        &#125;).disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxSwift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Grammar </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UIImagePickerController</title>
      <link href="/2017/12/14/Swift/Swift/UIKit/UIImagePickerController/"/>
      <url>/2017/12/14/Swift/Swift/UIKit/UIImagePickerController/</url>
      <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/qq_14920635/article/details/51472057" target="_blank" rel="noopener">http://blog.csdn.net/qq_14920635/article/details/51472057</a></p>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UIImagePickerController </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UIImagePickerController </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-NSAttributedString</title>
      <link href="/2017/12/14/Swift/Swift/UIKit/NSAttributedString/"/>
      <url>/2017/12/14/Swift/Swift/UIKit/NSAttributedString/</url>
      <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/qq_14920635/article/details/76318309" target="_blank" rel="noopener">http://blog.csdn.net/qq_14920635/article/details/76318309</a></p>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> NSAttributedString </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> NSAttributedString </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Func-Mirror-反射</title>
      <link href="/2017/12/14/Swift/Swift/Func/Swift-Func-Mirror-%E5%8F%8D%E5%B0%84/"/>
      <url>/2017/12/14/Swift/Swift/Func/Swift-Func-Mirror-%E5%8F%8D%E5%B0%84/</url>
      <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/qq_14920635/article/details/77676231" target="_blank" rel="noopener">http://blog.csdn.net/qq_14920635/article/details/77676231</a></p>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Func </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Func </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Func-正则表达式</title>
      <link href="/2017/12/14/Swift/Swift/Func/Swift-Func-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2017/12/14/Swift/Swift/Func/Swift-Func-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>#常用的正则表达式方式</p><h2 id="在NSpredicate中使用"><a href="#在NSpredicate中使用" class="headerlink" title="在NSpredicate中使用"></a>在NSpredicate中使用</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> email = <span class="string">"lifusc464@qq.com"</span>  </span><br><span class="line"><span class="keyword">let</span> regex = <span class="string">"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]&#123;2,4&#125;"</span>  </span><br><span class="line"><span class="keyword">let</span> predicate = <span class="type">NSPredicate</span>(format: <span class="string">"SELF MATCHES %@"</span>, regex)  </span><br><span class="line"><span class="keyword">let</span> isValid = predicate.evaluate(with: email)  </span><br><span class="line"><span class="built_in">print</span>(isValid ? <span class="string">"正确的邮箱地址"</span> : <span class="string">"错误的邮箱地址"</span>)</span><br></pre></td></tr></table></figure><h2 id="利用String的RangeOfString-option-直接查找"><a href="#利用String的RangeOfString-option-直接查找" class="headerlink" title="利用String的RangeOfString: option: 直接查找"></a>利用String的RangeOfString: option: 直接查找</h2><blockquote><p>正则表达判断是否含有结果值 </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment"> 正则表达判断是否含有结果值 </span></span><br><span class="line"><span class="comment"> - parameter pattern: 一个字符串类型的正则表达式 </span></span><br><span class="line"><span class="comment"> - parameter str: 需要比较判断的对象 </span></span><br><span class="line"><span class="comment"> - returns: 返回布尔值判断结果 </span></span><br><span class="line"><span class="comment"> - warning: 注意匹配到结果的话就会返回true，没有匹配到结果就会返回false </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">regex</span>(<span class="title">pattern</span>:<span class="title">String</span>, <span class="title">str</span>:<span class="title">String</span>) -&gt; <span class="title">Bool</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">let</span> regex = <span class="keyword">try</span>! <span class="type">NSRegularExpression</span>(pattern: pattern, options:[<span class="type">NSRegularExpression</span>.<span class="type">Options</span>.caseInsensitive])  </span><br><span class="line">    <span class="keyword">let</span> resultNum = regex.numberOfMatches(<span class="keyword">in</span>: str, options: <span class="type">NSRegularExpression</span>.<span class="type">MatchingOptions</span>(rawValue: <span class="number">0</span>) , range: <span class="type">NSMakeRange</span>(<span class="number">0</span>, str.characters.<span class="built_in">count</span>))  </span><br><span class="line">    <span class="keyword">if</span> resultNum&gt;=<span class="number">1</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 正则表达式获取目的值</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment"> 正则表达式获取目的值 </span></span><br><span class="line"><span class="comment"> - parameter pattern: 一个字符串类型的正则表达式 </span></span><br><span class="line"><span class="comment"> - parameter str: 需要比较判断的对象 </span></span><br><span class="line"><span class="comment"> - imports: 这里子串的获取先转话为NSString的[以后处理结果含NS的还是可以转换为NS前缀的方便] </span></span><br><span class="line"><span class="comment"> - returns: 返回目的字符串结果值数组(目前将String转换为NSString获得子串方法较为容易) </span></span><br><span class="line"><span class="comment"> - warning: 注意匹配到结果的话就会返回true，没有匹配到结果就会返回false </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">regexGetSub</span>(<span class="title">pattern</span>:<span class="title">String</span>, <span class="title">str</span>:<span class="title">String</span>) -&gt; [<span class="title">String</span>] </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> subStr = [<span class="type">String</span>]()  </span><br><span class="line">    <span class="keyword">let</span> regex = <span class="keyword">try</span>! <span class="type">NSRegularExpression</span>(pattern: pattern, options:[<span class="type">NSRegularExpression</span>.<span class="type">Options</span>.caseInsensitive])  </span><br><span class="line">    <span class="keyword">let</span> results = regex.matches(<span class="keyword">in</span>: str, options: <span class="type">NSRegularExpression</span>.<span class="type">MatchingOptions</span>.<span class="keyword">init</span>(rawValue: <span class="number">0</span>), range: <span class="type">NSMakeRange</span>(<span class="number">0</span>, str.characters.<span class="built_in">count</span>))  </span><br><span class="line">    <span class="comment">//解析出子串  </span></span><br><span class="line">    <span class="keyword">for</span>  rst <span class="keyword">in</span> results &#123;  </span><br><span class="line">        <span class="keyword">let</span> nsStr = str <span class="keyword">as</span>  <span class="type">NSString</span>  <span class="comment">//可以方便通过range获取子串  </span></span><br><span class="line">        subStr.append(nsStr.substring(with: rst.range))  </span><br><span class="line">        <span class="comment">//str.substring(with: Range&lt;String.Index&gt;) //本应该用这个的，可以无法直接获得参数，必须自己手动获取starIndex 和 endIndex作为区间  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> subStr  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Func </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Func </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Func-使用iconfont图标</title>
      <link href="/2017/12/14/Swift/Swift/Func/Swift-Func-%E4%BD%BF%E7%94%A8iconfont%E5%9B%BE%E6%A0%87/"/>
      <url>/2017/12/14/Swift/Swift/Func/Swift-Func-%E4%BD%BF%E7%94%A8iconfont%E5%9B%BE%E6%A0%87/</url>
      <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/qq_14920635/article/details/78408761" target="_blank" rel="noopener">http://blog.csdn.net/qq_14920635/article/details/78408761</a></p>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Func </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Func </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-NSNotificationCenter-简介</title>
      <link href="/2017/12/14/Swift/Swift/UIKit/NSNotificationCenter-%E7%AE%80%E4%BB%8B/"/>
      <url>/2017/12/14/Swift/Swift/UIKit/NSNotificationCenter-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="NSNotificationCenter"><a href="#NSNotificationCenter" class="headerlink" title="NSNotificationCenter"></a>NSNotificationCenter</h1><blockquote><p>如果被通知对象创建了，那么执行完发送通知之后就会执行被通知的selector的方法，之后再回来执行后一行代码<br>通知一般在mode与View需要交流（传递数据）时使用，或者也可以用于多线程的消息传递，也可是其他的信息传递,最常用的场景是页面值的回传</p></blockquote><h2 id="注册通知"><a href="#注册通知" class="headerlink" title="注册通知"></a>注册通知</h2><blockquote><p>参数：第一个是响应被通知的对象，一般是self， selector:一个自定义方法，实现得到通知后的操作（如果使用闭包的方法，就在回调中实现），<br>name:通知的名字（注意注册通知和发送通知必须一致才能够响应通知），<br>object:发通知的对象，如果填nil则表示接受所有通知，如果填上具体的对象，则是1对1的通知。<br>建议：如果通知多可以单独写一个方法放通知（调用第二个方法），如果通知比较少建议使用第一种，再实现其selector方法，注册通知是在需要被通知的类里写</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(<span class="keyword">self</span>, selector: #selector(<span class="type">TiltleNotification</span>), name: <span class="string">"TiltleNotification"</span>, object: <span class="literal">nil</span>)<span class="comment">//注册了一个名字叫做TiltleNotification</span></span><br></pre></td></tr></table></figure><h2 id="发送通知post"><a href="#发送通知post" class="headerlink" title="发送通知post"></a>发送通知post</h2><blockquote><p>在需要通知的类（即需要传信息出去的类）中使用通知传递消息<br>name也可以这样写:NSNotification.Name.init(“TiltleNotification”) </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSNotificationCenter</span>.defaultCenter().postNotificationName(<span class="type">NSNotification</span>.<span class="type">Name</span>(<span class="string">"TiltleNotification"</span>), object: <span class="keyword">self</span>, userInfo: [<span class="string">"success"</span>:<span class="literal">true</span>,<span class="string">"img"</span>:<span class="type">UIImage</span>(named:<span class="string">"image"</span>])</span><br></pre></td></tr></table></figure><h2 id="在完成通知中的选择器方法"><a href="#在完成通知中的选择器方法" class="headerlink" title="在完成通知中的选择器方法"></a>在完成通知中的选择器方法</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pushBookTiltleNotification</span><span class="params">(notification:NSNotification)</span></span>&#123; <span class="comment">//记得参数加上，才能得到信息  </span></span><br><span class="line">      <span class="keyword">let</span> dict = notification.userInfo   </span><br><span class="line">      <span class="keyword">if</span> (dict[<span class="string">"success"</span>] <span class="keyword">as</span>! <span class="type">Bool</span>) &#123;<span class="comment">//获取传递过来的值,而且需要转换下  </span></span><br><span class="line">          <span class="type">ProgressHUD</span>.showSuccess(<span class="string">"通知成功"</span>)  </span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">          <span class="type">ProgressHUD</span>.showError(<span class="string">"通知失败"</span>)  </span><br><span class="line">      &#125;  </span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="移除通知"><a href="#移除通知" class="headerlink" title="移除通知"></a>移除通知</h2><blockquote><p>由于通知是单列的，所以使用完后必须在析构deinit中移除通知，否则后期将引发难以查询的莫名错误</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">deinit</span>&#123;  </span><br><span class="line">       </span><br><span class="line">      <span class="comment">//注意由于通知是单例的，所以用了之后需要析构，  </span></span><br><span class="line">      <span class="type">NSNotificationCenter</span>.defaultCenter().removeObserver(<span class="keyword">self</span>, name: <span class="string">"TiltleNotification"</span>, object: <span class="literal">nil</span>)  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> NSNotificationCenter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> NSNotificationCenter </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UISearchController-简介</title>
      <link href="/2017/12/14/Swift/Swift/UIKit/UISearchController-%E7%AE%80%E4%BB%8B/"/>
      <url>/2017/12/14/Swift/Swift/UIKit/UISearchController-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UISearchController </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UITableView-双表联动</title>
      <link href="/2017/12/14/Swift/Swift/UIKit/UITableView-%E5%8F%8C%E8%A1%A8%E8%81%94%E5%8A%A8/"/>
      <url>/2017/12/14/Swift/Swift/UIKit/UITableView-%E5%8F%8C%E8%A1%A8%E8%81%94%E5%8A%A8/</url>
      <content type="html"><![CDATA[<h1 id="FFTableViewCtl-swift"><a href="#FFTableViewCtl-swift" class="headerlink" title="FFTableViewCtl.swift"></a>FFTableViewCtl.swift</h1><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FFTableViewCtl</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDataSource</span>, <span class="title">UITableViewDelegate</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><blockquote><p>左侧 菜单分类数据源</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> categoryData = [<span class="type">FFCategoryModel</span>]()</span><br></pre></td></tr></table></figure><blockquote><p>右侧，某类型具体菜单详情</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> foodData     = [[<span class="type">FFFoodModel</span>]]()</span><br></pre></td></tr></table></figure><blockquote><p>记录当前选择分类（菜类型）</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span>  <span class="keyword">var</span> selectIndex  = <span class="number">0</span>   <span class="comment">//默认选择 0</span></span><br></pre></td></tr></table></figure><blockquote><p>记录是否向下滚动</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span>  <span class="keyword">var</span> isScrollDown = <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>记录最后Y方向偏移量</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span>  <span class="keyword">var</span> lastOffsetY : <span class="type">CGFloat</span> = <span class="number">0.0</span></span><br></pre></td></tr></table></figure><blockquote><p>左侧TableView表</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> leftTableView : <span class="type">UITableView</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> leftTableView = <span class="type">UITableView</span>()</span><br><span class="line">    leftTableView.delegate = <span class="keyword">self</span></span><br><span class="line">    leftTableView.dataSource = <span class="keyword">self</span></span><br><span class="line">    </span><br><span class="line">    leftTableView.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">80</span>, height: <span class="type">UIScreen</span>.main.bounds.height)</span><br><span class="line">    leftTableView.rowHeight = <span class="number">55</span></span><br><span class="line">    leftTableView.showsVerticalScrollIndicator = <span class="literal">false</span></span><br><span class="line">    leftTableView.separatorColor = <span class="type">UIColor</span>.clear</span><br><span class="line">    leftTableView.register(<span class="type">FFLeftTableViewCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"FFLeftTableViewCell"</span>)</span><br><span class="line">    <span class="keyword">return</span> leftTableView</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><blockquote><p>右侧TableView表</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> rightTableView : <span class="type">UITableView</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> rightTableView = <span class="type">UITableView</span>()</span><br><span class="line">    rightTableView.delegate = <span class="keyword">self</span></span><br><span class="line">    rightTableView.dataSource = <span class="keyword">self</span></span><br><span class="line">    rightTableView.frame = <span class="type">CGRect</span>(x: <span class="number">80</span>, y: <span class="number">64</span>, width: <span class="type">UIScreen</span>.main.bounds.width - <span class="number">80</span>, height: <span class="type">UIScreen</span>.main.bounds.height - <span class="number">64</span>)</span><br><span class="line">    rightTableView.rowHeight = <span class="number">80</span></span><br><span class="line">    rightTableView.showsVerticalScrollIndicator = <span class="literal">false</span></span><br><span class="line">    rightTableView.register(<span class="type">FFRightTableViewCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"FFRightTableViewCell"</span>)</span><br><span class="line">    <span class="keyword">return</span> rightTableView</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">extension</span> <span class="title">FFTableViewCtl</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">configureData</span> <span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span></span><br><span class="line">            <span class="keyword">let</span> path = <span class="type">Bundle</span>.main.path(forResource: <span class="string">"meituan"</span>, ofType: <span class="string">"json"</span>)</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span></span><br><span class="line">            <span class="keyword">let</span> data = <span class="type">NSData</span>(contentsOfFile: path) <span class="keyword">as</span> <span class="type">Data</span>?</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span></span><br><span class="line">            <span class="keyword">let</span> anyObject = <span class="keyword">try</span>? <span class="type">JSONSerialization</span>.jsonObject(with: data,</span><br><span class="line">                                                              options: .mutableContainers)</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span></span><br><span class="line">            <span class="keyword">let</span> dict = anyObject <span class="keyword">as</span>? [<span class="type">String</span> : <span class="type">Any</span>]</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span></span><br><span class="line">            <span class="keyword">let</span> datas = dict[<span class="string">"data"</span>] <span class="keyword">as</span>? [<span class="type">String</span> : <span class="type">Any</span>]</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span></span><br><span class="line">            <span class="keyword">let</span> foods = datas[<span class="string">"food_spu_tags"</span>] <span class="keyword">as</span>? [[<span class="type">String</span> : <span class="type">Any</span>]]</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(foods)</span>"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> food <span class="keyword">in</span> foods &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> model = <span class="type">FFCategoryModel</span>(dict: food)</span><br><span class="line">            categoryData.append(model)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">guard</span></span><br><span class="line">                <span class="keyword">let</span> spus = model.spus</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> datas = [<span class="type">FFFoodModel</span>]()</span><br><span class="line">            <span class="keyword">for</span> fModel <span class="keyword">in</span> spus &#123;</span><br><span class="line">                datas.append(fModel)</span><br><span class="line">            &#125;</span><br><span class="line">           foodData.append(datas)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TableView-2个协议-实现"><a href="#TableView-2个协议-实现" class="headerlink" title="TableView 2个协议 实现"></a>TableView 2个协议 实现</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">FFTableViewCtl</span> </span>&#123;<span class="comment">//DataSource //Delegate &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>行</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> leftTableView == tableView&#123;</span><br><span class="line">        <span class="keyword">return</span> categoryData.<span class="built_in">count</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> foodData[section].<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>cell</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> leftTableView == tableView &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"FFLeftTableViewCell"</span>,</span><br><span class="line">                                                 <span class="keyword">for</span>: indexPath)<span class="keyword">as</span>! <span class="type">FFLeftTableViewCell</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> model  = categoryData[indexPath.row]</span><br><span class="line">        cell.nameLab.text = model.name</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"FFRightTableViewCell"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">FFRightTableViewCell</span></span><br><span class="line">        <span class="keyword">let</span> model = foodData[indexPath.section][indexPath.row]</span><br><span class="line">        cell.setDatas(model: model)</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>区 数</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfSections</span><span class="params">(<span class="keyword">in</span> tableView: UITableView)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> leftTableView == tableView &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> categoryData.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 区 view- 设置</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, viewForHeaderInSection section: Int)</span></span> -&gt; <span class="type">UIView</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> leftTableView == tableView &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> headerView = <span class="type">FFTableViewHeaderView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">UIScreen</span>.main.bounds.width, height: <span class="number">20</span>))</span><br><span class="line">        <span class="keyword">let</span> model = categoryData[section]</span><br><span class="line">        headerView.nameLab.text = model.name</span><br><span class="line">        <span class="keyword">return</span> headerView</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 区头view - 区高</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, heightForHeaderInSection section: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> leftTableView == tableView &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>区头view - 即将展示</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, willDisplayHeaderView view: UIView, forSection section: Int)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 当前的 tableView 是 FFRightTableView，FFRightTableView 滚动的方向向上，FFRightTableView 是用户拖拽而产生滚动的（（主要判断 RightTableView 用户拖拽而滚动的，还是点击 FFLeftTableView 而滚动的）</span></span><br><span class="line">    <span class="keyword">if</span>(rightTableView == tableView)</span><br><span class="line">        &amp;&amp; !isScrollDown</span><br><span class="line">        &amp;&amp; (rightTableView.isDragging || rightTableView.isDecelerating)&#123;</span><br><span class="line">        selectRow(index: section)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>区头view - 展示结束</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, didEndDisplayingHeaderView view: UIView, forSection section: Int)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 当前的 tableView 是 FFRightTableView，FFRightTableView 滚动的方向向下，FFRightTableView 是用户拖拽而产生滚动的（（主要判断 RightTableView 用户拖拽而滚动的，还是点击 FFLeftTableView 而滚动的）</span></span><br><span class="line">    <span class="keyword">if</span> (rightTableView == tableView)</span><br><span class="line">        &amp;&amp; isScrollDown</span><br><span class="line">        &amp;&amp; (rightTableView.isDragging || rightTableView.isDecelerating) &#123;</span><br><span class="line">        selectRow(index: section + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>didSelct - 选择cell</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, didSelectRowAt indexPath: IndexPath)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> leftTableView == tableView &#123;</span><br><span class="line">        selectIndex = indexPath.row</span><br><span class="line">        <span class="keyword">self</span>.scrollToTop(section: selectIndex, animated: <span class="literal">true</span>)</span><br><span class="line">        leftTableView.scrollToRow(at: <span class="type">IndexPath</span>(row: selectIndex, section: <span class="number">0</span>), at: .top, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>scrollViewDidScroll<br>标记一下 RightTableView 的滚动方向，是向上还是向下</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidScroll</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> tableView = scrollView <span class="keyword">as</span>! <span class="type">UITableView</span></span><br><span class="line">    <span class="keyword">if</span> rightTableView == tableView &#123;</span><br><span class="line">        isScrollDown = lastOffsetY &lt; scrollView.contentOffset.y</span><br><span class="line">        lastOffsetY = scrollView.contentOffset.y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="private-私有方法"><a href="#private-私有方法" class="headerlink" title="private 私有方法"></a>private 私有方法</h2><blockquote><p>selectRow 当拖动右边TableView，处理左边 TableView</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">selectRow</span><span class="params">(index:Int)</span></span>&#123;</span><br><span class="line">    leftTableView.selectRow(at: <span class="type">IndexPath</span>(row: index,</span><br><span class="line">                                          section: <span class="number">0</span>),</span><br><span class="line">                            animated: <span class="literal">true</span>,</span><br><span class="line">                            scrollPosition: .top)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>scrollToTop</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollToTop</span><span class="params">(section:Int,animated: Bool)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> headerRect = rightTableView.rect(forSection: section)</span><br><span class="line">    <span class="keyword">let</span> topHeader = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: headerRect.origin.y - rightTableView.contentInset.top)</span><br><span class="line">    rightTableView.setContentOffset(topHeader, animated: animated)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="FFLeftTableViewCell-swift"><a href="#FFLeftTableViewCell-swift" class="headerlink" title="FFLeftTableViewCell.swift"></a>FFLeftTableViewCell.swift</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FFLeftTableViewCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.awakeFromNib()</span><br><span class="line">        <span class="comment">// Initialization code</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> nameLab = <span class="type">UILabel</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> yellowView = <span class="type">UIView</span>()</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span> (style:<span class="type">UITableViewCellStyle</span>,reuseIdentifier:<span class="type">String</span>?)&#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(style: style, reuseIdentifier: reuseIdentifier)</span><br><span class="line">        selectionStyle = .<span class="keyword">none</span></span><br><span class="line">        initUI()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initUI</span><span class="params">()</span></span> &#123;</span><br><span class="line">        nameLab.frame = <span class="type">CGRect</span>(x: <span class="number">10</span>, y: <span class="number">10</span>, width: <span class="number">60</span>, height: <span class="number">40</span>)</span><br><span class="line">        nameLab.numberOfLines = <span class="number">0</span></span><br><span class="line">        nameLab.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">15</span>)</span><br><span class="line">        nameLab.textColor = <span class="type">UIColor</span>(<span class="number">130</span>, <span class="number">130</span>, <span class="number">130</span>)</span><br><span class="line">        nameLab.highlightedTextColor = <span class="type">UIColor</span>(<span class="number">253</span>, <span class="number">212</span>, <span class="number">49</span>)</span><br><span class="line">        contentView.addSubview(nameLab)</span><br><span class="line">        </span><br><span class="line">        yellowView.frame = <span class="type">CGRect</span>(x:<span class="number">0</span>,y:<span class="number">5</span>,width:<span class="number">5</span>,height:<span class="number">45</span>)</span><br><span class="line">        yellowView.backgroundColor = <span class="type">UIColor</span>(<span class="number">253</span>, <span class="number">212</span>, <span class="number">49</span>)</span><br><span class="line">        contentView.addSubview(yellowView)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setSelected</span><span class="params">(<span class="number">_</span> selected: Bool, animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.setSelected(selected, animated: animated)</span><br><span class="line">        <span class="comment">// Configure the view for the selected state</span></span><br><span class="line">        </span><br><span class="line">        contentView.backgroundColor = selected ? <span class="type">UIColor</span>.white : <span class="type">UIColor</span>(white: <span class="number">0</span>, alpha: <span class="number">0.1</span>)</span><br><span class="line">        isHighlighted = selected</span><br><span class="line">        nameLab.isHighlighted = selected</span><br><span class="line">        yellowView.isHidden = !selected</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="FFRightTableViewCell-swift"><a href="#FFRightTableViewCell-swift" class="headerlink" title="FFRightTableViewCell.swift"></a>FFRightTableViewCell.swift</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">FFRightTableViewCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.awakeFromNib()</span><br><span class="line">        <span class="comment">// Initialization code</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setSelected</span><span class="params">(<span class="number">_</span> selected: Bool, animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.setSelected(selected, animated: animated)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Configure the view for the selected state</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> nameLab = <span class="type">UILabel</span>()       <span class="comment">//名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> imgView = <span class="type">UIImageView</span>()   <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> priceLab = <span class="type">UILabel</span>()      <span class="comment">// 价格</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(style: <span class="type">UITableViewCellStyle</span>, reuseIdentifier: <span class="type">String</span>?)&#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(style: style, reuseIdentifier: reuseIdentifier)</span><br><span class="line">        initUI()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//#MARK:设置UI</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span>  <span class="title">initUI</span><span class="params">()</span></span>&#123;</span><br><span class="line">        nameLab.frame = <span class="type">CGRect</span>(x: <span class="number">15</span>, y: <span class="number">15</span>, width: <span class="number">50</span>, height: <span class="number">50</span>)</span><br><span class="line">        contentView.addSubview(nameLab)</span><br><span class="line">        </span><br><span class="line">        imgView.frame = <span class="type">CGRect</span>(x: <span class="number">15</span>, y: <span class="number">15</span>, width: <span class="number">50</span>, height: <span class="number">50</span>)</span><br><span class="line">        contentView.addSubview(imgView)</span><br><span class="line">        </span><br><span class="line">        priceLab.frame = <span class="type">CGRect</span>(x: <span class="number">80</span>, y: <span class="number">45</span>, width: <span class="number">200</span>, height: <span class="number">30</span>)</span><br><span class="line">        priceLab.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">14</span>)</span><br><span class="line">        priceLab.textColor = <span class="type">UIColor</span>.red</span><br><span class="line">        contentView.addSubview(priceLab)</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//#MARK: 加载数据</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setDatas</span><span class="params">( model:FFFoodModel)</span></span>&#123;</span><br><span class="line">        <span class="keyword">guard</span></span><br><span class="line">            <span class="keyword">let</span> minPrice = model.minPrice,</span><br><span class="line">            <span class="keyword">let</span> picture = model.picture,</span><br><span class="line">            <span class="keyword">let</span> name = model.name</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">            priceLab.text = <span class="string">"￥<span class="subst">\(minPrice)</span>"</span></span><br><span class="line">            nameLab.text = name</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> url = <span class="type">URL</span>.<span class="keyword">init</span>(string: picture)</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">      imgView.kf.setImage(with: url)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="FFCategoryModel-swift"><a href="#FFCategoryModel-swift" class="headerlink" title="FFCategoryModel.swift"></a>FFCategoryModel.swift</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">FFCategoryModel</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> icon: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> spus:    [<span class="type">FFFoodModel</span>]?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(dict :[<span class="type">String</span>:<span class="type">Any</span>]) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        setValuesForKeys(dict)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setValue</span><span class="params">(<span class="number">_</span> value: Any?, forKey key: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> key == <span class="string">"spus"</span> &#123;</span><br><span class="line">           spus = <span class="type">Array</span>()</span><br><span class="line">            <span class="keyword">guard</span></span><br><span class="line">                <span class="keyword">let</span> datas = value <span class="keyword">as</span>? [[<span class="type">String</span>:<span class="type">Any</span>]]</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> dict <span class="keyword">in</span> datas&#123;</span><br><span class="line">                <span class="keyword">let</span> foodModel = <span class="type">FFFoodModel</span>(dict:dict)</span><br><span class="line">                spus?.append(foodModel)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.setValue(value, forKey: key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setValue</span><span class="params">(<span class="number">_</span> value: Any?, forUndefinedKey key: String)</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="FFFoodModel-swift"><a href="#FFFoodModel-swift" class="headerlink" title="FFFoodModel.swift"></a>FFFoodModel.swift</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">FFFoodModel</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name : <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> picture : <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> minPrice : <span class="type">Float</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(dict : [<span class="type">String</span> : <span class="type">Any</span>]) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        setValuesForKeys(dict)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setValue</span><span class="params">(<span class="number">_</span> value: Any?, forKey key: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> key == <span class="string">"min_price"</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> price = value <span class="keyword">as</span>? <span class="type">Float</span> <span class="keyword">else</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line">            minPrice = price</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.setValue(value, forKey: key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setValue</span><span class="params">(<span class="number">_</span> value: Any?, forUndefinedKey key: String)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="FFTableViewHeaderView-swift"><a href="#FFTableViewHeaderView-swift" class="headerlink" title="FFTableViewHeaderView.swift"></a>FFTableViewHeaderView.swift</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">FFTableViewHeaderView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">lazy</span> <span class="keyword">var</span> nameLab  = <span class="type">UILabel</span>()</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span> (frame:<span class="type">CGRect</span>)&#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line">        backgroundColor = <span class="type">UIColor</span>(<span class="number">240</span>, <span class="number">240</span>, <span class="number">240</span>, <span class="number">0.8</span>)</span><br><span class="line">        nameLab.frame = <span class="type">CGRect</span>(x: <span class="number">15</span>, y: <span class="number">0</span>, width: <span class="number">200</span>, height: <span class="number">20</span>)</span><br><span class="line">        nameLab.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">13</span>)</span><br><span class="line">        addSubview(nameLab)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UITableView </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UITableView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Error-网络错误锦集</title>
      <link href="/2017/12/14/Swift/Swift/Error/Swift-Error-%E7%BD%91%E7%BB%9C%E9%94%99%E8%AF%AF%E9%94%A6%E9%9B%86/"/>
      <url>/2017/12/14/Swift/Swift/Error/Swift-Error-%E7%BD%91%E7%BB%9C%E9%94%99%E8%AF%AF%E9%94%A6%E9%9B%86/</url>
      <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><blockquote><p>错误信息</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">App Transport Security has blocked a cleartext HTTP (http://) resource load since it is insecure. Temporary exceptions can be configured via your app&apos;s Info.plist file</span><br></pre></td></tr></table></figure><blockquote><p>修改info.plist</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">App Transport Security Settings</span><br><span class="line">  Allow Arbitrary Loads           YES</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Error </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Error </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Error-开发错误锦集</title>
      <link href="/2017/12/14/Swift/Swift/Error/Swift-Error-%E5%BC%80%E5%8F%91%E9%94%99%E8%AF%AF%E9%94%A6%E9%9B%86/"/>
      <url>/2017/12/14/Swift/Swift/Error/Swift-Error-%E5%BC%80%E5%8F%91%E9%94%99%E8%AF%AF%E9%94%A6%E9%9B%86/</url>
      <content type="html"><![CDATA[<h1 id="Model赋值"><a href="#Model赋值" class="headerlink" title="Model赋值"></a>Model赋值</h1><blockquote><p>某个key（比如has_next_page）没var，但数据里有(forUndefinedKey)</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">reason:this <span class="class"><span class="keyword">class</span> <span class="title">is</span> <span class="title">not</span> <span class="title">key</span> <span class="title">value</span> <span class="title">coding</span>-<span class="title">compliant</span> <span class="title">for</span> <span class="title">the</span> <span class="title">key</span> <span class="title">has_next_page</span>.'</span></span><br></pre></td></tr></table></figure><blockquote><p>forKey/forUndefinedKey</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//forKey</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setValue</span><span class="params">(<span class="number">_</span> value: Any?, forKey key: String)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//forUndefinedKey</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setValue</span><span class="params">(<span class="number">_</span> value: Any?, forUndefinedKey key: String)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="添加环境变量-OS-ACTIVITY-MODE"><a href="#添加环境变量-OS-ACTIVITY-MODE" class="headerlink" title="添加环境变量 OS_ACTIVITY_MODE"></a>添加环境变量 OS_ACTIVITY_MODE</h1><blockquote><p>Xcode 8多余日志输出</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nw_socket_set_common_sockopts setsockopt SO_NOAPNFALLBK failed: [42] Protocol not available, dumping backtrace:</span><br></pre></td></tr></table></figure><blockquote><p>添加环境变量 </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【product】-【scheme】-【Edit Scheme】-【Run】-【Argument】-【Environment Variable】添加key Value【OS_ACTIVITY_MODE disable】</span><br></pre></td></tr></table></figure><p>#检查字典或者数组的形式是否正确</p><blockquote><p>Swift编译时报错：Command failed due to signal: Segmentation fault: 11<br>在网络请求完，解析的时候遇到这个问题：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Alamofire</span>.request(.<span class="type">GET</span>, <span class="string">"http://api.budejie.com/api/api_open.php"</span>, parameters: [<span class="string">"a"</span>:<span class="string">"newlist"</span>, <span class="string">"c"</span>:<span class="string">"data"</span>, <span class="string">"type"</span>:<span class="number">1</span>]).responseJSON() &#123; response <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> json = <span class="type">JSON</span>(response.result.value!)</span><br><span class="line">        arr = json[<span class="string">"list"</span>].arrayObject!</span><br><span class="line">        <span class="type">DRLog</span>(arr)</span><br><span class="line">        <span class="keyword">self</span>.tableView.reloadData()</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><blockquote><p>在控制台上看到的确实是arr是一个数组形式，里面有多个NSDictionary形式，但是如果我们直接这个用：arr[index][“text”]是错误的。必须先将arr中的每个类似NSDictionary形式转换成NSDictionary：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> dic = arr[index] <span class="keyword">as</span>! <span class="type">NSDictionary</span></span><br><span class="line"><span class="keyword">let</span> text = dic[<span class="string">"text"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Error </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Error </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UIWebView-简单使用</title>
      <link href="/2017/12/14/Swift/Swift/UIKit/Swift-UIKit-UIWebView-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/12/14/Swift/Swift/UIKit/Swift-UIKit-UIWebView-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="UIWebView"><a href="#UIWebView" class="headerlink" title="UIWebView"></a>UIWebView</h1><blockquote><p>UIWebView 继承与 UIView, 并且遵守了 UIScrollViewDelegate 协议, 所以它可以使用里面的方法和属性</p></blockquote><h1 id="遵守代理协议"><a href="#遵守代理协议" class="headerlink" title="遵守代理协议"></a>遵守代理协议</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UIWebViewDelegate</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义UIWebVIew"><a href="#自定义UIWebVIew" class="headerlink" title="自定义UIWebVIew"></a>自定义UIWebVIew</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myWebView</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 1.获取 UIWebView 的 UIScrollView 属性</span></span><br><span class="line">       <span class="keyword">let</span> webScroll = webView.scrollView</span><br><span class="line">       <span class="built_in">println</span>(<span class="string">"webScroll = <span class="subst">\(webScroll)</span>"</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2.获取 UIWebView 的 request 属性</span></span><br><span class="line">       <span class="keyword">let</span> webRequest = webView.request</span><br><span class="line">       <span class="built_in">println</span>(<span class="string">"webRequest = <span class="subst">\(webRequest)</span>"</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3.获取 UIWebView 是否在接收数据的时候可以退后一步</span></span><br><span class="line">       <span class="keyword">let</span> webCanBack = webView.canGoBack</span><br><span class="line">       <span class="built_in">println</span>(<span class="string">"webCanBack = <span class="subst">\(webCanBack)</span>"</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 4.获取 UIWebView 是否在接收数据的时候可以前进一步</span></span><br><span class="line">       <span class="keyword">let</span> webCanGo = webView.canGoForward</span><br><span class="line">       <span class="built_in">println</span>(<span class="string">"webCanGo = <span class="subst">\(webCanGo)</span>"</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 5.获取 UIWebVIew 是否接受完数据</span></span><br><span class="line">       <span class="keyword">let</span> webLoading = webView.loading</span><br><span class="line">       <span class="built_in">println</span>(<span class="string">"webLoading = <span class="subst">\(webLoading)</span>"</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 6.设置 UIWebView 接收的数据是否可以通过手势来调整页面内容大小</span></span><br><span class="line">       webView.scalesPageToFit = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 7.设置 UIWebView 接收到得数据是什么类型的</span></span><br><span class="line">       webView.dataDetectorTypes = <span class="type">UIDataDetectorTypes</span>.<span class="type">All</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 8.设置 UIWebView 内是否可以回放媒体</span></span><br><span class="line">       webView.allowsInlineMediaPlayback = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 9.设置 UIWebView 中的 HTML5 视频是否自动播放</span></span><br><span class="line">       webView.mediaPlaybackRequiresUserAction = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 10.设置 UIWebView 是否可以使用 Air 播放</span></span><br><span class="line">       webView.mediaPlaybackAllowsAirPlay = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 11.设置 UIWebView 是否使用同步加载(默认是False)</span></span><br><span class="line">       webView.suppressesIncrementalRendering = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 12.设置 UIWebView 在点击视图或者元素时是否显示键盘(默认是True)</span></span><br><span class="line">       webView.keyboardDisplayRequiresUserAction = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 13.设置 UIWebView 的分页模式</span></span><br><span class="line">       webView.paginationMode = <span class="type">UIWebPaginationMode</span>.<span class="type">RightToLeft</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 14.设置 UIWebView 的分页打破模式</span></span><br><span class="line">       webView.paginationBreakingMode = <span class="type">UIWebPaginationBreakingMode</span>.<span class="type">Column</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 15.设置 UIWebView 的分页长度</span></span><br><span class="line">       webView.pageLength = <span class="number">400</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 16.设置 UIWebView 每个分页之间的宽度</span></span><br><span class="line">       webView.gapBetweenPages = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 17.获取 UIWebView 的分页数量</span></span><br><span class="line">       <span class="keyword">let</span> webViewPageCount = webView.pageCount</span><br><span class="line">       <span class="built_in">println</span>(webViewPageCount)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 18.设置 UIWebView 的代理对象</span></span><br><span class="line">       webView.delegate = <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 19.发送网络请求</span></span><br><span class="line">       <span class="keyword">var</span> url:<span class="type">NSURL</span> = <span class="type">NSURL</span>(string:<span class="string">"http://www.baidu.com"</span>)!</span><br><span class="line">       <span class="keyword">var</span> request:<span class="type">NSURLRequest</span> = <span class="type">NSURLRequest</span>(<span class="type">URL</span>:url)</span><br><span class="line">       webView.loadRequest(request)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="实现代理方法"><a href="#实现代理方法" class="headerlink" title="实现代理方法"></a>实现代理方法</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.该方法是用来设置是否在 UIWebView 加载之前发送一个请求</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(webView: UIWebView, shouldStartLoadWithRequest request: NSURLRequest, navigationType: UIWebViewNavigationType)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.该方法是在 UIWebView 在开发加载时调用</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">webViewDidStartLoad</span><span class="params">(webView: UIWebView)</span></span> &#123;</span><br><span class="line">       <span class="built_in">println</span>(<span class="string">"开始加载"</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3.该方法是在 UIWebView 加载完之后才调用</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">webViewDidFinishLoad</span><span class="params">(webView: UIWebView)</span></span> &#123;</span><br><span class="line">       <span class="built_in">println</span>(<span class="string">"加载完成"</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4.该方法是在 UIWebView 请求失败的时候调用</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(webView: UIWebView, didFailLoadWithError error: NSError)</span></span> &#123;</span><br><span class="line">       <span class="built_in">println</span>(<span class="string">"加载失败"</span>)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="在-ViewDidLoad-方法中实现"><a href="#在-ViewDidLoad-方法中实现" class="headerlink" title="在 ViewDidLoad 方法中实现"></a>在 ViewDidLoad 方法中实现</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">       <span class="keyword">self</span>.myWebView()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UIWebView </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UIWebView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UIWebView-简介</title>
      <link href="/2017/12/14/Swift/Swift/UIKit/Swift-UIKit-UIWebView-%E7%AE%80%E4%BB%8B/"/>
      <url>/2017/12/14/Swift/Swift/UIKit/Swift-UIKit-UIWebView-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="UIWebView的常用属性"><a href="#UIWebView的常用属性" class="headerlink" title="UIWebView的常用属性"></a>UIWebView的常用属性</h1><blockquote><p>1.设置 UIWebView 的代理对象</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> delegate: <span class="type">UIWebViewDelegate</span>?</span><br></pre></td></tr></table></figure><blockquote><p>2.获取 UIWebView 的 UIScrollView 属性</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scrollView: <span class="type">UIScrollView</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>3.获取 UIWebView 的网络请求</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> request: <span class="type">NSURLRequest</span>? &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>4.获取 UIWebView 是否在接收数据的时候可以退后一步</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canGoBack: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>5.获取 UIWebView 是否在接收数据的时候可以前进一步</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">var</span> canGoForward: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">&gt; <span class="number">6</span>.获取 <span class="type">UIWebView</span> 是否接受完数据</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line">   <span class="keyword">var</span> loading: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>7.设置 UIWebView 接收的数据是否可以通过手势来调整页面内容大小</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scalesPageToFit: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>8.设置 UIWebView 接收的数据是什么类型</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dataDetectorTypes: <span class="type">UIDataDetectorTypes</span></span><br></pre></td></tr></table></figure><blockquote><p>9.设置 UIWebView 内是否可以回放媒体</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> allowsInlineMediaPlayback: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>10.设置 UIWebView 中的 HTML5 视频是否自动播放(默认是True)</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mediaPlaybackRequiresUserAction: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>11.设置 UIWebView 是否可以使用 Air 播放(默认是True)</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mediaPlaybackAllowsAirPlay: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>12.设置 UIWebView 是否使用同步加载(默认是False)</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> suppressesIncrementalRendering: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>13.设置 UIWebView 在点击视图或者元素时是否显示键盘(默认是True)</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> keyboardDisplayRequiresUserAction: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>14.设置 UIWebView 的分页模式</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> paginationMode: <span class="type">UIWebPaginationMode</span></span><br></pre></td></tr></table></figure><blockquote><p>15.设置 UIWebView 的分页打破模式</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> paginationBreakingMode: <span class="type">UIWebPaginationBreakingMode</span></span><br></pre></td></tr></table></figure><blockquote><p>16.设置 UIWebView 的分页长度</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pageLength: <span class="type">CGFloat</span></span><br></pre></td></tr></table></figure><blockquote><p>17.设置 UIWebView 之间的页面宽度</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gapBetweenPages: <span class="type">CGFloat</span></span><br></pre></td></tr></table></figure><blockquote><p>18.获取 UIWebView 的页面数量</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pageCount: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><h1 id="常用类型"><a href="#常用类型" class="headerlink" title="常用类型"></a>常用类型</h1><blockquote><p>1.获取 UIWebView 的数据类型</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UIDataDetectorTypes</span> : <span class="title">RawOptionSetType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> rawValue: <span class="type">UInt</span>)</span><br><span class="line">    <span class="keyword">init</span>(rawValue: <span class="type">UInt</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">PhoneNumber</span>: <span class="type">UIDataDetectorTypes</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">Link</span>: <span class="type">UIDataDetectorTypes</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">Address</span>: <span class="type">UIDataDetectorTypes</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">CalendarEvent</span>: <span class="type">UIDataDetectorTypes</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">None</span>: <span class="type">UIDataDetectorTypes</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">All</span>: <span class="type">UIDataDetectorTypes</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.设置 UIWebView 的 Navigation 类型</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UIWebViewNavigationType</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">LinkClicked</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">FormSubmitted</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">BackForward</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Reload</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">FormResubmitted</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Other</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3.设置 UIWebView 的分页样式</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UIWebPaginationMode</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Unpaginated</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">LeftToRight</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">TopToBottom</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">BottomToTop</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">RightToLeft</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>4.设置 UIWebView 打破分页样式的样式</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UIWebPaginationBreakingMode</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Page</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Column</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="UIWebView的代理方法"><a href="#UIWebView的代理方法" class="headerlink" title="UIWebView的代理方法"></a>UIWebView的代理方法</h1><blockquote><p>1.该方法是用来设置是否在 UIWebView 加载之前发送一个请求</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(webView: UIWebView, shouldStartLoadWithRequest request: NSURLRequest, navigationType: UIWebViewNavigationType)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>2.该方法是在 UIWebView 在开发加载时调用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">webViewDidStartLoad</span><span class="params">(webView: UIWebView)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>3.该方法是在 UIWebView 加载完之后才调用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">webViewDidFinishLoad</span><span class="params">(webView: UIWebView)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>4.该方法是在 UIWebView 请求失败的时候调用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(webView: UIWebView, didFailLoadWithError error: NSError)</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UIWebView </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UIWebView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UINavigationController-简单使用</title>
      <link href="/2017/12/14/Swift/Swift/UIKit/UINavigationController-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/12/14/Swift/Swift/UIKit/UINavigationController-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="UINavigationController"><a href="#UINavigationController" class="headerlink" title="UINavigationController"></a>UINavigationController</h1><blockquote><p>UINavigationController 是继承与 UIViewController 的, 所以里面的方法以及属性都是可以使用的.</p></blockquote><h1 id="首先我们要再AppDelegate-swift文件中实现"><a href="#首先我们要再AppDelegate-swift文件中实现" class="headerlink" title="首先我们要再AppDelegate.swift文件中实现"></a>首先我们要再AppDelegate.swift文件中实现</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">       <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">self</span>.window = <span class="type">UIWindow</span>(frame: <span class="type">UIScreen</span>.mainScreen().bounds)</span><br><span class="line">       <span class="keyword">self</span>.window!.backgroundColor = <span class="type">UIColor</span>.grayColor()</span><br><span class="line">       <span class="keyword">self</span>.window!.makeKeyAndVisible()</span><br><span class="line"></span><br><span class="line">       <span class="keyword">let</span> viewController = <span class="type">ViewController</span>()</span><br><span class="line">       <span class="keyword">let</span> navigationController = <span class="type">UINavigationController</span>(rootViewController: viewController)</span><br><span class="line">       <span class="keyword">self</span>.window!.rootViewController = navigationController</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="遵守代理协议"><a href="#遵守代理协议" class="headerlink" title="遵守代理协议"></a>遵守代理协议</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UINavigationControllerDelegate</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h1 id="自定义UINavigationController"><a href="#自定义UINavigationController" class="headerlink" title="自定义UINavigationController"></a>自定义UINavigationController</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myNavigationContronller</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="comment">// 1.设置 UINavigationController 的 Title</span></span><br><span class="line">       <span class="keyword">self</span>.title = <span class="string">"UINavigationContronller"</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2.设置 UIVavigationController 的按钮 Title, Style, Target, Action 等方法属性</span></span><br><span class="line">       <span class="keyword">let</span> backBarButtonItem = <span class="type">UIBarButtonItem</span>(title: <span class="string">"返回"</span>, style: <span class="type">UIBarButtonItemStyle</span>.<span class="type">Plain</span>, target: <span class="keyword">self</span>, action: <span class="string">"backAction"</span>)</span><br><span class="line">       <span class="keyword">let</span> nextBarButtonItem = <span class="type">UIBarButtonItem</span>(title: <span class="string">"下一页"</span>, style: <span class="type">UIBarButtonItemStyle</span>.<span class="type">Plain</span>, target: <span class="keyword">self</span>, action: <span class="string">"nextAction"</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3.设置 UINavigationItem</span></span><br><span class="line">       <span class="keyword">self</span>.navigationItem.leftBarButtonItem = backBarButtonItem</span><br><span class="line">       <span class="keyword">self</span>.navigationItem.rightBarButtonItem = nextBarButtonItem</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 4.获取 UINavigationController 的顶部的视图控制器</span></span><br><span class="line">       <span class="keyword">let</span> topView = <span class="keyword">self</span>.navigationController?.topViewController</span><br><span class="line">       <span class="built_in">println</span>(topView)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 5.获取 UINavigationController 可见的视图控制器</span></span><br><span class="line">       <span class="keyword">let</span> visibleView = <span class="keyword">self</span>.navigationController?.visibleViewController</span><br><span class="line">       <span class="built_in">println</span>(visibleView)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 6.设置 UINavigationController 的导航栏控制器</span></span><br><span class="line">       <span class="keyword">self</span>.navigationController?.viewControllers</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 7.设置 UINavigationController 的导航栏控制器是否隐藏(默认是 false)</span></span><br><span class="line">       <span class="keyword">self</span>.navigationController?.navigationBarHidden = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 8.获取 UINavigationController 的导航栏控制器</span></span><br><span class="line">       <span class="keyword">let</span> navigationBar = <span class="keyword">self</span>.navigationController?.navigationBar</span><br><span class="line">       <span class="built_in">println</span>(navigationBar)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 9.设置 UINavigationController 的内置工具栏是否可见(默认是 ture)</span></span><br><span class="line">       <span class="keyword">self</span>.navigationController?.toolbarHidden = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 10.获取 UINavigationController 的 toolbar</span></span><br><span class="line">       <span class="keyword">let</span> toolbar = <span class="keyword">self</span>.navigationController?.toolbar</span><br><span class="line">       <span class="built_in">println</span>(toolbar)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 11.设置 UINavigationController 的代理对象</span></span><br><span class="line">       <span class="keyword">self</span>.navigationController?.delegate = <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 12.获取 UINavigationController 的手势识别顶部视图控制器</span></span><br><span class="line">       <span class="keyword">let</span> pop = <span class="keyword">self</span>.navigationController?.interactivePopGestureRecognizer</span><br><span class="line">       <span class="built_in">println</span>(pop)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 13.设置 UINavigationController 当键盘出现时是否隐藏导航栏和工具栏</span></span><br><span class="line">       <span class="keyword">self</span>.navigationController!.hidesBarsWhenKeyboardAppears = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 14.设置 UINavigationController 是否使用向上滑动的手势隐藏导航栏和工具栏</span></span><br><span class="line">       <span class="keyword">self</span>.navigationController?.hidesBarsOnSwipe = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 15.获取 UINavigationController 用手势识别隐藏导航栏和工具栏</span></span><br><span class="line">       <span class="keyword">let</span> barHide = <span class="keyword">self</span>.navigationController!.barHideOnSwipeGestureRecognizer</span><br><span class="line">       <span class="built_in">println</span>(barHide)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 16.设置 UINavigationController 是否在垂直显示时隐藏</span></span><br><span class="line">       <span class="keyword">self</span>.navigationController!.hidesBarsWhenVerticallyCompact = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 17.设置 UINavigationController 是否使用点击手势来隐藏</span></span><br><span class="line">       <span class="keyword">self</span>.navigationController?.hidesBarsOnTap = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 18.获取 UINavigationController 隐藏时所使用的手势</span></span><br><span class="line">       <span class="keyword">let</span> barHideOnTap = <span class="keyword">self</span>.navigationController!.barHideOnTapGestureRecognizer</span><br><span class="line">       <span class="built_in">println</span>(barHideOnTap)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 19.设置 UINavigationController 的导航栏是否隐藏, 是否使用动画</span></span><br><span class="line">       <span class="keyword">self</span>.navigationController?.setNavigationBarHidden(<span class="literal">true</span>, animated: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 20.设置 UINavigationController 的工具栏是否隐藏, 是否使用动画</span></span><br><span class="line">       <span class="keyword">self</span>.navigationController?.setToolbarHidden(<span class="literal">true</span>, animated: <span class="literal">true</span>)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="自定义代理方法以及监听方法"><a href="#自定义代理方法以及监听方法" class="headerlink" title="自定义代理方法以及监听方法"></a>自定义代理方法以及监听方法</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.该方法使用来设置 UINavigationController 将要显示时所调用的方法</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">navigationController</span><span class="params">(navigationController: UINavigationController, willShowViewController viewController: UIViewController, animated: Bool)</span></span> &#123;</span><br><span class="line">       <span class="built_in">println</span>(<span class="string">"UINavigationController 将要显示"</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.该方法使用来设置 UINavigationController 完全显示时所调用的方法</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">navigationController</span><span class="params">(navigationController: UINavigationController, didShowViewController viewController: UIViewController, animated: Bool)</span></span> &#123;</span><br><span class="line">       <span class="built_in">println</span>(<span class="string">"UINavigationController 完全显示"</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3.返回按钮的监听方法</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">backAction</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="built_in">println</span>(<span class="string">"点击了返回"</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4.下一页按钮的监听方法</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">nextAction</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="built_in">println</span>(<span class="string">"点击了下一页"</span>)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UINavigationController </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UINavigationController </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UINavigationController-简介</title>
      <link href="/2017/12/14/Swift/Swift/UIKit/UINavigationController-%E7%AE%80%E4%BB%8B/"/>
      <url>/2017/12/14/Swift/Swift/UIKit/UINavigationController-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="UINavigationController常用属性"><a href="#UINavigationController常用属性" class="headerlink" title="UINavigationController常用属性"></a>UINavigationController常用属性</h1><blockquote><p>1.获取 UINavigationController 的顶部的视图控制器</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> topViewController: <span class="type">UIViewController</span>! &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.获取 UINavigationController 可见的视图控制器</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> visibleViewController: <span class="type">UIViewController</span>! &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>3.设置 UINavigationController 的 viewControllers 对象</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> viewControllers: [<span class="type">AnyObject</span>]!</span><br></pre></td></tr></table></figure><blockquote><p>4.设置 UINavigationController 的导航栏控制器是否隐藏, 默认是 false</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> navigationBarHidden: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>5.获取 UINavigationController 的导航栏控制器</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> navigationBar: <span class="type">UINavigationBar</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>6.设置 UINavigationController 的内置工具栏是否可见(默认是 ture)</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> toolbarHidden: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>7.获取 UINavigationController 的 toolbar</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> toolbar: <span class="type">UIToolbar</span>! &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>8.设置 UINavigationController 的代理对象</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> delegate: <span class="type">UINavigationControllerDelegate</span>?</span><br></pre></td></tr></table></figure><blockquote><p>9.获取 UINavigationController 的手势识别顶部视图控制器</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> interactivePopGestureRecognizer: <span class="type">UIGestureRecognizer</span>! &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>10.设置 UINavigationController 当键盘出现时是否隐藏导航栏和工具栏</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hidesBarsWhenKeyboardAppears: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>11.设置 UINavigationController 是否使用向上滑动的手势隐藏导航栏和工具栏</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hidesBarsOnSwipe: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>12.获取 UINavigationController 用手势识别隐藏导航栏和工具栏</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> barHideOnSwipeGestureRecognizer: <span class="type">UIPanGestureRecognizer</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>13.设置 UINavigationController 是否在垂直显示时隐藏</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hidesBarsWhenVerticallyCompact: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>14.设置 UINavigationController 是否使用点击手势来隐藏</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hidesBarsOnTap: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>15.获取 UINavigationController 隐藏时所使用的手势</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> barHideOnTapGestureRecognizer: <span class="type">UITapGestureRecognizer</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><h1 id="UINavigationController常用的方法"><a href="#UINavigationController常用的方法" class="headerlink" title="UINavigationController常用的方法"></a>UINavigationController常用的方法</h1><blockquote><p>1.该方法是用来设置 UINavigationController 跳转到指定的视图控制器, 是否使用动画</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pushViewController</span><span class="params">(viewController: UIViewController, animated: Bool)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>2.该方法是用来设置 UINavigationController Pop到其他视图控制器时是否使用动画, 并且返回的类型必须是 UIViewController</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">popViewControllerAnimated</span><span class="params">(animated: Bool)</span></span> -&gt; <span class="type">UIViewController</span>?</span><br></pre></td></tr></table></figure><blockquote><p>3.该方法是用来设置 UINavigationController Pop到指定的视图控制器, 是否使用动画, 返回的类型是任意类型</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">popToViewController</span><span class="params">(viewController: UIViewController, animated: Bool)</span></span> -&gt; [<span class="type">AnyObject</span>]?</span><br></pre></td></tr></table></figure><blockquote><p>4.该方法是用来设置 UINavigationController Pop到根视图时是否使用动画, 并且返回的类型必须是任意类型</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">popToRootViewControllerAnimated</span><span class="params">(animated: Bool)</span></span> -&gt; [<span class="type">AnyObject</span>]?</span><br></pre></td></tr></table></figure><blockquote><p>5.该方法是用来替换之前于 UINavigationController 绑定的视图控制器, 并且是否使用动画</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setViewControllers</span><span class="params">(viewControllers: [AnyObject]!, animated: Bool)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>6.该方法是用来设置 UINavigationController 的导航栏是否隐藏, 是否使用动画</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setNavigationBarHidden</span><span class="params">(hidden: Bool, animated: Bool)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>7.该方法是用来设置 UINavigationController 的工具栏是否隐藏, 是否使用动画</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setToolbarHidden</span><span class="params">(hidden: Bool, animated: Bool)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>8.该方法是用来设置 UINavigationController 显示指定的 ViewController</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showViewController</span><span class="params">(vc: UIViewController, sender: AnyObject!)</span></span></span><br></pre></td></tr></table></figure><h1 id="UINavigationController代理方法"><a href="#UINavigationController代理方法" class="headerlink" title="UINavigationController代理方法"></a>UINavigationController代理方法</h1><blockquote><p>1.该方法使用来设置 UINavigationController 将要显示时所调用的方法</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">navigationController</span><span class="params">(navigationController: UINavigationController, willShowViewController viewController: UIViewController, animated: Bool)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>2.该方法使用来设置 UINavigationController 完全显示时所调用的方法</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">navigationController</span><span class="params">(navigationController: UINavigationController, didShowViewController viewController: UIViewController, animated: Bool)</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UINavigationController </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UINavigationController </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UISegmentedControl-简单使用</title>
      <link href="/2017/12/14/Swift/Swift/UIKit/UISegmentedControl-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/12/14/Swift/Swift/UIKit/UISegmentedControl-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="自定义UISegmentedContro"><a href="#自定义UISegmentedContro" class="headerlink" title="自定义UISegmentedContro"></a>自定义UISegmentedContro</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySegmentedControl</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.自定义 UISegemtedControl 并且设置它的 Item 数组对象</span></span><br><span class="line">        <span class="keyword">var</span> segmented = <span class="type">UISegmentedControl</span>(items: [<span class="string">"分段一"</span>, <span class="string">"分段二"</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.设置 UISegemtedControl 的中心点</span></span><br><span class="line">        segmented.center = <span class="type">CGPointMake</span>(<span class="keyword">self</span>.view.frame.width / <span class="number">2</span>, <span class="keyword">self</span>.view.frame.height / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.设置 UISegemtedControl 的尺寸</span></span><br><span class="line">        segmented.bounds = <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.设置 UISegemtedControl 点击之后是否瞬间弹起, (默认是 false)</span></span><br><span class="line">        segmented.momentary = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.获取 UISegemtedControl 的分段按钮个数</span></span><br><span class="line">        <span class="keyword">var</span> number: <span class="type">Int</span> = segmented.numberOfSegments</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.设置 UISegemtedControl 是否基于内容自动调整尺寸, 默认是 false, 前提是要不设置 UISegemtedControl 的尺寸</span></span><br><span class="line">        segmented.apportionsSegmentWidthsByContent = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.插入一个 UISegemtedControl 的分段按钮, 并且设置标题和索引, 以及是否使用动画</span></span><br><span class="line">        segmented.insertSegmentWithTitle(<span class="string">"分段三"</span>, atIndex: <span class="number">2</span>, animated: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8.插入一个 UISegemtedControl 作为分段按钮, 并且设置索引, 以及是否使用动画</span></span><br><span class="line">        segmented.insertSegmentWithImage(<span class="type">UIImage</span>(named: <span class="string">"image_black.jpg"</span>)!, atIndex: <span class="number">3</span>, animated: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 9.删除指定索引的 UISegemtedControl 分段按钮, 以及是否使用动画</span></span><br><span class="line">        segmented.removeSegmentAtIndex(<span class="number">1</span>, animated: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 10.删除所有 UISegemtedControl 的分段按钮</span></span><br><span class="line">        <span class="comment">//segmented.removeAllSegments()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 11.修改 UISegemtedControl 指定的 Item 分段按钮标题</span></span><br><span class="line">        segmented.setTitle(<span class="string">"分段四"</span>, forSegmentAtIndex: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 12.获取指定的 UISegemtedControl 分段按钮的标题</span></span><br><span class="line">        <span class="keyword">var</span> title: <span class="type">String</span> = segmented.titleForSegmentAtIndex(<span class="number">0</span>)!</span><br><span class="line">        <span class="built_in">println</span>(title)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 13.修改 UISegemtedControl 指定的 Item 分段按钮图片</span></span><br><span class="line">        segmented.setImage(<span class="type">UIImage</span>(named: <span class="string">"image_black.jpg"</span>)!, forSegmentAtIndex: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 14.获取指定的 UISegemtedControl 分段按钮的图片</span></span><br><span class="line">        <span class="keyword">var</span> image: <span class="type">UIImage</span> = segmented.imageForSegmentAtIndex(<span class="number">2</span>)!</span><br><span class="line">        <span class="built_in">println</span>(image)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 15.设置 UISegemtedControl 指定的 Item 宽度</span></span><br><span class="line">        segmented.setWidth(<span class="number">70</span>, forSegmentAtIndex: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 16.获取指定 UISegemtedControl 分段按钮的宽度</span></span><br><span class="line">        <span class="keyword">var</span> width: <span class="type">CGFloat</span> = segmented.widthForSegmentAtIndex(<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">println</span>(width)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 17.设置 UISegemtedControl 指定的 Item 内容偏移量</span></span><br><span class="line">        segmented.setContentOffset(<span class="type">CGSizeMake</span>(<span class="number">5</span>, <span class="number">5</span>), forSegmentAtIndex: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 18.获取指定 UISegemtedControl 指定的 Item 内容偏移量</span></span><br><span class="line">        <span class="keyword">var</span> size: <span class="type">CGSize</span> = segmented.contentOffsetForSegmentAtIndex(<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">println</span>(size)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 19.设置 UISegemtedControl 指定的 Item 是否可以点击</span></span><br><span class="line">        segmented.setEnabled(<span class="literal">true</span>, forSegmentAtIndex: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 20.获取指定 UISegemtedControl 指定的 Item 是否可以点击</span></span><br><span class="line">        <span class="keyword">var</span> bool: <span class="type">Bool</span> = segmented.isEnabledForSegmentAtIndex(<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">println</span>(bool)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 21.获取 UISegemtedControl 可点击的 Item 数量</span></span><br><span class="line">        <span class="keyword">var</span> selected: <span class="type">Int</span> = segmented.selectedSegmentIndex</span><br><span class="line">        <span class="built_in">println</span>(selected)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 22.设置 UISegemtedControl 的样式颜色</span></span><br><span class="line">        segmented.tintColor = <span class="type">UIColor</span>.redColor()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 23.设置 UISegemtedControl 的背景图片, 并且在 UISegemtedControl 指定的样式下才会显示, 以及图片显示的样式</span></span><br><span class="line">        segmented.setBackgroundImage(<span class="type">UIImage</span>(named: <span class="string">"image_black.jpg"</span>), forState: <span class="type">UIControlState</span>.<span class="type">Normal</span>, barMetrics: <span class="type">UIBarMetrics</span>.<span class="type">Default</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 24.获取 UISegemtedControl 在指定的状态, 图片显示下的图片</span></span><br><span class="line">        <span class="keyword">var</span> backgroundImage: <span class="type">UIImage</span> = segmented.backgroundImageForState(<span class="type">UIControlState</span>.<span class="type">Normal</span>, barMetrics: <span class="type">UIBarMetrics</span>.<span class="type">Default</span>)!</span><br><span class="line">        <span class="built_in">println</span>(backgroundImage)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 25.设置 UISegemtedControl 的左右的分隔符图片, 并且在 UISegemtedControl 指定的样式下才会显示, 以及图片显示的样式</span></span><br><span class="line">        segmented.setDividerImage(<span class="type">UIImage</span>(named: <span class="string">"image_divider"</span>), forLeftSegmentState: <span class="type">UIControlState</span>.<span class="type">Normal</span>, rightSegmentState: <span class="type">UIControlState</span>.<span class="type">Normal</span>, barMetrics: <span class="type">UIBarMetrics</span>.<span class="type">Default</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 26.获取 UISegemtedControl 的左右的分隔符图片, 并且在 UISegemtedControl 指定的样式下才会显示, 以及图片显示的样式</span></span><br><span class="line">        <span class="keyword">var</span> divider: <span class="type">UIImage</span> = segmented.dividerImageForLeftSegmentState(<span class="type">UIControlState</span>.<span class="type">Normal</span>, rightSegmentState: <span class="type">UIControlState</span>.<span class="type">Normal</span>, barMetrics: <span class="type">UIBarMetrics</span>.<span class="type">Default</span>)!</span><br><span class="line">        <span class="built_in">println</span>(divider)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 27.添加 UISegemtedControl 的监听方法</span></span><br><span class="line">        segmented.addTarget(<span class="keyword">self</span>, action: <span class="string">"didClicksegmentedControlAction:"</span>, forControlEvents: <span class="type">UIControlEvents</span>.<span class="type">ValueChanged</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加到 self.view</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(segmented)</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h1 id="UISegemtedControl的监听方法"><a href="#UISegemtedControl的监听方法" class="headerlink" title="UISegemtedControl的监听方法"></a>UISegemtedControl的监听方法</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">didClicksegmentedControlAction</span><span class="params">(segmented: UISegmentedControl!)</span></span> &#123;</span><br><span class="line">       <span class="keyword">var</span> index = segmented.selectedSegmentIndex</span><br><span class="line">       <span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">           <span class="built_in">println</span>(<span class="string">"分段按钮一"</span>)</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> index == <span class="number">1</span> &#123;</span><br><span class="line">           <span class="built_in">println</span>(<span class="string">"分段按钮二"</span>)</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> index == <span class="number">2</span> &#123;</span><br><span class="line">           <span class="built_in">println</span>(<span class="string">"分段按钮三"</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="在-viewDidLoad-中实现"><a href="#在-viewDidLoad-中实现" class="headerlink" title="在 viewDidLoad 中实现"></a>在 viewDidLoad 中实现</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    <span class="keyword">self</span>.mySegmentedControl()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UISegmentedControl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UISegmentedControl </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UISegmentedControl-简介</title>
      <link href="/2017/12/14/Swift/Swift/UIKit/UISegmentedControl-%E7%AE%80%E4%BB%8B/"/>
      <url>/2017/12/14/Swift/Swift/UIKit/UISegmentedControl-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="UISegemtedControl的常用属性"><a href="#UISegemtedControl的常用属性" class="headerlink" title="UISegemtedControl的常用属性"></a>UISegemtedControl的常用属性</h1><blockquote><p>1.初始化时设置 UISegemtedControl 的 Item 数组</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>(items: [<span class="type">AnyObject</span>])</span><br></pre></td></tr></table></figure><blockquote><p>2.设置 UISegemtedControl 点击之后是否瞬间弹起, (默认是 false)</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> momentary: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>3.获取 UISegemtedControl 里有的分段按钮个数   </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numberOfSegments: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>4.设置 UISegemtedControl 是否基于内容自动调整尺寸, 默认是 false, 前提是要不设置 UISegemtedControl 的尺寸</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> apportionsSegmentWidthsByContent: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>5.获取 UISegemtedControl 可点击的 Item 数量</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> selectedSegmentIndex: <span class="type">Int</span></span><br></pre></td></tr></table></figure><blockquote><p>6.设置 UISegemtedControl 的样式颜色</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tintColor: <span class="type">UIColor</span>!</span><br></pre></td></tr></table></figure><h1 id="UISegemtedControl的常用方法"><a href="#UISegemtedControl的常用方法" class="headerlink" title="UISegemtedControl的常用方法"></a>UISegemtedControl的常用方法</h1><blockquote><p>1.插入一个 UISegemtedControl 的分段按钮, 并且设置标题和索引, 以及是否使用动画</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertSegmentWithTitle</span><span class="params">(title: String!, atIndex segment: Int, animated: Bool)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>2.插入一个 UISegemtedControl 作为分段按钮, 并且设置索引, 以及是否使用动画</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertSegmentWithImage</span><span class="params">(image: UIImage, atIndex segment: Int, animated: Bool)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>3.删除指定索引的 UISegemtedControl 分段按钮, 以及是否使用动画</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeSegmentAtIndex</span><span class="params">(segment: Int, animated: Bool)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>4.删除所有 UISegemtedControl 的分段按钮</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeAllSegments</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><blockquote><p>3.修改 UISegemtedControl 指定的 Item 分段按钮标题</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setTitle</span><span class="params">(title: String?, forSegmentAtIndex segment: Int)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>4.获取指定的 UISegemtedControl 分段按钮的标题</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">titleForSegmentAtIndex</span><span class="params">(segment: Int)</span></span> -&gt; <span class="type">String</span>?</span><br></pre></td></tr></table></figure><blockquote><p>5.修改 UISegemtedControl 指定的 Item 分段按钮图片</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setImage</span><span class="params">(image: UIImage?, forSegmentAtIndex segment: Int)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>6.获取指定的 UISegemtedControl 分段按钮的图片</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">imageForSegmentAtIndex</span><span class="params">(segment: Int)</span></span> -&gt; <span class="type">UIImage</span>?</span><br></pre></td></tr></table></figure><blockquote><p>7.设置 UISegemtedControl 指定的 Item 宽度</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setWidth</span><span class="params">(width: CGFloat, forSegmentAtIndex segment: Int)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>8.获取指定 UISegemtedControl 分段按钮的宽度</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">widthForSegmentAtIndex</span><span class="params">(segment: Int)</span></span> -&gt; <span class="type">CGFloat</span></span><br></pre></td></tr></table></figure><blockquote><p>9.设置 UISegemtedControl 指定的 Item 内容偏移量</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setContentOffset</span><span class="params">(offset: CGSize, forSegmentAtIndex segment: Int)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>10.获取指定 UISegemtedControl 指定的 Item 内容偏移量</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">contentOffsetForSegmentAtIndex</span><span class="params">(segment: Int)</span></span> -&gt; <span class="type">CGSize</span></span><br></pre></td></tr></table></figure><blockquote><p>11.设置 UISegemtedControl 指定的 Item 是否可以点击</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setEnabled</span><span class="params">(enabled: Bool, forSegmentAtIndex segment: Int)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>12.获取指定 UISegemtedControl 指定的 Item 是否可以点击</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEnabledForSegmentAtIndex</span><span class="params">(segment: Int)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>13.设置 UISegemtedControl 的背景图片, 并且在 UISegemtedControl 指定的样式下才会显示, 以及图片显示的样式</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setBackgroundImage</span><span class="params">(backgroundImage: UIImage?, forState state: UIControlState, barMetrics: UIBarMetrics)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>14.获取 UISegemtedControl 在指定的状态, 图片显示下的图片</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backgroundImageForState</span><span class="params">(state: UIControlState, barMetrics: UIBarMetrics)</span></span> -&gt; <span class="type">UIImage</span>?</span><br></pre></td></tr></table></figure><blockquote><p>15.设置 UISegemtedControl 的左右的分隔符图片, 并且在 UISegemtedControl 指定的样式下才会显示, 以及图片显示的样式</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setDividerImage</span><span class="params">(dividerImage: UIImage?, forLeftSegmentState leftState: UIControlState, rightSegmentState rightState: UIControlState, barMetrics: UIBarMetrics)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>16.获取 UISegemtedControl 的左右的分隔符图片, 并且在 UISegemtedControl 指定的样式下才会显示, 以及图片显示的样式</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dividerImageForLeftSegmentState</span><span class="params">(leftState: UIControlState, rightSegmentState rightState: UIControlState, barMetrics: UIBarMetrics)</span></span> -&gt; <span class="type">UIImage</span>?</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UISegmentedControl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UISegmentedControl </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UISwitch-简单使用</title>
      <link href="/2017/12/14/Swift/Swift/UIKit/UISwitch-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/12/14/Swift/Swift/UIKit/UISwitch-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="自定义UISwitch"><a href="#自定义UISwitch" class="headerlink" title="自定义UISwitch"></a>自定义UISwitch</h1><blockquote><p>UISwitch 是继承于 UIControl, 所以 UIControl 里面的属性和方法 UISwitch 都是可以用的</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySwitch</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="comment">// 1.自定义 UISwitch</span></span><br><span class="line">       <span class="keyword">var</span> switchButton = <span class="type">UISwitch</span>()</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2.设置 UISwitch 的位置</span></span><br><span class="line">       switchButton.center = <span class="type">CGPointMake</span>(<span class="keyword">self</span>.view.frame.width / <span class="number">2</span>, <span class="keyword">self</span>.view.frame.height / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3.设置 UISwitch 打开时底图渐变颜色, 默认是从白变绿</span></span><br><span class="line">       switchButton.onTintColor = <span class="type">UIColor</span>.redColor()</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 4.设置 UISwitch 关闭时底图渐变颜色, 默认是从绿变白</span></span><br><span class="line">       switchButton.tintColor = <span class="type">UIColor</span>.blackColor()</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 5.设置 UISwitch 的小圆点颜色, 默认是白色</span></span><br><span class="line">       switchButton.thumbTintColor = <span class="type">UIColor</span>.blueColor()</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 6.设置 UISwitch 是否打开</span></span><br><span class="line">       switchButton.on = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 7.设置 UISwitch 是否打开, 并且是否打开动画效果</span></span><br><span class="line">       switchButton.setOn(<span class="literal">true</span>, animated: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 8.添加到 UISwitch 到 self.view</span></span><br><span class="line">       <span class="keyword">self</span>.view.addSubview(switchButton)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="在-viewDidLoad中实现"><a href="#在-viewDidLoad中实现" class="headerlink" title="在 viewDidLoad中实现"></a>在 viewDidLoad中实现</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    <span class="keyword">self</span>.mySwitch()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UISwitch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UISwitch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UISwitch-简介</title>
      <link href="/2017/12/14/Swift/Swift/UIKit/UISwitch-%E7%AE%80%E4%BB%8B/"/>
      <url>/2017/12/14/Swift/Swift/UIKit/UISwitch-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="UISwitch的常用属性"><a href="#UISwitch的常用属性" class="headerlink" title="UISwitch的常用属性"></a>UISwitch的常用属性</h1><blockquote><p>1.设置 UISwitch 打开时底图渐变颜色, 默认是从白变绿</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> onTintColor: <span class="type">UIColor</span>!</span><br></pre></td></tr></table></figure><blockquote><p>2.设置 UISwitch 关闭时底图渐变颜色, 默认是从白变绿    </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tintColor: <span class="type">UIColor</span>?</span><br></pre></td></tr></table></figure><blockquote><p>3.设置 UISwitch 的小圆点颜色, 默认是白色</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> thumbTintColor: <span class="type">UIColor</span>?</span><br></pre></td></tr></table></figure><blockquote><p>4.设置 UISwitch 是否打开</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> on: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>5.设置 UISwitch 的位置</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>(frame: <span class="type">CGRect</span>)</span><br></pre></td></tr></table></figure><blockquote><p>6.设置 UISwitch 是否打开, 并且是否打开动画效果</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setOn</span><span class="params">(on: Bool, animated: Bool)</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UISwitch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UISwitch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UITextField-简单使用</title>
      <link href="/2017/12/14/Swift/Swift/UIKit/UITextField-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/12/14/Swift/Swift/UIKit/UITextField-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="遵守代理协议"><a href="#遵守代理协议" class="headerlink" title="遵守代理协议"></a>遵守代理协议</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITextFieldDelegate</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="添加UITextField"><a href="#添加UITextField" class="headerlink" title="添加UITextField"></a>添加UITextField</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myTextField</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">// 1.创建UITextField, 并且设置它的Frame</span></span><br><span class="line">      textField.frame = <span class="type">CGRectMake</span>(<span class="number">100</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2.设置UITextField的背景颜色</span></span><br><span class="line">      textField.backgroundColor = <span class="type">UIColor</span>.greenColor()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3.设置UITextField的显示样式</span></span><br><span class="line">      textField.borderStyle = <span class="type">UITextBorderStyle</span>.<span class="type">RoundedRect</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4.设置UITextField的编辑状态, 默认是永远不打开, 这里设置的是在编辑时才打开</span></span><br><span class="line">      textField.clearButtonMode = <span class="type">UITextFieldViewMode</span>.<span class="type">WhileEditing</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 5.设置UITextField的键盘样式</span></span><br><span class="line">      textField.keyboardType = <span class="type">UIKeyboardType</span>.<span class="type">ASCIICapable</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 6.设置UITextField的首字母是否大写</span></span><br><span class="line">      textField.autocapitalizationType = <span class="type">UITextAutocapitalizationType</span>.<span class="type">Sentences</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 7.设置UITextField的键盘外观颜色</span></span><br><span class="line">      textField.keyboardAppearance = <span class="type">UIKeyboardAppearance</span>.<span class="type">Dark</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 8.设置UITextField的return样式</span></span><br><span class="line">      textField.returnKeyType = <span class="type">UIReturnKeyType</span>.<span class="type">Default</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 9.设置UITextField预输入的文字</span></span><br><span class="line">      textField.attributedText = <span class="type">NSAttributedString</span>(string: <span class="string">"ABCDEFG"</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 10.设置UITextField的提示文字</span></span><br><span class="line">      textField.placeholder = <span class="string">"请输入您的名字"</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 11.设置UITextField的代理对象</span></span><br><span class="line">      textField.delegate = <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 12.设置UITextField内容的垂直对齐方式, 默认是center</span></span><br><span class="line">      textField.contentVerticalAlignment = <span class="type">UIControlContentVerticalAlignment</span>.<span class="type">Top</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 13.再次编辑时对旧内容进行自动清除, 默认是false</span></span><br><span class="line">      textField.clearsOnBeginEditing = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 14.根据TextField的大小自动缩放字体大小, 默认是false</span></span><br><span class="line">      textField.adjustsFontSizeToFitWidth = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 15.添加到父视图</span></span><br><span class="line">      <span class="keyword">self</span>.view.addSubview(textField)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="实现代理方法"><a href="#实现代理方法" class="headerlink" title="实现代理方法"></a>实现代理方法</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">textFieldShouldReturn</span><span class="params">(textField: UITextField)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">       <span class="comment">// 取消第一响应者</span></span><br><span class="line">       textField.resignFirstResponder()</span><br><span class="line">       <span class="comment">// 返回true</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="在ViewDidload实现"><a href="#在ViewDidload实现" class="headerlink" title="在ViewDidload实现"></a>在ViewDidload实现</h1><blockquote><p>UITExtField不会自动换行的, 所以我们只可能限制用户所输入多少个字符, 如果需要自动换行, 那就需要去了解UITextVIew</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">       <span class="keyword">self</span>.myTextField()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UITextField </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UITextField </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UITxtxField-简介</title>
      <link href="/2017/12/14/Swift/Swift/UIKit/Swift-UIKit-UITxtxField-%E7%AE%80%E4%BB%8B/"/>
      <url>/2017/12/14/Swift/Swift/UIKit/Swift-UIKit-UITxtxField-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="UITxtxField的常用状态"><a href="#UITxtxField的常用状态" class="headerlink" title="UITxtxField的常用状态"></a>UITxtxField的常用状态</h1><h2 id="TextField边框的样式"><a href="#TextField边框的样式" class="headerlink" title="TextField边框的样式"></a>TextField边框的样式</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">UITextBorderStyle</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> <span class="comment">// TextField边框什么都没有, 默认是方角</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Line</span> <span class="comment">// TextField边框有一条黑色的实现围着, 默认也是方角的</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Bezel</span> <span class="comment">// TextField边框有两条线围着, 形成一定的层次感, 默认也是方角的</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">RoundedRect</span> <span class="comment">// TextField边框什么都没有, 默认是圆角</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TextField的快速删除状态"><a href="#TextField的快速删除状态" class="headerlink" title="TextField的快速删除状态"></a>TextField的快速删除状态</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">UITextFieldViewMode</span> : <span class="title">Int</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">case</span> <span class="type">Never</span> <span class="comment">// 永远都不打开</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">WhileEditing</span> <span class="comment">// 在编辑的状态才打开</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">UnlessEditing</span> <span class="comment">// 在非编辑的状态才打开</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Always</span> <span class="comment">// 一直打开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TextField的键盘样式"><a href="#TextField的键盘样式" class="headerlink" title="TextField的键盘样式"></a>TextField的键盘样式</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">UIKeyboardType</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Default</span> <span class="comment">// 显示默认的键盘</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">ASCIICapable</span> <span class="comment">// 显示所有ASCII表的所有字符</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">NumbersAndPunctuation</span> <span class="comment">// 数字和标点符号的键盘</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">URL</span> <span class="comment">// 输入网站所使用的键盘</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">NumberPad</span> <span class="comment">// 纯数字键盘</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">PhonePad</span> <span class="comment">// 为了方便输入手机号码所使用的键盘</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">NamePhonePad</span> <span class="comment">// 为了方便输入名字和电话号码所使用的键盘</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">EmailAddress</span> <span class="comment">// 面向邮箱所使用的键盘</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">DecimalPad</span> <span class="comment">// 面向带小数点的数字键盘</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Twitter</span> <span class="comment">// 面向Twitter等社交所使用的键盘, 为了方便@和#</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">WebSearch</span> <span class="comment">// 面向网站所使用的键盘</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TextField的大写样式"><a href="#TextField的大写样式" class="headerlink" title="TextField的大写样式"></a>TextField的大写样式</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">UITextAutocapitalizationType</span> : <span class="title">Int</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> <span class="comment">// 不自动大写</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Words</span> <span class="comment">// 单个单词首字母大写</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sentences</span> <span class="comment">// 句子首字母大写</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">AllCharacters</span> <span class="comment">// 全部大写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TextField的键盘外观颜色"><a href="#TextField的键盘外观颜色" class="headerlink" title="TextField的键盘外观颜色"></a>TextField的键盘外观颜色</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">UIKeyboardAppearance</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Default</span> <span class="comment">// 默认是光亮的</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Dark</span> <span class="comment">// 设置为黑暗颜色</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Light</span> <span class="comment">// 设置为光亮的颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TextField的Return样式"><a href="#TextField的Return样式" class="headerlink" title="TextField的Return样式"></a>TextField的Return样式</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">UIReturnKeyType</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Default</span> <span class="comment">// 模样的样式</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Go</span> <span class="comment">// 标着有Go的蓝色样式</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Google</span> <span class="comment">// 标着Google的蓝色样式, 用于语音搜索, 显示的样式是Search</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Join</span> <span class="comment">// 标有Join的蓝色按钮</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Next</span> <span class="comment">// 标着有Next的蓝色按钮</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Route</span> <span class="comment">// 标着有Route的蓝色按钮</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Search</span> <span class="comment">// 标着有Search的蓝色按钮</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Send</span> <span class="comment">// 标着有Send的蓝色按钮</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Yahoo</span> <span class="comment">// 标着有Yahoo的蓝色按钮, 显示的样式是Search</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Done</span> <span class="comment">// 标着有Done的蓝色按钮</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">EmergencyCall</span> <span class="comment">// 标着有EmergencyCall的蓝色按钮, 紧急呼救的按钮</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="TextField的右边显示图样式"><a href="#TextField的右边显示图样式" class="headerlink" title="TextField的右边显示图样式"></a>TextField的右边显示图样式</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">UITextFieldViewMode</span> : <span class="title">Int</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">case</span> <span class="type">Never</span> <span class="comment">// 永远不显示</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">WhileEditing</span> <span class="comment">// 在编辑的情况下显示</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">UnlessEditing</span> <span class="comment">// 在非编辑的情况下显示</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Always</span> <span class="comment">// 永远显示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UITextField的垂直排列方式"><a href="#UITextField的垂直排列方式" class="headerlink" title="UITextField的垂直排列方式"></a>UITextField的垂直排列方式</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">UIControlContentVerticalAlignment</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Center</span> <span class="comment">// 居中对齐, 默认</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Top</span> <span class="comment">// 顶部对齐</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Bottom</span> <span class="comment">// 底部对齐</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Fill</span> <span class="comment">// 平铺整个TextField的高度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UITextField的水平排列方式"><a href="#UITextField的水平排列方式" class="headerlink" title="UITextField的水平排列方式"></a>UITextField的水平排列方式</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">UIControlContentHorizontalAlignment</span> : <span class="title">Int</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">case</span> <span class="type">Center</span> <span class="comment">// 居中对齐</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Left</span> <span class="comment">// 左对齐, 默认</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Right</span> <span class="comment">// 右对齐</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Fill</span> <span class="comment">// 平铺整个TextField的宽度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="UITextField的常用属性"><a href="#UITextField的常用属性" class="headerlink" title="UITextField的常用属性"></a>UITextField的常用属性</h1><blockquote><p>字体颜色, 默认的字体颜色是黑色</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> textColor: <span class="type">UIColor</span>!</span><br></pre></td></tr></table></figure><blockquote><p>字体大小, 默认的字体大小是12</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">var</span> font: <span class="type">UIFont</span>!</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">&gt;字体对齐方式, 默认是向左对齐</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line">   <span class="keyword">var</span> textAlignment: <span class="type">NSTextAlignment</span></span><br></pre></td></tr></table></figure><blockquote><p>边框的样式, 默认是None. </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> borderStyle: <span class="type">UITextBorderStyle</span></span><br></pre></td></tr></table></figure><blockquote><p>快捷清楚的按钮, 默认是不打开的</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> clearButtonMode: <span class="type">UITextFieldViewMode</span></span><br></pre></td></tr></table></figure><blockquote><p>提示文本, 默认是nil, 字体颜色是70%的灰</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> placeholder: <span class="type">String</span>?</span><br></pre></td></tr></table></figure><blockquote><p>再次编辑时对旧内容进行自动清除, 默认是false</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> clearsOnBeginEditing: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>根据TextField的大小自动缩放字体大小, 默认是false</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> adjustsFontSizeToFitWidth: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><h1 id="常用代理方法"><a href="#常用代理方法" class="headerlink" title="常用代理方法"></a>常用代理方法</h1><blockquote><p>点击return会结束编辑, 也可以在这里设置取消TextField的第一响应者, 使键盘隐藏</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">textFieldShouldReturn</span><span class="params">(textField: UITextField)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>可限制文字输入的长度以及特定的字符, 如果返回true, 那么就是可以修改, 如果返回false就不可修改</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">textField</span><span class="params">(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UITxtxField </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UITxtxField </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UIImage-简单使用</title>
      <link href="/2017/12/14/Swift/Swift/UIKit/UIImage-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/12/14/Swift/Swift/UIKit/UIImage-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myImage</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 1.创建一个UIImageView, 并且设置它的frame</span></span><br><span class="line">       <span class="keyword">var</span> myImageView = <span class="type">UIImageView</span>(frame: <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.view.frame.size.width, <span class="keyword">self</span>.view.frame.size.height))</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2.设置UIImage的图片名, 以及展示的样式</span></span><br><span class="line">       <span class="keyword">var</span> myImage = <span class="type">UIImage</span>(named: <span class="string">"image_bate.jpg"</span>)?.imageWithRenderingMode(<span class="type">UIImageRenderingMode</span>.<span class="type">Automatic</span>)</span><br><span class="line">       <span class="comment">// 3.把UIImage添加到ImageView里面去</span></span><br><span class="line">       myImageView.image = myImage</span><br><span class="line"></span><br><span class="line">       <span class="keyword">self</span>.view.addSubview(myImageView)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>在viewDidload中实现:</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">       <span class="keyword">self</span>.myImage()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><blockquote><p>由于UIImage不能单独的拿出来展示, 它必须依赖于某个一个继承于UIView的一个View, 比如UIImageView或者UIButton, 这些都是可以的</p></blockquote>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UIImage </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UIImage </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UIImage-简介</title>
      <link href="/2017/12/14/Swift/Swift/UIKit/UIImage-%E7%AE%80%E4%BB%8B/"/>
      <url>/2017/12/14/Swift/Swift/UIKit/UIImage-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="UIImage的状态"><a href="#UIImage的状态" class="headerlink" title="UIImage的状态"></a>UIImage的状态</h1><blockquote><p>UIImageOrientation</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">UIImageOrientation</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Up</span> <span class="comment">//默认方向</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Down</span> <span class="comment">//180°旋转</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Left</span> <span class="comment">//逆时针旋转90°</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Right</span> <span class="comment">//顺时针旋转90°</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">UpMirrored</span> <span class="comment">//水平向上翻转</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">DownMirrored</span> <span class="comment">//水平向下翻转</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">LeftMirrored</span> <span class="comment">//逆时针旋转90°后再垂直翻转</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">RightMirrored</span> <span class="comment">//顺时针旋转90°后再垂直翻转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>UIImageResizingMode</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">UIImageResizingMode</span> : <span class="title">Int</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">case</span> <span class="type">Tile</span> <span class="comment">//平铺到调整完位置的图像</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Stretch</span> <span class="comment">//拉伸到调整完位置的图像</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>UIImageRenderingMode</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">UIImageRenderingMode</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Automatic</span> <span class="comment">//默认上下文显示的图像位置</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">AlwaysOriginal</span> <span class="comment">//总是以图片为模板</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">AlwaysTemplate</span> <span class="comment">//会把图像作为绘画的模板, 忽略其他颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常用的属性"><a href="#常用的属性" class="headerlink" title="常用的属性"></a>常用的属性</h1><blockquote><p>UIImage里面虽然有很多属性, 但唯一常用的属性就只有设置获取image名字的属性.</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>?(named name: <span class="type">String</span>) -&gt; <span class="type">UIImage</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UIImage </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UIImage </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UITableViewCell-简单使用</title>
      <link href="/2017/12/14/Swift/Swift/UIKit/UITableViewCell-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/12/14/Swift/Swift/UIKit/UITableViewCell-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="UITableViewCell-简单使用"><a href="#UITableViewCell-简单使用" class="headerlink" title="UITableViewCell-简单使用"></a>UITableViewCell-简单使用</h1><blockquote><p>由于 TableViewCell 是不可以单独存在的, 所以必须得依赖于 UITableView</p></blockquote><h1 id="遵守-TableView-代理协议以及数据源协议"><a href="#遵守-TableView-代理协议以及数据源协议" class="headerlink" title="遵守 TableView 代理协议以及数据源协议"></a>遵守 TableView 代理协议以及数据源协议</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDataSource</span>, <span class="title">UITableViewDelegate</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义-TableVIew"><a href="#自定义-TableVIew" class="headerlink" title="自定义 TableVIew"></a>自定义 TableVIew</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myTableView</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">var</span> tableView = <span class="type">UITableView</span>(frame: <span class="keyword">self</span>.view.frame, style: <span class="type">UITableViewStyle</span>.<span class="type">Plain</span>)</span><br><span class="line">       tableView.dataSource = <span class="keyword">self</span></span><br><span class="line">       tableView.delegate = <span class="keyword">self</span></span><br><span class="line">       <span class="keyword">self</span>.view.addSubview(tableView)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="实现数据源方法"><a href="#实现数据源方法" class="headerlink" title="实现数据源方法"></a>实现数据源方法</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfSectionsInTableView</span><span class="params">(tableView: UITableView)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="自定义-UITableViewCell"><a href="#自定义-UITableViewCell" class="headerlink" title="自定义 UITableViewCell"></a>自定义 UITableViewCell</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">        <span class="comment">// 1.自定义 UITableViewCell 的样式以及标签, reuseIdentifier 是 Cell 得标签, 作用和 Tag 类似</span></span><br><span class="line">        <span class="keyword">var</span> cell = <span class="type">UITableViewCell</span>(style: <span class="type">UITableViewCellStyle</span>.<span class="type">Value1</span>, reuseIdentifier: <span class="string">"cell"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.设置 UITableViewCell 的标题Label</span></span><br><span class="line">        cell.textLabel!.text = <span class="string">"我是 Cell"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.设置 UITableViewCell 的简介Label</span></span><br><span class="line">        cell.detailTextLabel?.text = <span class="string">"Cell"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.设置 UITableViewCell 的 imageView 图片</span></span><br><span class="line">        cell.imageView?.image = <span class="type">UIImage</span>(named: <span class="string">"image_black.jpg"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.设置 UITableViewCell 的编辑模式是否开启, 以及是否执行动画效果</span></span><br><span class="line">        cell.setEditing(<span class="literal">true</span>, animated: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.设置 UITableViewCell 的背景色</span></span><br><span class="line">        cell.backgroundColor = <span class="type">UIColor</span>.greenColor()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.设置 UITableViewCell 的编辑模式辅助按钮</span></span><br><span class="line">        cell.editingAccessoryType = <span class="type">UITableViewCellAccessoryType</span>.<span class="type">DisclosureIndicator</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8.设置 UITableViewCell 被选中的样式</span></span><br><span class="line">        cell.selectionStyle = <span class="type">UITableViewCellSelectionStyle</span>.<span class="type">Default</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 9.设置 UITableViewCell 分割线的位置</span></span><br><span class="line">        cell.separatorInset = <span class="type">UIEdgeInsetsMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 10.设置 UITableViewCell 被选中时的背景View</span></span><br><span class="line">        cell.selectedBackgroundView = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 11.设置 UITableViewCell 的辅助按钮样式</span></span><br><span class="line">        cell.accessoryType = <span class="type">UITableViewCellAccessoryType</span>.<span class="type">DisclosureIndicator</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回自定的 Cell</span></span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="开启-TableViewCell-的编辑模式"><a href="#开启-TableViewCell-的编辑模式" class="headerlink" title="开启 TableViewCell 的编辑模式"></a>开启 TableViewCell 的编辑模式</h1> <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath)</span></span> &#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UITableViewCell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UITableViewCell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UITableViewCell</title>
      <link href="/2017/12/14/Swift/Swift/UIKit/UITableViewCell-%E7%AE%80%E4%BB%8B/"/>
      <url>/2017/12/14/Swift/Swift/UIKit/UITableViewCell-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h1><h2 id="UITableViewCell-显示的样式"><a href="#UITableViewCell-显示的样式" class="headerlink" title="UITableViewCell 显示的样式"></a>UITableViewCell 显示的样式</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">UITableViewCellStyle</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Default</span> <span class="comment">// 默认显示样式</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Value1</span> <span class="comment">// 样式一</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Value2</span> <span class="comment">// 样式二</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Subtitle</span> <span class="comment">// 副标题样式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UITableViewCell-选中的样式"><a href="#UITableViewCell-选中的样式" class="headerlink" title="UITableViewCell 选中的样式"></a>UITableViewCell 选中的样式</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">UITableViewCellEditingStyle</span> : <span class="title">Int</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> <span class="comment">// 没有</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Delete</span> <span class="comment">// 删除</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Insert</span> <span class="comment">// 添加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UITableViewCell-辅助按钮的样式"><a href="#UITableViewCell-辅助按钮的样式" class="headerlink" title="UITableViewCell 辅助按钮的样式"></a>UITableViewCell 辅助按钮的样式</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">UITableViewCellAccessoryType</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> <span class="comment">// 没有按钮</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">DisclosureIndicator</span> <span class="comment">// 蓝色向右的箭头</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">DetailDisclosureButton</span> <span class="comment">// 蓝色向右的箭头以及信息按钮</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Checkmark</span> <span class="comment">// 复选框</span></span><br><span class="line">    @availability(iOS, introduced=<span class="number">7.0</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">DetailButton</span> <span class="comment">// 信息按钮</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UITableViewCell-常用属性"><a href="#UITableViewCell-常用属性" class="headerlink" title="UITableViewCell 常用属性"></a>UITableViewCell 常用属性</h2><blockquote><p>1.初始化 Cell 的 Style 以及标签名</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>(style: <span class="type">UITableViewCellStyle</span>, reuseIdentifier: <span class="type">String</span>?)</span><br></pre></td></tr></table></figure><blockquote><p>2.设置 Cell 的 ImageView 内容</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> imageView: <span class="type">UIImageView</span>? &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>3.设置 Cell 的 textLabel 的内容</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> textLabel: <span class="type">UILabel</span>? &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>4.设置 Cell 的 副标题内容</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> detailTextLabel: <span class="type">UILabel</span>? &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>5.设置 Cell 的内容 View</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> contentView: <span class="type">UIView</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>6.设置 Cell 的背景 View</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> backgroundView: <span class="type">UIView</span>?</span><br></pre></td></tr></table></figure><blockquote><p>7.设置 Cell 被选中时的背景 View</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> selectedBackgroundView: <span class="type">UIView</span>!</span><br></pre></td></tr></table></figure><blockquote><p>8.设置 Cell 多选中得背景 View</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> multipleSelectionBackgroundView: <span class="type">UIView</span>?</span><br></pre></td></tr></table></figure><blockquote><p>9.设置 Cell 被选中时的 Style</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> selectionStyle: <span class="type">UITableViewCellSelectionStyle</span></span><br></pre></td></tr></table></figure><blockquote><p>10.设置 Cell 编辑的 Style</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> editingStyle: <span class="type">UITableViewCellEditingStyle</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>11.设置 Cell 是否开启编辑状态</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> editing: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>12.设置 Cell 的辅助按钮样式</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> accessoryType: <span class="type">UITableViewCellAccessoryType</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UITableViewCell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UITableViewCell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UITableView-简单使用</title>
      <link href="/2017/12/13/Swift/Swift/UIKit/UITableView-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/12/13/Swift/Swift/UIKit/UITableView-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="遵守代理协议和数据源协议"><a href="#遵守代理协议和数据源协议" class="headerlink" title="遵守代理协议和数据源协议"></a>遵守代理协议和数据源协议</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDelegate</span>, <span class="title">UITableViewDataSource</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义-UITableView"><a href="#自定义-UITableView" class="headerlink" title="自定义 UITableView"></a>自定义 UITableView</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myTableView</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="comment">// 1.设置 TableView 的 frame 和 style</span></span><br><span class="line">       <span class="keyword">var</span> tableView: <span class="type">UITableView</span> = <span class="type">UITableView</span>(frame: <span class="keyword">self</span>.view.frame, style: <span class="type">UITableViewStyle</span>.<span class="type">Plain</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2.设置 TableView 的背景色</span></span><br><span class="line">       tableView.backgroundColor = <span class="type">UIColor</span>(red: <span class="number">0.0</span>, green: <span class="number">127.0</span>, blue: <span class="number">127.0</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3.设置 TableView 的代理对象</span></span><br><span class="line">       tableView.delegate = <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 4.设置 TableView 的数据源对象</span></span><br><span class="line">       tableView.dataSource = <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 5.设置 TableView 每一行 Cell 的高度</span></span><br><span class="line">       tableView.rowHeight = <span class="number">44</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 6.设置 TableView 每一行 Cell 页头的行高</span></span><br><span class="line">       tableView.sectionHeaderHeight = <span class="number">50</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 7.设置 TableView 每一行 Cell 页尾的行高</span></span><br><span class="line">       tableView.sectionFooterHeight = <span class="number">50</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 8.设置 TableView 每一行 Cell 的估计行高</span></span><br><span class="line">       tableView.estimatedRowHeight = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 9.设置 TableView 每一行 Cell 的页头估计行高</span></span><br><span class="line">       tableView.estimatedSectionHeaderHeight = <span class="number">50</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 10.设置 TableView 每一行 Cell 的页尾估计行高</span></span><br><span class="line">       tableView.estimatedSectionFooterHeight = <span class="number">50</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 11.设置 TableView 每一行 Cell 之间分割线位置(分别是: 上, 左, 下, 右)</span></span><br><span class="line">       tableView.separatorInset = <span class="type">UIEdgeInsetsMake</span>(<span class="number">0</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 12.设置 TableView 每一行 Cell 之间分割线的颜色</span></span><br><span class="line">       tableView.separatorColor = <span class="type">UIColor</span>.redColor()</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 13.设置 TableView 每一行 Cell 之间的分割效果(暂无方法, 目前只是用来实例化)</span></span><br><span class="line">       tableView.separatorEffect = <span class="type">UIVisualEffect</span>()</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 14.设置 TableView 每一行 Cell 之间的分割线样式(默认是 SingleLine 样式)</span></span><br><span class="line">       tableView.separatorStyle = <span class="type">UITableViewCellSeparatorStyle</span>.<span class="type">SingleLine</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 15.设置 TableView 的背景 View 对象</span></span><br><span class="line">       tableView.backgroundView = <span class="type">UIView</span>()</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 16.设置 TableView 的编辑模式是否开启, 并且是否使用动画效果</span></span><br><span class="line">       tableView.setEditing(<span class="literal">true</span>, animated: <span class="literal">true</span>)</span><br><span class="line">       <span class="comment">// 17.添加到 self.view 上</span></span><br><span class="line">       <span class="keyword">self</span>.view.addSubview(tableView)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="实现代理方法和数据源方法"><a href="#实现代理方法和数据源方法" class="headerlink" title="实现代理方法和数据源方法"></a>实现代理方法和数据源方法</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.该方法是用来设置 TableView 有多少组 Cell</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">numberOfSectionsInTableView</span><span class="params">(tableView: UITableView)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.该方法是用来设置 TableView 有多少行 Cell</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.该方法是用来设置 TableView 每一行 Cell 的详细内容</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> cell = <span class="type">UITableViewCell</span>()</span><br><span class="line">      cell.backgroundColor = <span class="type">UIColor</span>.blueColor()</span><br><span class="line">      <span class="keyword">return</span> cell</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.该方法是用来设置 TableView 每一行 Cell 的标题内容</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, titleForHeaderInSection section: Int)</span></span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"我是页头"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5.该方法是用来设置 TableView 每一行 Cell 的页尾内容</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, titleForFooterInSection section: Int)</span></span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"我是页尾"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6.该方法是用来设置 TableView 每一行 Cell 的高度, 一旦这里设置了, 那么在自定义里的 rowHeight 属性就会被覆盖</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 7.该方法是用来响应 TableVIewCell 被点击的事件</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath)</span></span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">"我被点击了"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 8.该方法是用来设置 TableView 每一行 Cell 的编辑模式, 如果不设置, 默认都是删除</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, editingStyleForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCellEditingStyle</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">UITableViewCellEditingStyle</span>.<span class="type">Insert</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 9.该方法是用来设置 Tabelview 的左滑快捷按钮, 只要写了该方法, 默认打开</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath)</span></span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 10.该方法是用来设置 TabelView 左滑快捷按钮的详细内容以及操作</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, titleForDeleteConfirmationButtonForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">String</span>! &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"删除"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 11.该方法是用来设置 TableView 是否可以拖拽到其他行数, 只要写了该方法, 默认打开</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, moveRowAtIndexPath sourceIndexPath: NSIndexPath, toIndexPath destinationIndexPath: NSIndexPath)</span></span> &#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UITableView </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UITableView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UITableView-简介</title>
      <link href="/2017/12/13/Swift/Swift/UIKit/UITableView-%E7%AE%80%E4%BB%8B/"/>
      <url>/2017/12/13/Swift/Swift/UIKit/UITableView-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="UITableview常用属性"><a href="#UITableview常用属性" class="headerlink" title="UITableview常用属性"></a>UITableview常用属性</h1><h2 id="UITableView-的样式"><a href="#UITableView-的样式" class="headerlink" title="UITableView 的样式"></a>UITableView 的样式</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">UITableViewStyle</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Plain</span> <span class="comment">// 平铺样式</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Grouped</span> <span class="comment">// 分组样式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UITableView-添加或者删除-Cell-时的动画"><a href="#UITableView-添加或者删除-Cell-时的动画" class="headerlink" title="UITableView 添加或者删除 Cell 时的动画"></a>UITableView 添加或者删除 Cell 时的动画</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">UITableViewRowAnimation</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Fade</span> <span class="comment">// 淡入淡出</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Right</span> <span class="comment">// 从右添加</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Left</span> <span class="comment">// 从左添加</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Top</span> <span class="comment">// 从上添加</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Bottom</span> <span class="comment">// 从底部添加</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> <span class="comment">// 没有动画</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Middle</span> <span class="comment">// 从中间添加</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Automatic</span> <span class="comment">// 随机添加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UITableView-滚动时指定的位置"><a href="#UITableView-滚动时指定的位置" class="headerlink" title="UITableView 滚动时指定的位置"></a>UITableView 滚动时指定的位置</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">UITableViewScrollPosition</span> : <span class="title">Int</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> <span class="comment">// 不指定</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Top</span> <span class="comment">// 指定上面</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Middle</span> <span class="comment">// 指定中间</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Bottom</span> <span class="comment">// 指定底部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UITableView-分割线的样式"><a href="#UITableView-分割线的样式" class="headerlink" title="UITableView 分割线的样式"></a>UITableView 分割线的样式</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">UITableViewCellSeparatorStyle</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> <span class="comment">// 没有分割线</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">SingleLine</span> <span class="comment">// 单行分割线</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">SingleLineEtched</span> <span class="comment">// 多行分割线融合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UITableView-属性"><a href="#UITableView-属性" class="headerlink" title="UITableView 属性"></a>UITableView 属性</h2><blockquote><p>1.设置 UITableView 的位置以及Style</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">init</span>(frame: <span class="type">CGRect</span>, style: <span class="type">UITableViewStyle</span>)    </span><br><span class="line"><span class="keyword">var</span> style: <span class="type">UITableViewStyle</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.设置数据源对象</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unowned</span>(unsafe) <span class="keyword">var</span> dataSource: <span class="type">UITableViewDataSource</span>?</span><br></pre></td></tr></table></figure><blockquote><p>3.设置代理对象</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unowned</span>(unsafe) <span class="keyword">var</span> delegate: <span class="type">UITableViewDelegate</span>?</span><br></pre></td></tr></table></figure><blockquote><p>4.设置 Cell 的行高</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rowHeight: <span class="type">CGFloat</span></span><br></pre></td></tr></table></figure><blockquote><p>5.设置 Cell 的标题高度</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sectionHeaderHeight: <span class="type">CGFloat</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">&gt; <span class="number">6</span>.设置 <span class="type">Cell</span> 的页尾高度</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line"><span class="keyword">var</span> sectionFooterHeight: <span class="type">CGFloat</span></span><br></pre></td></tr></table></figure><blockquote><p>7.设置估计的 Cell 的行高</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> estimatedRowHeight: <span class="type">CGFloat</span></span><br></pre></td></tr></table></figure><blockquote><p>8.设置估计的 Cell 的标题行高</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> estimatedSectionHeaderHeight: <span class="type">CGFloat</span></span><br></pre></td></tr></table></figure><blockquote><p>9.设置估计的 Cell 的页尾行高</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> estimatedSectionFooterHeight: <span class="type">CGFloat</span></span><br></pre></td></tr></table></figure><blockquote><p>10.设置 Cell 与 Cell 之间的分割线位置</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> separatorInset: <span class="type">UIEdgeInsets</span></span><br></pre></td></tr></table></figure><blockquote><p>11.设置 UITableView 的背景 View 对象</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> backgroundView: <span class="type">UIView</span>?</span><br></pre></td></tr></table></figure><h1 id="常用数据源方法"><a href="#常用数据源方法" class="headerlink" title="常用数据源方法"></a>常用数据源方法</h1><ul><li>要使用数据源方法(DataSoucre方法), 首先我们需要遵守 UITableView 的数据源方法(UITableViewDataSoucre)协议</li></ul><blockquote><p>1.该方法是用来设置 TableView 有多少行 Cell</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure><blockquote><p>2.该方法是用来设置 TableView 每一行 Cell 的详细内容</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span></span><br></pre></td></tr></table></figure><blockquote><p>3.该方法是用来设置 TableView 有多少组 Cell</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">numberOfSectionsInTableView</span><span class="params">(tableView: UITableView)</span></span> -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure><blockquote><p>4.该方法是用来设置每一组 Cell 的标题内容</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, titleForHeaderInSection section: Int)</span></span> -&gt; <span class="type">String</span>?</span><br></pre></td></tr></table></figure><blockquote><p>5.该方法是用来设置每一组 Cell 的页尾内容</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, titleForFooterInSection section: Int)</span></span> -&gt; <span class="type">String</span>?</span><br></pre></td></tr></table></figure><blockquote><p>6.该方法使用来设置 TableView 左滑快捷</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">optional func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath)</span><br></pre></td></tr></table></figure><blockquote><p>7.该方法是用来设置 TableView 是否可以拖拽到其他行数, 只要写了该方法, 默认打开</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, moveRowAtIndexPath sourceIndexPath: NSIndexPath, toIndexPath destinationIndexPath: NSIndexPath)</span></span></span><br></pre></td></tr></table></figure><h1 id="常用代理方法"><a href="#常用代理方法" class="headerlink" title="常用代理方法"></a>常用代理方法</h1><blockquote><p>1.该方法是用来设置每一行 Cell 的高度</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">CGFloat</span></span><br></pre></td></tr></table></figure><blockquote><p>2.该方法是用来设置 Cell 标题内容的高度(如果该方法使用了, 那么在自定义 TableView 的sectionHeaderHeight属性就会被覆盖)</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, heightForHeaderInSection section: Int)</span></span> -&gt; <span class="type">CGFloat</span></span><br></pre></td></tr></table></figure><blockquote><p>3.该方法是用来设置 Cell 页尾内容的高度(如果该方法使用了, 那么在自定义 TableView 的sectionFooterHeight属性就会被覆盖)</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, heightForFooterInSection section: Int)</span></span> -&gt; <span class="type">CGFloat</span></span><br></pre></td></tr></table></figure><blockquote><p>4.该方法是用来设置 TableView 左滑快捷按钮的内容以及详细操作</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, titleForDeleteConfirmationButtonForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">String</span>!</span><br></pre></td></tr></table></figure><blockquote><p>5.该方法是用来设置 TableView 每一行 Cell 的编辑模式, 如果不设置, 默认都是删除</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, editingStyleForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCellEditingStyle</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UITableView </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UITableView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UIScrollView-简单使用</title>
      <link href="/2017/12/13/Swift/Swift/UIKit/UIScrollView-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/12/13/Swift/Swift/UIKit/UIScrollView-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="实例化UIScrollView-UIImageView-UIImage"><a href="#实例化UIScrollView-UIImageView-UIImage" class="headerlink" title="实例化UIScrollView, UIImageView, UIImage"></a>实例化UIScrollView, UIImageView, UIImage</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UIScrollViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scrollView =  <span class="type">UIScrollView</span>()</span><br><span class="line">    <span class="keyword">var</span> imageView =  <span class="type">UIImageView</span>()</span><br><span class="line">    <span class="keyword">var</span> imageURL = <span class="type">UIImage</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设置UIScrollView"><a href="#设置UIScrollView" class="headerlink" title="设置UIScrollView"></a>设置UIScrollView</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myScrollView</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">// 1.1设置ScrollView的Frame</span></span><br><span class="line">      scrollView.frame = <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.view.frame.width, <span class="keyword">self</span>.view.frame.height)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1.2设置ScrollView的边距</span></span><br><span class="line">      scrollView.contentInset = <span class="type">UIEdgeInsetsMake</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1.3设置ScrollView的代理</span></span><br><span class="line">      scrollView.delegate = <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1.4设置ScrollView的最小缩放比例</span></span><br><span class="line">      scrollView.minimumZoomScale = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1.5设置ScrollView的最大缩放比例</span></span><br><span class="line">      scrollView.maximumZoomScale = <span class="number">1.5</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1.6添加到父视图</span></span><br><span class="line">      <span class="keyword">self</span>.view.addSubview(scrollView)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="设置UIImageView"><a href="#设置UIImageView" class="headerlink" title="设置UIImageView"></a>设置UIImageView</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myImageView</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">// 2.1设置ImageView的图片</span></span><br><span class="line">      imageURL = <span class="type">UIImage</span>(named: <span class="string">"image_landscape3.jpg"</span>)!</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2.2设置添加图片的方法以及对象</span></span><br><span class="line">      <span class="keyword">self</span>.setImage(imageURL)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2.3添加到ScrollView上</span></span><br><span class="line">      scrollView.addSubview(imageView)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="设置UIImage"><a href="#设置UIImage" class="headerlink" title="设置UIImage"></a>设置UIImage</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setImage</span> <span class="params">(image: UIImage)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 3.1设置image对象</span></span><br><span class="line">        imageURL = image</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2设置imageView的image内容</span></span><br><span class="line">        imageView.image = image</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.3设置imageView根据image自动调整大小</span></span><br><span class="line">        imageView.sizeToFit()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.4设置ScrollView的内容大小为image的大小</span></span><br><span class="line">        scrollView.contentSize = image.size</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UIScrollView </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UIScrollView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UIScrollView-简介</title>
      <link href="/2017/12/13/Swift/Swift/UIKit/UIScrollView-%E7%AE%80%E4%BB%8B/"/>
      <url>/2017/12/13/Swift/Swift/UIKit/UIScrollView-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="UIScrollView的常用属性"><a href="#UIScrollView的常用属性" class="headerlink" title="UIScrollView的常用属性"></a>UIScrollView的常用属性</h1><blockquote><p> 设置内容的中心点, 默认是0</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> contentOffset: <span class="type">CGPoint</span></span><br></pre></td></tr></table></figure><blockquote><p>设置内容的宽高, 默认是0</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> contentSize: <span class="type">CGSize</span></span><br></pre></td></tr></table></figure><blockquote><p>设置UIScrollView的边距, 默认是0</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> contentInset: <span class="type">UIEdgeInsets</span></span><br></pre></td></tr></table></figure><blockquote><p>设置UIScrollView是否可以翻页, 默认是false</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pagingEnabled: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>设置UIScrollView是否可用, 默认是true </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scrollEnabled: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>设置UIScrollView的水平滚动, 默认是true</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> showsHorizontalScrollIndicator: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>设置UIScrollView的垂直滚动, 默认是true</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> showsVerticalScrollIndicator: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>设置UIScrollView滚动条显示的位置, 默认是0</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scrollIndicatorInsets: <span class="type">UIEdgeInsets</span></span><br></pre></td></tr></table></figure><blockquote><p>设置最小的缩放比例, 默认是1.0</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minimumZoomScale: <span class="type">CGFloat</span></span><br></pre></td></tr></table></figure><blockquote><p>设置最大的缩放比例, 默认是1.0</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maximumZoomScale: <span class="type">CGFloat</span></span><br></pre></td></tr></table></figure><blockquote><p>设置点击状态栏就回到ScrollView的最顶部, 默认是true</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scrollsToTop: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>设置缩放视图时是否有弹簧效果, 默认是true</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bouncesZoom: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>设置ScrollView是否滚动时是否有弹簧效果, 默认是true</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bounces: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><h1 id="UIScrollView的常用方法"><a href="#UIScrollView的常用方法" class="headerlink" title="UIScrollView的常用方法"></a>UIScrollView的常用方法</h1><blockquote><p>拖拽视图时调用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidScroll</span><span class="params">(scrollView: UIScrollView)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>刚开始拖拽视图的时候调用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewWillBeginDragging</span><span class="params">(scrollView: UIScrollView)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>拖拽停止的时候调用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidEndDragging</span><span class="params">(scrollView: UIScrollView, willDecelerate decelerate: Bool)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>当视图滚动速度开始减慢的时候调用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewWillBeginDecelerating</span><span class="params">(scrollView: UIScrollView)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>当拖拽的视图完全停下来后才调用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidEndDecelerating</span><span class="params">(scrollView: UIScrollView)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>当ScrollView的动画执行完之后才调用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidEndScrollingAnimation</span><span class="params">(scrollView: UIScrollView)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>设置视图的比例放大或者缩小</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">optional func viewForZoomingInScrollView(scrollView: UIScrollView) -&gt; UIView?</span><br></pre></td></tr></table></figure><blockquote><p>当完成比例放大或者缩小的时候调用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidEndZooming</span><span class="params">(scrollView: UIScrollView, withView view: UIView!, atScale scale: CGFloat)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>是否可以点击状态栏回到最顶部, 默认是true</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewShouldScrollToTop</span><span class="params">(scrollView: UIScrollView)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>当点击状态栏回到顶部的时候才调用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidScrollToTop</span><span class="params">(scrollView: UIScrollView)</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UIScrollView </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UIScrollView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UITextView-简单使用</title>
      <link href="/2017/12/13/Swift/Swift/UIKit/Swift-UIKit-UITextView-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/12/13/Swift/Swift/UIKit/Swift-UIKit-UITextView-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="遵守代理协议"><a href="#遵守代理协议" class="headerlink" title="遵守代理协议"></a>遵守代理协议</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITextViewDelegate</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义UITextView"><a href="#自定义UITextView" class="headerlink" title="自定义UITextView"></a>自定义UITextView</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myTextView</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 1.自定义 UITextView 以及文本容器的大小</span></span><br><span class="line">       <span class="keyword">var</span> textView = <span class="type">UITextView</span>(frame: <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">200</span>, <span class="keyword">self</span>.view.frame.width, <span class="number">200</span>))</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2.设置 UITextView 的文本内容</span></span><br><span class="line">       textView.text = <span class="string">"http://www.baidu.com\nabcdefghijk"</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3.设置 UITextView 的文本颜色</span></span><br><span class="line">       textView.textColor = <span class="type">UIColor</span>.redColor()</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 4.设置 UITextView 的文字大小</span></span><br><span class="line">       textView.font = <span class="type">UIFont</span>.systemFontOfSize(<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 5.设置 UITextView 的文字对齐方式</span></span><br><span class="line">       textView.textAlignment = <span class="type">NSTextAlignment</span>.<span class="type">Center</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 6.设置 UITextView 是否可编辑</span></span><br><span class="line">       textView.editable = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 7.设置 UITextView 是否可以选中</span></span><br><span class="line">       textView.selectable = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 8.设置 UITextView 的背景颜色</span></span><br><span class="line">       textView.backgroundColor = <span class="type">UIColor</span>.greenColor()</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 9.设置 UITextView 的超文本样式</span></span><br><span class="line">       textView.dataDetectorTypes = <span class="type">UIDataDetectorTypes</span>.<span class="type">All</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 10.设置 UITextView 的文本长按时是否可以更改为粗体, 斜体或者斜体下划线样式</span></span><br><span class="line">       textView.allowsEditingTextAttributes = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 11.设置 UITextView 的文本容器边界</span></span><br><span class="line">       textView.textContainerInset = <span class="type">UIEdgeInsetsMake</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 12.设置 UITextView 是否点击编辑时把旧内容全选</span></span><br><span class="line">       textView.clearsOnInsertion = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 13.设置 UITextView 的代理对象</span></span><br><span class="line">       textView.delegate = <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 14.添加到 self.view</span></span><br><span class="line">       <span class="keyword">self</span>.view.addSubview(textView)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="实现代理方法"><a href="#实现代理方法" class="headerlink" title="实现代理方法"></a>实现代理方法</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.该方法是用来设置 UITextView 是否可以编辑</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">textViewShouldBeginEditing</span><span class="params">(textView: UITextView)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">"正在开始编辑"</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.该方法是用来设置 UITextView 是否可以结束编辑</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">textViewShouldEndEditing</span><span class="params">(textView: UITextView)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">"正在结束编辑"</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.该方法是用来设置 UITextView 在开始编辑时调用</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">textViewDidBeginEditing</span><span class="params">(textView: UITextView)</span></span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">"开始编辑"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.该方法是用来设置 UITextView 在结束编辑时调用</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">textViewDidEndEditing</span><span class="params">(textView: UITextView)</span></span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">"结束编辑"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5.该方法是用来设置 UITextView 内容是否可更改</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">textView</span><span class="params">(textView: UITextView, shouldChangeTextInRange range: NSRange, replacementText text: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">"正在更改内容"</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6.该方法是用来设置 UITextView 内容更改后时调用</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">textViewDidChange</span><span class="params">(textView: UITextView)</span></span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">"内容已经改变"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 7.该方法是用来选择需要更改内容的 UITextView</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">textViewDidChangeSelection</span><span class="params">(textView: UITextView)</span></span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">"已经选择要更改内容的文本框"</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="在-viewDidLoad-调用"><a href="#在-viewDidLoad-调用" class="headerlink" title="在 viewDidLoad 调用"></a>在 viewDidLoad 调用</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">       <span class="keyword">self</span>.myTextView()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UITextView </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UITextView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UITextView-简介</title>
      <link href="/2017/12/13/Swift/Swift/UIKit/Swift-UIKit-UITextView-%E7%AE%80%E4%BB%8B/"/>
      <url>/2017/12/13/Swift/Swift/UIKit/Swift-UIKit-UITextView-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="UITextView常用属性"><a href="#UITextView常用属性" class="headerlink" title="UITextView常用属性"></a>UITextView常用属性</h1><blockquote><p>1.设置 UITextView 的文字</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text: <span class="type">String</span>!</span><br></pre></td></tr></table></figure><blockquote><p>2.设置 UITextView 的字体大小</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> font: <span class="type">UIFont</span>!</span><br></pre></td></tr></table></figure><blockquote><p>3.设置 UITextView 的字体颜色</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> textColor: <span class="type">UIColor</span>!</span><br></pre></td></tr></table></figure><blockquote><p>4.设置 UITextView 的字体排序, 默认是从左往右</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> textAlignment: <span class="type">NSTextAlignment</span></span><br></pre></td></tr></table></figure><blockquote><p>5.设置 UITextView 是否可编辑</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> editable: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>6.设置 UITextView 是否可以点击</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> selectable: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>7.设置 UITextView 的超文本样式</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dataDetectorTypes: <span class="type">UIDataDetectorTypes</span></span><br></pre></td></tr></table></figure><blockquote><p>8.设置 UITextView 在长按下是否可以选择不同的文字样式</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> allowsEditingTextAttributes: <span class="type">Bool</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">&gt; <span class="number">9</span>.设置 <span class="type">UITextView</span> 的文本容器边界</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line"><span class="keyword">var</span> textContainerInset: <span class="type">UIEdgeInsets</span></span><br></pre></td></tr></table></figure><blockquote><p>10.设置 UITextView 是否点击编辑时把旧内容全选</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> clearsOnInsertion: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><h1 id="UITextView-的代理方法"><a href="#UITextView-的代理方法" class="headerlink" title="UITextView 的代理方法"></a>UITextView 的代理方法</h1><blockquote><p>1.该方法是用来设置 UITextView 是否可以编辑</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">textViewShouldBeginEditing</span><span class="params">(textView: UITextView)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>2.该方法是用来设置 UITextView 是否可以结束编辑</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">textViewShouldEndEditing</span><span class="params">(textView: UITextView)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>3.该方法是用来设置 UITextView 在开始编辑时调用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">textViewDidBeginEditing</span><span class="params">(textView: UITextView)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>4.该方法是用来设置 UITextView 在结束编辑时调用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">textViewDidEndEditing</span><span class="params">(textView: UITextView)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>5.该方法是用来设置 UITextView 内容是否可更改</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">textView</span><span class="params">(textView: UITextView, shouldChangeTextInRange range: NSRange, replacementText text: String)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>6.该方法是用来设置 UITextView 内容更改后时调用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">textViewDidChange</span><span class="params">(textView: UITextView)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>7.该方法是用来选择需要更改内容的 UITextView</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">textViewDidChangeSelection</span><span class="params">(textView: UITextView)</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UITextView </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UITextView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UIActionSheet-简单使用</title>
      <link href="/2017/12/13/Swift/Swift/UIKit/UIActionSheet-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/12/13/Swift/Swift/UIKit/UIActionSheet-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="遵守代理协议"><a href="#遵守代理协议" class="headerlink" title="遵守代理协议"></a>遵守代理协议</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UIActionSheetDelegate</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义UIButton并且监听-ActionSheet-方法"><a href="#自定义UIButton并且监听-ActionSheet-方法" class="headerlink" title="自定义UIButton并且监听 ActionSheet 方法"></a>自定义UIButton并且监听 ActionSheet 方法</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myButton</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> button: <span class="type">UIButton</span> = <span class="type">UIButton</span>.buttonWithType(<span class="type">UIButtonType</span>.<span class="type">System</span>) <span class="keyword">as</span>! <span class="type">UIButton</span></span><br><span class="line">        button.frame = <span class="type">CGRectMake</span>(<span class="number">100</span>, <span class="number">200</span>, <span class="number">50</span>, <span class="number">20</span>)</span><br><span class="line">        button.setTitle(<span class="string">"弹窗"</span>, forState: <span class="type">UIControlState</span>.<span class="type">Normal</span>)</span><br><span class="line">        button.backgroundColor = <span class="type">UIColor</span>.redColor()</span><br><span class="line">        button.addTarget(<span class="keyword">self</span>, action: <span class="string">"myActionSheet"</span>, forControlEvents: <span class="type">UIControlEvents</span>.<span class="type">TouchUpInside</span>)</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(button)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="自定义UIActionSheet"><a href="#自定义UIActionSheet" class="headerlink" title="自定义UIActionSheet"></a>自定义UIActionSheet</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myActionSheet</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">// 1.自定义 UIActionSheet, 并且设置标题, 代理对象, 以及按钮的标题</span></span><br><span class="line">      <span class="keyword">var</span> actionSheet = <span class="type">UIActionSheet</span>(title: <span class="string">"UIActionSheet"</span>, delegate: <span class="keyword">self</span>, cancelButtonTitle: <span class="string">"取消"</span>, destructiveButtonTitle: <span class="string">"按钮一"</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2.设置 UIActionSheet 的样式</span></span><br><span class="line">      actionSheet.actionSheetStyle = <span class="type">UIActionSheetStyle</span>.<span class="type">Default</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3.设置取消按钮的索引</span></span><br><span class="line">      actionSheet.cancelButtonIndex = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4.设置destructive的索引值</span></span><br><span class="line">      actionSheet.destructiveButtonIndex = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 5.添加其他按钮的标题</span></span><br><span class="line">      actionSheet.addButtonWithTitle(<span class="string">"按钮二"</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 6.设置按钮标题的索引</span></span><br><span class="line">      actionSheet.buttonTitleAtIndex(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 7.显示到 self.view 上</span></span><br><span class="line">       actionSheet.showInView(<span class="keyword">self</span>.view)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="实现UIActionSheet代理方法"><a href="#实现UIActionSheet代理方法" class="headerlink" title="实现UIActionSheet代理方法"></a>实现UIActionSheet代理方法</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.该方法是在 UIActionSheet 上的按钮被点击时调用的</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">actionSheet</span><span class="params">(actionSheet: UIActionSheet, clickedButtonAtIndex buttonIndex: Int)</span></span> &#123;</span><br><span class="line">     <span class="built_in">println</span>(<span class="string">"被点击了"</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 2.该方法是在 UIActionSheet 上的点击了取消按钮时调用的</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">actionSheetCancel</span><span class="params">(actionSheet: UIActionSheet)</span></span> &#123;</span><br><span class="line">     <span class="built_in">println</span>(<span class="string">"点击了取消按钮"</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 3.该方法是在 UIActionSheet 完全即将显示的时候调用的</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">willPresentActionSheet</span><span class="params">(actionSheet: UIActionSheet)</span></span> &#123;</span><br><span class="line">     <span class="built_in">println</span>(<span class="string">"UIActionSheet即将显示"</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 4.该方法是在 UIActionSheet 完全显示的时候调用的</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">didPresentActionSheet</span><span class="params">(actionSheet: UIActionSheet)</span></span> &#123;</span><br><span class="line">     <span class="built_in">println</span>(<span class="string">"UIActionSheet完全显示"</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 5.该方法是在 UIActionSheet 完全即将消失的时候调用的</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">actionSheet</span><span class="params">(actionSheet: UIActionSheet, willDismissWithButtonIndex buttonIndex: Int)</span></span> &#123;</span><br><span class="line">     <span class="built_in">println</span>(<span class="string">"UIActionSheet即将消失"</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 6.该方法是在 UIActionSheet 完全消失的时候调用的</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">actionSheet</span><span class="params">(actionSheet: UIActionSheet, didDismissWithButtonIndex buttonIndex: Int)</span></span> &#123;</span><br><span class="line">     <span class="built_in">println</span>(<span class="string">"UIActionSheet完全消失"</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="在viewDidLoad实现"><a href="#在viewDidLoad实现" class="headerlink" title="在viewDidLoad实现"></a>在viewDidLoad实现</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">       <span class="keyword">self</span>.myButton()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UIActionSheet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UIActionSheet </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UIActionSheet-简介</title>
      <link href="/2017/12/13/Swift/Swift/UIKit/UIActionSheet-%E7%AE%80%E4%BB%8B/"/>
      <url>/2017/12/13/Swift/Swift/UIKit/UIActionSheet-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="UIActionSheet常用属性"><a href="#UIActionSheet常用属性" class="headerlink" title="UIActionSheet常用属性"></a>UIActionSheet常用属性</h1><blockquote><p>1.设置 UIActionSheet 的代理对象</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> delegate: <span class="type">UIActionSheetDelegate</span>?</span><br></pre></td></tr></table></figure><blockquote><p>2.设置 UIActionSheet 的标题</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> title: <span class="type">String</span></span><br></pre></td></tr></table></figure><blockquote><p>3.设置 UIActionSheet 的样式</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> actionSheetStyle: <span class="type">UIActionSheetStyle</span></span><br></pre></td></tr></table></figure><blockquote><p>4.读取 UIActionSheet 里有多少个按钮</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numberOfButtons: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>5.设置 UIActionSheet 取消按钮的索引</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cancelButtonIndex: <span class="type">Int</span></span><br></pre></td></tr></table></figure><blockquote><p>6.设置其他按钮的索引</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> destructiveButtonIndex: <span class="type">Int</span></span><br></pre></td></tr></table></figure><blockquote><p>7.读取 UIActionSheet 其他按钮的索引值</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstOtherButtonIndex: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>8.读取 UIActionSheet 是否可见</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> visible: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><h1 id="UIActionSheet的常用方法"><a href="#UIActionSheet的常用方法" class="headerlink" title="UIActionSheet的常用方法"></a>UIActionSheet的常用方法</h1><blockquote><p>1.该方法是用来添加 UIActionSheet 的按钮标题</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addButtonWithTitle</span><span class="params">(title: String)</span></span> -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure><blockquote><p>2.该方法是用来设置 UIActionSheet 的按钮索引</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buttonTitleAtIndex</span><span class="params">(buttonIndex: Int)</span></span> -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure><blockquote><p>3.该方法是来用设置 UIActionSheet 显示到 ToolBar</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showFromToolbar</span><span class="params">(view: UIToolbar!)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>4.该方法是用来设置 UIActionSheet 显示到 TabBar</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showFromTabBar</span><span class="params">(view: UITabBar!)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>5.该方法是用来设置来自 UIBarButtonItem 的 UIActionSheet, 并且是否开启动画效果</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showFromBarButtonItem</span><span class="params">(item: UIBarButtonItem!, animated: Bool)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>6.该方法是用来设置 UIActionSheet 的显示的视图大小, 以及指定视图和是否开启动画效果</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showFromRect</span><span class="params">(rect: CGRect, inView view: UIView!, animated: Bool)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>7.该方法是用来设置 UIActionSheet 显示到哪一个视图</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showInView</span><span class="params">(view: UIView!)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>8.该方法是用来设置 UIActionSheet 消失的按钮索引, 以及是否使用动画</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dismissWithClickedButtonIndex</span><span class="params">(buttonIndex: Int, animated: Bool)</span></span></span><br></pre></td></tr></table></figure><h1 id="UIActionSheet的代理方法"><a href="#UIActionSheet的代理方法" class="headerlink" title="UIActionSheet的代理方法"></a>UIActionSheet的代理方法</h1><blockquote><p>1.该方法是在 UIActionSheet 上的按钮被点击时调用的</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">actionSheet</span><span class="params">(actionSheet: UIActionSheet, clickedButtonAtIndex buttonIndex: Int)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>2.该方法是在 UIActionSheet 上的点击了取消按钮时调用的</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">actionSheetCancel</span><span class="params">(actionSheet: UIActionSheet)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>3.该方法是在 UIActionSheet 完全即将显示的时候调用的</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">willPresentActionSheet</span><span class="params">(actionSheet: UIActionSheet)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>4.该方法是在 UIActionSheet 完全显示的时候调用的</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">didPresentActionSheet</span><span class="params">(actionSheet: UIActionSheet)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>5.该方法是在 UIActionSheet 完全即将消失的时候调用的</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">actionSheet</span><span class="params">(actionSheet: UIActionSheet, willDismissWithButtonIndex buttonIndex: Int)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>6.该方法是在 UIActionSheet 完全消失的时候调用的</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">actionSheet</span><span class="params">(actionSheet: UIActionSheet, didDismissWithButtonIndex buttonIndex: Int)</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UIActionSheet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UIActionSheet </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Func-字典模型互转</title>
      <link href="/2017/12/13/Swift/Swift/Func/Swift-Func-%E5%AD%97%E5%85%B8%E6%A8%A1%E5%9E%8B%E4%BA%92%E8%BD%AC/"/>
      <url>/2017/12/13/Swift/Swift/Func/Swift-Func-%E5%AD%97%E5%85%B8%E6%A8%A1%E5%9E%8B%E4%BA%92%E8%BD%AC/</url>
      <content type="html"><![CDATA[<h1 id="字典–-gt-模型"><a href="#字典–-gt-模型" class="headerlink" title="字典–&gt;模型"></a>字典–&gt;模型</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">User</span>: <span class="title">NSObject</span> </span>&#123;  <span class="comment">//模型类</span></span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> icon:<span class="type">String</span>?</span><br><span class="line"></span><br><span class="line">   <span class="comment">// print时会调用。相当于java中的 toString()。为了代码整洁下面的模型去了这个计算属性。测试时请下载demo</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">internal</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name: <span class="subst">\(name)</span> \n icon:<span class="subst">\(icon)</span> \n"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">let</span> dict = [<span class="string">"name"</span>:<span class="string">"Jack"</span>,<span class="string">"icon"</span>:<span class="string">"lufy.png"</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> user = <span class="type">User</span>.objectWithKeyValues(dict) <span class="keyword">as</span>? <span class="type">User</span>&#123;</span><br><span class="line">             <span class="built_in">print</span>(<span class="string">"<span class="subst">\(user)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  输出： name: <span class="type">Optional</span>(<span class="string">"Jack"</span>) </span><br><span class="line">        icon: <span class="type">Optional</span>(<span class="string">"lufy.png"</span>)</span><br></pre></td></tr></table></figure><h1 id="字典–-gt-模型-：模型中包裹模型"><a href="#字典–-gt-模型-：模型中包裹模型" class="headerlink" title="字典–&gt;模型 ：模型中包裹模型"></a>字典–&gt;模型 ：模型中包裹模型</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//模型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Status</span> :<span class="title">NSObject</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> text:<span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> user:<span class="type">User</span>?        <span class="comment">//与 1 中的模型相同</span></span><br><span class="line">    <span class="keyword">var</span> retweetedStatus:<span class="type">Status</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">let</span> dict = [<span class="string">"text"</span>:<span class="string">"Agree!Nice weather!"</span>,</span><br><span class="line">                  <span class="string">"user"</span>:[<span class="string">"name"</span>:<span class="string">"Jack"</span>,<span class="string">"icon"</span>:<span class="string">"lufy.png"</span>],</span><br><span class="line">                  <span class="string">"retweetedStatus"</span>:[<span class="string">"text"</span>:<span class="string">"Nice weather!"</span>,</span><br><span class="line">                                     <span class="string">"user"</span>:[<span class="string">"name"</span>:<span class="string">"Rose"</span>,<span class="string">"icon"</span>:<span class="string">"nami.png"</span>]]                                      </span><br><span class="line">                 ]</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> status = <span class="type">Status</span>.objectWithKeyValues(dict) <span class="keyword">as</span>? <span class="type">Status</span>&#123;</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">"<span class="subst">\(status)</span>"</span>)</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br><span class="line">输出： </span><br><span class="line">    text:<span class="type">Optional</span>(<span class="string">"Agree!Nice weather!"</span>)</span><br><span class="line">    user:<span class="type">Optional</span>(name: <span class="type">Optional</span>(<span class="string">"Jack"</span>)  icon:<span class="type">Optional</span>(<span class="string">"lufy.png"</span>))</span><br><span class="line">    retweetedStatus:<span class="type">Optional</span>(text:<span class="type">Optional</span>(<span class="string">"Nice weather!"</span>)</span><br><span class="line">                             user:<span class="type">Optional</span>(name: <span class="type">Optional</span>(<span class="string">"Rose"</span>)icon:<span class="type">Optional</span>(<span class="string">"nami.png"</span>))</span><br><span class="line">                             retweetedStatus:<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><h1 id="字典–-gt-模型：-字典中包裹数组，-数组中的元素是-一个模型对应的字典"><a href="#字典–-gt-模型：-字典中包裹数组，-数组中的元素是-一个模型对应的字典" class="headerlink" title="字典–&gt;模型： 字典中包裹数组， 数组中的元素是 一个模型对应的字典"></a>字典–&gt;模型： 字典中包裹数组， 数组中的元素是 一个模型对应的字典</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//模型类， 必须遵守DictModelProtocol协议， 并实现customClassMapping方法。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserGroup</span>: <span class="title">NSObject</span>,<span class="title">DictModelProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> groupName:<span class="type">String</span>?;            <span class="comment">//团队名称</span></span><br><span class="line">    <span class="keyword">var</span> numbers:<span class="type">NSArray</span>?              <span class="comment">//成员，保存User实例</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">customClassMapping</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>: <span class="type">String</span>]?&#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">"numbers"</span>:<span class="string">"User"</span>];   <span class="comment">//指定numbers数组中的元素类型是User</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func3</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">let</span> dict = [<span class="string">"groupName"</span>:<span class="string">"Dream Team"</span>,</span><br><span class="line">                 <span class="string">"numbers"</span>:[[<span class="string">"name"</span>:<span class="string">"Jack"</span>,<span class="string">"icon"</span>:<span class="string">"lufy.png"</span>],</span><br><span class="line">                            [<span class="string">"name"</span>:<span class="string">"Rose"</span>,<span class="string">"icon"</span>:<span class="string">"nami.png"</span>]]</span><br><span class="line">               ]</span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">let</span> group = <span class="type">UserGroup</span>.objectWithKeyValues(dict)&#123;</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">"<span class="subst">\(group)</span>"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出： groupName:<span class="type">Optional</span>(<span class="string">"Dream Team"</span>)</span><br><span class="line">      numbers:<span class="type">Optional</span>((</span><br><span class="line">                        <span class="string">"name: Optional(\"Jack\") \n icon:Optional(\"lufy.png\") \n"</span>,</span><br><span class="line">                        <span class="string">"name: Optional(\"Rose\") \n icon:Optional(\"nami.png\") \n"</span></span><br><span class="line">    ))</span><br></pre></td></tr></table></figure><h1 id="字典–-gt-模型：-将一个字典数组转成模型数组"><a href="#字典–-gt-模型：-将一个字典数组转成模型数组" class="headerlink" title="字典–&gt;模型： 将一个字典数组转成模型数组"></a>字典–&gt;模型： 将一个字典数组转成模型数组</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">func4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">let</span> arrayOfStatus = [[<span class="string">"text"</span>:<span class="string">"Agree!Nice weather!"</span>,</span><br><span class="line">                             <span class="string">"user"</span>:[<span class="string">"name"</span>:<span class="string">"Jack"</span>,</span><br><span class="line">                                     <span class="string">"icon"</span>:<span class="string">"lufy.png"</span></span><br><span class="line">                                    ],</span><br><span class="line">                            <span class="string">"retweetedStatus"</span>:[<span class="string">"text"</span>:<span class="string">"Nice weather!"</span>,</span><br><span class="line">                                                <span class="string">"user"</span>:[<span class="string">"name"</span>:<span class="string">"Rose"</span>,</span><br><span class="line">                                                        <span class="string">"icon"</span>:<span class="string">"nami.png"</span></span><br><span class="line">                                                       ]</span><br><span class="line">                                               ]</span><br><span class="line">                            ],</span><br><span class="line">                            [<span class="string">"text"</span>:<span class="string">"2___Agree!Nice weather!"</span>,</span><br><span class="line">                              <span class="string">"user"</span>:[<span class="string">"name"</span>:<span class="string">"2___Jack"</span>,</span><br><span class="line">                                       <span class="string">"icon"</span>:<span class="string">"2___lufy.png"</span></span><br><span class="line">                                     ],</span><br><span class="line">                            <span class="string">"retweetedStatus"</span>:[<span class="string">"text"</span>:<span class="string">"2___Nice weather!"</span>,</span><br><span class="line">                                                <span class="string">"user"</span>:[<span class="string">"name"</span>:<span class="string">"2___Rose"</span>,</span><br><span class="line">                                                        <span class="string">"icon"</span>:<span class="string">"2___nami.png"</span></span><br><span class="line">                                                       ]</span><br><span class="line">                                               ]</span><br><span class="line">                            ]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> status = <span class="type">Status</span>.objectArrayWithKeyValuesArray(arrayOfStatus)&#123;</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> status&#123; <span class="comment">//打印出数组的元素</span></span><br><span class="line">                <span class="built_in">print</span>(item)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">输出： </span><br><span class="line">    text:<span class="type">Optional</span>(<span class="string">"Agree!Nice weather!"</span>)</span><br><span class="line">    user:<span class="type">Optional</span>(name: <span class="type">Optional</span>(<span class="string">"Jack"</span>)icon:<span class="type">Optional</span>(<span class="string">"lufy.png"</span>))</span><br><span class="line">    retweetedStatus:<span class="type">Optional</span>(text:<span class="type">Optional</span>(<span class="string">"Nice weather!"</span>)</span><br><span class="line">                             user:<span class="type">Optional</span>(name: <span class="type">Optional</span>(<span class="string">"Rose"</span>) icon:<span class="type">Optional</span>(<span class="string">"nami.png"</span>))</span><br><span class="line">                             retweetedStatus:<span class="literal">nil</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    text:<span class="type">Optional</span>(<span class="string">"2___Agree!Nice weather!"</span>)</span><br><span class="line">    user:<span class="type">Optional</span>(name: <span class="type">Optional</span>(<span class="string">"2___Jack"</span>)icon:<span class="type">Optional</span>(<span class="string">"2___lufy.png"</span>))</span><br><span class="line">    retweetedStatus:<span class="type">Optional</span>(text:<span class="type">Optional</span>(<span class="string">"2___Nice weather!"</span>)</span><br><span class="line">                             user:<span class="type">Optional</span>(name: <span class="type">Optional</span>(<span class="string">"2___Rose"</span>)icon:<span class="type">Optional</span>(<span class="string">"2___nami.png"</span>))</span><br><span class="line">                             retweetedStatus:<span class="literal">nil</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h1 id="模型–-gt-字典"><a href="#模型–-gt-字典" class="headerlink" title="模型–&gt;字典"></a>模型–&gt;字典</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">func5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">let</span> user = <span class="type">User</span>()</span><br><span class="line">        user.name = <span class="string">"hejunm"</span></span><br><span class="line">        user.icon = <span class="string">"my.png"</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> dict = user.keyValues&#123;</span><br><span class="line">            <span class="keyword">do</span>&#123; <span class="comment">//转化为JSON 字符串，打印出来更直观</span></span><br><span class="line">                <span class="keyword">let</span> data = <span class="keyword">try</span> <span class="type">NSJSONSerialization</span>.dataWithJSONObject(dict, options: .<span class="type">PrettyPrinted</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="type">NSString</span>(data: data, encoding: <span class="type">NSUTF8StringEncoding</span>))</span><br><span class="line">            &#125;<span class="keyword">catch</span>&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">输出：    </span><br><span class="line"> <span class="type">Optional</span>(&#123;</span><br><span class="line">  <span class="string">"icon"</span> : <span class="string">"my.png"</span>,</span><br><span class="line">  <span class="string">"name"</span> : <span class="string">"hejunm"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="模型–-gt-字典：-模型中还有模型"><a href="#模型–-gt-字典：-模型中还有模型" class="headerlink" title="模型–&gt;字典： 模型中还有模型"></a>模型–&gt;字典： 模型中还有模型</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">func6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> user = <span class="type">User</span>()</span><br><span class="line">       user.name = <span class="string">"retweeted user hejunm"</span></span><br><span class="line">       user.icon = <span class="string">"my.png"</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">let</span> retweetedStatus = <span class="type">Status</span>();  <span class="comment">//转发微博</span></span><br><span class="line">       retweetedStatus.text = <span class="string">"this is retweeted status"</span>;</span><br><span class="line">       retweetedStatus.user = user</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">let</span> oriUser = <span class="type">User</span>()</span><br><span class="line">       oriUser.name = <span class="string">"original user"</span></span><br><span class="line">       oriUser.icon = <span class="string">"my.png"</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">let</span> oriStatus = <span class="type">Status</span>(); <span class="comment">//原微博</span></span><br><span class="line">       oriStatus.text = <span class="string">"this is original status"</span></span><br><span class="line">       oriStatus.user = oriUser</span><br><span class="line">       oriStatus.retweetedStatus = retweetedStatus</span><br><span class="line"></span><br><span class="line">       <span class="keyword">let</span> dict =  oriStatus.keyValues</span><br><span class="line">       <span class="keyword">do</span>&#123; <span class="comment">//转化为JSON 字符串</span></span><br><span class="line">           <span class="keyword">var</span> data = <span class="keyword">try</span> <span class="type">NSJSONSerialization</span>.dataWithJSONObject(dict!, options: .<span class="type">PrettyPrinted</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="type">NSString</span>(data: data, encoding: <span class="type">NSUTF8StringEncoding</span>))</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：  </span><br><span class="line"> <span class="type">Optional</span>(&#123;</span><br><span class="line"> <span class="string">"text"</span> : <span class="string">"this is original status"</span>,</span><br><span class="line"> <span class="string">"user"</span> : &#123;</span><br><span class="line">           <span class="string">"icon"</span> : <span class="string">"my.png"</span>,</span><br><span class="line">           <span class="string">"name"</span> : <span class="string">"original user"</span></span><br><span class="line">          &#125;,</span><br><span class="line">  <span class="string">"retweetedStatus"</span> : &#123;</span><br><span class="line">    <span class="string">"text"</span> : <span class="string">"this is retweeted status"</span>,</span><br><span class="line">    <span class="string">"user"</span> : &#123;</span><br><span class="line">      <span class="string">"icon"</span> : <span class="string">"my.png"</span>,</span><br><span class="line">      <span class="string">"name"</span> : <span class="string">"retweeted user hejunm"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="模型–-gt-字典-：-模型数组转字典数组"><a href="#模型–-gt-字典-：-模型数组转字典数组" class="headerlink" title="模型–&gt;字典 ： 模型数组转字典数组"></a>模型–&gt;字典 ： 模型数组转字典数组</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">func7</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> user1 = <span class="type">User</span>()</span><br><span class="line">        user1.name = <span class="string">"hejunm_1"</span></span><br><span class="line">        user1.icon = <span class="string">"my.png_1"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> user2 = <span class="type">User</span>()</span><br><span class="line">        user2.name = <span class="string">"hejunm_2"</span></span><br><span class="line">        user2.icon = <span class="string">"my.png_2"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> userArray = [user1,user2] <span class="keyword">as</span> <span class="type">NSArray</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> dicts = userArray.keyValuesArray&#123;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> data = <span class="keyword">try</span> <span class="type">NSJSONSerialization</span>.dataWithJSONObject(dicts, options: .<span class="type">PrettyPrinted</span>) <span class="comment">//转成json字符串</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="type">NSString</span>(data: data, encoding: <span class="type">NSUTF8StringEncoding</span>))</span><br><span class="line">            &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">输出： </span><br><span class="line"><span class="type">Optional</span>([</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"icon"</span> : <span class="string">"my.png_1"</span>,</span><br><span class="line">    <span class="string">"name"</span> : <span class="string">"hejunm_1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"icon"</span> : <span class="string">"my.png_2"</span>,</span><br><span class="line">    <span class="string">"name"</span> : <span class="string">"hejunm_2"</span></span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h1 id="源码-字典–-gt-模型"><a href="#源码-字典–-gt-模型" class="headerlink" title="源码 - 字典–&gt;模型"></a>源码 - 字典–&gt;模型</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 当字典中存在数组， 并且数组中保存的值得类型是字典， 那么就需要指定数组中的字典对应的类类型。</span></span><br><span class="line"><span class="comment"> 这里以键值对的形式保存</span></span><br><span class="line"><span class="comment"> eg 字典如下：</span></span><br><span class="line"><span class="comment"> key: [[key1:value1, key2:value2],[key1:value3, key2:value4],[key1:value5, key2:value6]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> key：  key值</span></span><br><span class="line"><span class="comment"> value: 字典[key1:value1, key2:value2] 对应的模型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@objc</span> <span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">DictModelProtocol</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">customClassMapping</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>: <span class="type">String</span>]?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSObject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dict: 要进行转换的字典</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">objectWithKeyValues</span>(<span class="title">dict</span>: <span class="title">NSDictionary</span>)-&gt;<span class="title">AnyObject</span>?</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">HEFoundation</span>.isClassFromFoundation(<span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"只有自定义模型类才可以字典转模型"</span>)</span><br><span class="line">            <span class="built_in">assert</span>(<span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> obj:<span class="type">AnyObject</span> = <span class="keyword">self</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">var</span> cls:<span class="type">AnyClass</span> = <span class="keyword">self</span>.classForCoder()                                           <span class="comment">//当前类的类型</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="string">"NSObject"</span> !=  <span class="string">"<span class="subst">\(cls)</span>"</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> <span class="built_in">count</span>:<span class="type">UInt32</span> = <span class="number">0</span></span><br><span class="line">            <span class="keyword">let</span> properties =  class_copyPropertyList(cls, &amp;<span class="built_in">count</span>)                         <span class="comment">//获取属性列表</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> property = properties[<span class="type">Int</span>(i)]                                         <span class="comment">//获取模型中的某一个属性</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> propertyType = <span class="type">String</span>.fromCString(property_getAttributes(property))!  <span class="comment">//属性类型</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> propertyKey = <span class="type">String</span>.fromCString(property_getName(property))!         <span class="comment">//属性名称</span></span><br><span class="line">                <span class="keyword">if</span> propertyKey == <span class="string">"description"</span>&#123; <span class="keyword">continue</span>  &#125;                              <span class="comment">//description是Foundation中的计算型属性，是实例的描述信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> value:<span class="type">AnyObject</span>! = dict[propertyKey]      <span class="comment">//取得字典中的值</span></span><br><span class="line">                <span class="keyword">if</span> value == <span class="literal">nil</span> &#123;<span class="keyword">continue</span>&#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> valueType =  <span class="string">"<span class="subst">\(value.classForCoder)</span>"</span>     <span class="comment">//字典中保存的值得类型</span></span><br><span class="line">                <span class="keyword">if</span> valueType == <span class="string">"NSDictionary"</span>&#123;               <span class="comment">//1，值是字典。 这个字典要对应一个自定义的模型类并且这个类不是Foundation中定义的类型。</span></span><br><span class="line">                    <span class="keyword">let</span> subModelStr:<span class="type">String</span>! = <span class="type">HEFoundation</span>.getType(propertyType)</span><br><span class="line">                    <span class="keyword">if</span> subModelStr == <span class="literal">nil</span>&#123;</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">"你定义的模型与字典不匹配。 字典中的键<span class="subst">\(propertyKey)</span>  对应一个自定义的 模型"</span>)</span><br><span class="line">                        <span class="built_in">assert</span>(<span class="literal">true</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> subModelClass = <span class="type">NSClassFromString</span>(subModelStr)&#123;</span><br><span class="line">                        value = subModelClass.objectWithKeyValues(value <span class="keyword">as</span>! <span class="type">NSDictionary</span>) <span class="comment">//递归</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> valueType == <span class="string">"NSArray"</span>&#123;              <span class="comment">//值是数组。 数组中存放字典。 将字典转换成模型。 如果协议中没有定义映射关系，就不做处理</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">self</span>.respondsToSelector(<span class="string">"customClassMapping"</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">var</span> subModelClassName = cls.customClassMapping()?[propertyKey]&#123;   <span class="comment">//子模型的类名称</span></span><br><span class="line">                            subModelClassName =  <span class="type">HEFoundation</span>.bundlePath+<span class="string">"."</span>+subModelClassName</span><br><span class="line">                            <span class="keyword">if</span> <span class="keyword">let</span> subModelClass = <span class="type">NSClassFromString</span>(subModelClassName)&#123;</span><br><span class="line">                                value = subModelClass.objectArrayWithKeyValuesArray(value <span class="keyword">as</span>! <span class="type">NSArray</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              obj.setValue(value, forKey: propertyKey)</span><br><span class="line">            &#125;</span><br><span class="line">            free(properties)                            <span class="comment">//释放内存</span></span><br><span class="line">            cls = cls.superclass()!                     <span class="comment">//处理父类</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     将字典数组转换成模型数组</span></span><br><span class="line"><span class="comment">     array: 要转换的数组, 数组中包含的字典所对应的模型类就是 调用这个类方法的类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     当数组中嵌套数组， 内部的数组包含字典，cls就是内部数组中的字典对应的模型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">objectArrayWithKeyValuesArray</span>(<span class="title">array</span>: <span class="title">NSArray</span>)-&gt;<span class="title">NSArray</span>?</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> array.<span class="built_in">count</span> == <span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> result = [<span class="type">AnyObject</span>]()</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> array&#123;</span><br><span class="line">            <span class="keyword">let</span> type = <span class="string">"<span class="subst">\(item.classForCoder)</span>"</span></span><br><span class="line">            <span class="keyword">if</span> type == <span class="string">"NSDictionary"</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> model = objectWithKeyValues(item <span class="keyword">as</span>! <span class="type">NSDictionary</span>)&#123;</span><br><span class="line">                    result.append(model)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> type == <span class="string">"NSArray"</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> model =  objectArrayWithKeyValuesArray(item <span class="keyword">as</span>! <span class="type">NSArray</span>)&#123;</span><br><span class="line">                    result.append(model)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.append(item)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> result.<span class="built_in">count</span>==<span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="源码-模型–-gt-字典"><a href="#源码-模型–-gt-字典" class="headerlink" title="源码 - 模型–&gt;字典"></a>源码 - 模型–&gt;字典</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> keyValues:[<span class="type">String</span>:<span class="type">AnyObject</span>]?&#123;                   <span class="comment">//获取一个模型对应的字典</span></span><br><span class="line">        <span class="keyword">get</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> result = [<span class="type">String</span>: <span class="type">AnyObject</span>]()           <span class="comment">//保存结果</span></span><br><span class="line">            <span class="keyword">var</span> classType:<span class="type">AnyClass</span> = <span class="keyword">self</span>.classForCoder</span><br><span class="line">            <span class="keyword">while</span>(<span class="string">"NSObject"</span> !=  <span class="string">"<span class="subst">\(classType)</span>"</span> )&#123;</span><br><span class="line">                <span class="keyword">var</span> <span class="built_in">count</span>:<span class="type">UInt32</span> = <span class="number">0</span></span><br><span class="line">                <span class="keyword">let</span> properties = class_copyPropertyList(classType, &amp;<span class="built_in">count</span>)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span>&#123;</span><br><span class="line">                    <span class="keyword">let</span> property = properties[<span class="type">Int</span>(i)]</span><br><span class="line">                    <span class="keyword">let</span> propertyKey = <span class="type">String</span>.fromCString(property_getName(property))!         <span class="comment">//模型中属性名称</span></span><br><span class="line">                    <span class="keyword">let</span> propertyType = <span class="type">String</span>.fromCString(property_getAttributes(property))!  <span class="comment">//模型中属性类型</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> <span class="string">"description"</span> == propertyKey&#123; <span class="keyword">continue</span> &#125;   <span class="comment">//描述，不是属性</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">let</span> tempValue:<span class="type">AnyObject</span>!  = <span class="keyword">self</span>.valueForKey(propertyKey)</span><br><span class="line">                    <span class="keyword">if</span>  tempValue == <span class="literal">nil</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> <span class="number">_</span> =  <span class="type">HEFoundation</span>.getType(propertyType) &#123;         <span class="comment">//1,自定义的类</span></span><br><span class="line">                        result[propertyKey] = tempValue.keyValues</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (propertyType.containsString(<span class="string">"NSArray"</span>))&#123;       <span class="comment">//2, 数组, 将数组中的模型转成字典</span></span><br><span class="line">                        result[propertyKey] = tempValue.keyValuesArray       <span class="comment">//3， 基本数据</span></span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        result[propertyKey] = tempValue</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                free(properties)</span><br><span class="line">                classType = classType.superclass()!</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> result.<span class="built_in">count</span> == <span class="number">0</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSArray</span></span>&#123;  <span class="comment">//数组的拓展</span></span><br><span class="line">    <span class="keyword">var</span> keyValuesArray:[<span class="type">AnyObject</span>]?&#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> result = [<span class="type">AnyObject</span>]()</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> <span class="keyword">self</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> !<span class="type">HEFoundation</span>.isClassFromFoundation(item.classForCoder)&#123; <span class="comment">//1,自定义的类</span></span><br><span class="line">                    <span class="keyword">let</span> subKeyValues:[<span class="type">String</span>:<span class="type">AnyObject</span>]! = item.keyValues</span><br><span class="line">                    <span class="keyword">if</span>  subKeyValues == <span class="literal">nil</span> &#123;<span class="keyword">continue</span>&#125;</span><br><span class="line">                    result.append(subKeyValues)</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> item.classForCoder == <span class="type">NSArray</span>.classForCoder()&#123;    <span class="comment">//2, 如果item 是数组</span></span><br><span class="line">                    <span class="keyword">let</span> subKeyValues:[<span class="type">AnyObject</span>]! = item.keyValuesArray</span><br><span class="line">                    <span class="keyword">if</span>  subKeyValues == <span class="literal">nil</span> &#123;<span class="keyword">continue</span>&#125;</span><br><span class="line">                    result.append(subKeyValues)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;                                                     <span class="comment">//3, 基本数据类型</span></span><br><span class="line">                    result.append(item)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> result.<span class="built_in">count</span> == <span class="number">0</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="辅助类"><a href="#辅助类" class="headerlink" title="辅助类"></a>辅助类</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HEFoundation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="keyword">set</span> = <span class="type">NSSet</span>(array: [</span><br><span class="line">                                    <span class="type">NSURL</span>.classForCoder(),</span><br><span class="line">                                    <span class="type">NSDate</span>.classForCoder(),</span><br><span class="line">                                    <span class="type">NSValue</span>.classForCoder(),</span><br><span class="line">                                    <span class="type">NSData</span>.classForCoder(),</span><br><span class="line">                                    <span class="type">NSError</span>.classForCoder(),</span><br><span class="line">                                    <span class="type">NSArray</span>.classForCoder(),</span><br><span class="line">                                    <span class="type">NSDictionary</span>.classForCoder(),</span><br><span class="line">                                    <span class="type">NSString</span>.classForCoder(),</span><br><span class="line">                                    <span class="type">NSAttributedString</span>.classForCoder()</span><br><span class="line">                                  ])</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span>  bundlePath = <span class="type">NSBundle</span>.mainBundle().infoDictionary![<span class="string">"CFBundleExecutable"</span>] <span class="keyword">as</span>! <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 判断某个类是否是 Foundation中自带的类 */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">isClassFromFoundation</span>(<span class="title">c</span>:<span class="title">AnyClass</span>)-&gt;<span class="title">Bool</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span>  result = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">c</span> == <span class="type">NSObject</span>.classForCoder()&#123;</span><br><span class="line">            result = <span class="literal">true</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">set</span>.enumerateObjectsUsingBlock(&#123; (foundation,  stop) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span>  <span class="built_in">c</span>.isSubclassOfClass(foundation <span class="keyword">as</span>! <span class="type">AnyClass</span>) &#123;</span><br><span class="line">                    result = <span class="literal">true</span></span><br><span class="line">                    stop.initialize(<span class="literal">true</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 很据属性信息， 获得自定义类的 类名*/</span></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     let propertyType = String.fromCString(property_getAttributes(property))! 获取属性类型</span></span><br><span class="line"><span class="comment">     到这个属性的类型是自定义的类时， 会得到下面的格式： T+@+"+..+工程的名字+数字+类名+"+,+其他,</span></span><br><span class="line"><span class="comment">     而我们想要的只是类名，所以要修改这个字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">getType</span>(<span class="title">var</span> <span class="title">code</span>:<span class="title">String</span>)-&gt;<span class="title">String</span>?</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !code.containsString(bundlePath)&#123; <span class="comment">//不是自定义类</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        code = code.componentsSeparatedByString(<span class="string">"\""</span>)[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> range = code.rangeOfString(bundlePath)&#123;</span><br><span class="line">            code = code.substringFromIndex(range.endIndex)</span><br><span class="line">            <span class="keyword">var</span> numStr = <span class="string">""</span> <span class="comment">//类名前面的数字</span></span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">c</span>:<span class="type">Character</span> <span class="keyword">in</span> code.characters&#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">c</span> &lt;= <span class="string">"9"</span> &amp;&amp; <span class="built_in">c</span> &gt;= <span class="string">"0"</span>&#123;</span><br><span class="line">                    numStr+=<span class="type">String</span>(<span class="built_in">c</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> numRange = code.rangeOfString(numStr)&#123;</span><br><span class="line">                code = code.substringFromIndex(numRange.endIndex)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> bundlePath+<span class="string">"."</span>+code</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://blog.csdn.net/hejunmeng/article/details/51280570" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Func </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Func </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-AppKit-NSTimer-定时器</title>
      <link href="/2017/12/13/Swift/Swift/UIKit/NSTimer-%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
      <url>/2017/12/13/Swift/Swift/UIKit/NSTimer-%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
      <content type="html"><![CDATA[<h1 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NSTimer</span> : <span class="title">NSObject</span></span></span><br></pre></td></tr></table></figure><h2 id="定时器的作用"><a href="#定时器的作用" class="headerlink" title="定时器的作用"></a>定时器的作用</h2><ul><li>在指定的时间执行指定的任务</li><li>间隔一段时间执行指定任务</li></ul><h1 id="定时器的创建"><a href="#定时器的创建" class="headerlink" title="定时器的创建"></a>定时器的创建</h1><h2 id="scheduled方式"><a href="#scheduled方式" class="headerlink" title="scheduled方式"></a>scheduled方式</h2><ul><li>创建并启动定时器</li><li>默认将时钟以NSDefaultRunLoopMode模式添加到运行循环</li><li>用户发生交互的时候时钟将暂停</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">      public class func scheduledTimerWithTimeInterval(ti: NSTimeInterval,  </span></span><br><span class="line"><span class="comment">                                           target aTarget: AnyObject,  </span></span><br><span class="line"><span class="comment">                                       selector aSelector: Selector,  </span></span><br><span class="line"><span class="comment">                                                 userInfo: AnyObject?,  </span></span><br><span class="line"><span class="comment">                                          repeats yesOrNo: Bool) -&gt; NSTimer </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      参数： </span></span><br><span class="line"><span class="comment">          TimeInterval：触发时间，单位秒 </span></span><br><span class="line"><span class="comment">          target：定时起触发对象 </span></span><br><span class="line"><span class="comment">          selector：定时器响应方法 </span></span><br><span class="line"><span class="comment">          userInfo：用户信息 </span></span><br><span class="line"><span class="comment">          repeats：是否重复执行，YES 每个指定的时间重复执行，NO 只执行一次 </span></span><br><span class="line"><span class="comment">  */</span>  </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 创建并启动定时器  </span></span><br><span class="line">  <span class="keyword">let</span> timer:<span class="type">NSTimer</span> = <span class="type">NSTimer</span>.scheduledTimerWithTimeInterval(<span class="number">2.0</span>,   </span><br><span class="line">                                                      target: <span class="keyword">self</span>,   </span><br><span class="line">                                                    selector: #selector(<span class="type">YPScrollView</span>.timerChange),<span class="number">2</span>  </span><br><span class="line">                                                    userInfo: <span class="literal">nil</span>,   </span><br><span class="line">                                                     repeats: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h2 id="timer方式"><a href="#timer方式" class="headerlink" title="timer方式"></a>timer方式</h2><ul><li>创建定时器添加到运行循环</li><li>将时钟以指定模式添加到运行循环</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">    mode： </span></span><br><span class="line"><span class="comment">        NSDefaultRunLoopMode: 时钟，网络。           发生用户交互的时候，时钟会被暂停 </span></span><br><span class="line"><span class="comment">        NSRunLoopCommonModes: 用户交互，响应级别高。  发生用户交互的时候，时钟仍然会触发，如果时钟触发方法非常 </span></span><br><span class="line"><span class="comment">                                                    耗时，使用此方式时用户操作会造成非常严重的卡顿。 </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 创建定时器  </span></span><br><span class="line"><span class="keyword">let</span> timer:<span class="type">NSTimer</span> = <span class="type">NSTimer</span>(timeInterval: <span class="number">2.0</span>,   </span><br><span class="line">                                  target: <span class="keyword">self</span>,   </span><br><span class="line">                                selector: #selector(<span class="type">ViewController</span>.updateTimer(<span class="number">_</span>:)),   </span><br><span class="line">                                userInfo: <span class="literal">nil</span>,   </span><br><span class="line">                                 repeats: <span class="literal">true</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 将定时器添加到运行循环  </span></span><br><span class="line"><span class="type">NSRunLoop</span>.currentRunLoop().addTimer(timer, forMode: <span class="type">NSRunLoopCommonModes</span>)</span><br></pre></td></tr></table></figure><h1 id="定时器的启动与关闭"><a href="#定时器的启动与关闭" class="headerlink" title="定时器的启动与关闭"></a>定时器的启动与关闭</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 启动定时器  </span></span><br><span class="line">timer.fireDate = <span class="type">NSDate</span>.distantFuture()  </span><br><span class="line">      </span><br><span class="line"><span class="comment">// 暂停定时器  </span></span><br><span class="line">timer.fireDate = <span class="type">NSDate</span>.distantPast()  </span><br><span class="line">      </span><br><span class="line"><span class="comment">// 关闭定时器，永久关闭定时器  </span></span><br><span class="line">timer.invalidate()</span><br></pre></td></tr></table></figure><h1 id="子线程定时器的创建"><a href="#子线程定时器的创建" class="headerlink" title="子线程定时器的创建"></a>子线程定时器的创建</h1><blockquote><p>在子线程创建定时器时，需要手动开启子线程的运行循环</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>)) &#123;   </span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 在子线程创建定时器  </span></span><br><span class="line">     <span class="comment">/* </span></span><br><span class="line"><span class="comment">         scheduled 或 timer 方式创建 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">     <span class="keyword">let</span> timer:<span class="type">NSTimer</span> = <span class="type">NSTimer</span>(timeInterval: <span class="number">2.0</span>,   </span><br><span class="line">                          target: <span class="keyword">self</span>,   </span><br><span class="line">                        selector: #selector(<span class="type">ViewController</span>.updateTimer(<span class="number">_</span>:)),   </span><br><span class="line">                        userInfo: <span class="literal">nil</span>,   </span><br><span class="line">                         repeats: <span class="literal">true</span>)  </span><br><span class="line">     <span class="type">NSRunLoop</span>.currentRunLoop().addTimer(timer, forMode: <span class="type">NSRunLoopCommonModes</span>)  </span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 启动子线程的运行循环  </span></span><br><span class="line">     <span class="comment">/* </span></span><br><span class="line"><span class="comment">         这句代码就是一个死循环！如果不停止运行循环，不会执行添加到此句之后的任何代码 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">     <span class="type">CFRunLoopRun</span>()  </span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 停止子线程运行循环之前，不会执行添加到此处的任何代码  </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num:<span class="type">Int</span> = <span class="number">0</span>  </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">updateTimer</span><span class="params">(timer:NSTimer)</span></span> &#123;  </span><br><span class="line"> </span><br><span class="line">     num  = num + <span class="number">1</span>  </span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 满足条件后，停止当前的运行循环  </span></span><br><span class="line">     <span class="keyword">if</span> (num == <span class="number">8</span>) &#123;  </span><br><span class="line"> </span><br><span class="line">         <span class="comment">// 停止当前的运行循环  </span></span><br><span class="line">         <span class="comment">/* </span></span><br><span class="line"><span class="comment">             一旦停止了运行循环，后续代码能够执行，执行完毕后，线程被自动销毁 </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">         <span class="type">CFRunLoopStop</span>(<span class="type">CFRunLoopGetCurrent</span>())  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">/ 延时调用  </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    1.5 秒后自动调用 self 的 hideHUD 方法 </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="keyword">self</span>.performSelector(#selector(<span class="type">NsTimer</span>.hideHUD), withObject: <span class="literal">nil</span>, afterDelay: <span class="number">1.5</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 取消延时调用  </span></span><br><span class="line"><span class="type">NSObject</span>.cancelPreviousPerformRequestsWithTarget(<span class="keyword">self</span>, selector: #selector(<span class="type">NsTimer</span>.hideHUD), object: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> / 延时调用  </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    1.5 秒后自动调用 self 的 hideHUD 方法 </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="keyword">self</span>.performSelector(#selector(<span class="type">NsTimer</span>.hideHUD), withObject: <span class="literal">nil</span>, afterDelay: <span class="number">1.5</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 取消延时调用  </span></span><br><span class="line"><span class="type">NSObject</span>.cancelPreviousPerformRequestsWithTarget(<span class="keyword">self</span>, selector: #selector(<span class="type">NsTimer</span>.hideHUD), object: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> / 延时调用  </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    1.5 秒后自动调用 self 的 hideHUD 方法 </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="keyword">self</span>.performSelector(#selector(<span class="type">NsTimer</span>.hideHUD), withObject: <span class="literal">nil</span>, afterDelay: <span class="number">1.5</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 取消延时调用  </span></span><br><span class="line"><span class="type">NSObject</span>.cancelPreviousPerformRequestsWithTarget(<span class="keyword">self</span>, selector: #selector(<span class="type">NsTimer</span>.hideHUD), object: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> NSTimer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> NSTimer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UICollectionView-简单使用</title>
      <link href="/2017/12/13/Swift/Swift/UIKit/UICollectionView-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/12/13/Swift/Swift/UIKit/UICollectionView-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="遵守协议"><a href="#遵守协议" class="headerlink" title="遵守协议"></a>遵守协议</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UICollectionViewDataSource</span>, <span class="title">UICollectionViewDelegate</span>, <span class="title">UICollectionViewDelegateFlowLayout</span> </span>&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义UICollectionView"><a href="#自定义UICollectionView" class="headerlink" title="自定义UICollectionView"></a>自定义UICollectionView</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">myCollectionView</span><span class="params">()</span></span> &#123;  </span><br><span class="line">        <span class="comment">// 1.自定义 Item 的FlowLayout  </span></span><br><span class="line">        <span class="keyword">let</span> flowLayout = <span class="type">UICollectionViewFlowLayout</span>()  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 2.设置 Item 的 Size  </span></span><br><span class="line">        flowLayout.itemSize = <span class="type">CGSizeMake</span>(<span class="number">90</span>, <span class="number">120</span>)  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 3.设置 Item 的排列方式  </span></span><br><span class="line">        flowLayout.scrollDirection = <span class="type">UICollectionViewScrollDirection</span>.<span class="type">Vertical</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 4.设置 Item 的四周边距  </span></span><br><span class="line">        flowLayout.sectionInset = <span class="type">UIEdgeInsetsMake</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>)  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 5.设置同一竖中上下相邻的两个 Item 之间的间距  </span></span><br><span class="line">        flowLayout.minimumLineSpacing = <span class="number">20</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 6.设置同一行中相邻的两个 Item 之间的间距  </span></span><br><span class="line">        flowLayout.minimumInteritemSpacing = <span class="number">20</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 7.设置UICollectionView 的页头尺寸  </span></span><br><span class="line">        flowLayout.headerReferenceSize = <span class="type">CGSizeMake</span>(<span class="number">100</span>, <span class="number">50</span>)  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 8.设置 UICollectionView 的页尾尺寸  </span></span><br><span class="line">        flowLayout.footerReferenceSize = <span class="type">CGSizeMake</span>(<span class="number">100</span>, <span class="number">50</span>)  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 1.自定义 UICollectionView 的位置大小, 以及 Item 的显示样式为 flowLayout  </span></span><br><span class="line">        <span class="keyword">var</span> collection = <span class="type">UICollectionView</span>(frame: <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">64</span>, <span class="keyword">self</span>.view.frame.width, <span class="keyword">self</span>.view.frame.height - <span class="number">64</span>), collectionViewLayout: flowLayout)  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 2.设置 UICollectionView 的背景颜色  </span></span><br><span class="line">        collection.backgroundColor = <span class="type">UIColor</span>.whiteColor()  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 3.设置 UICollectionView 垂直滚动是否滚到 Item 的最底部内容  </span></span><br><span class="line">        collection.alwaysBounceVertical = <span class="literal">true</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 4.设置 UICollectionView 垂直滚动是否滚到 Item 的最右边内容  </span></span><br><span class="line">        collection.alwaysBounceHorizontal = <span class="literal">true</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 5.设置 UICollectionView 的数据源对象  </span></span><br><span class="line">        collection.dataSource = <span class="keyword">self</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 6.设置 UICollectionView 的代理对象  </span></span><br><span class="line">        collection.delegate = <span class="keyword">self</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 7.设置 UICollectionView 的单元格点击(默认是 true)  </span></span><br><span class="line">        collection.allowsSelection = <span class="literal">true</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 8.设置 UICollectionView 的单元格多选(默认是 false)  </span></span><br><span class="line">        collection.allowsMultipleSelection = <span class="literal">false</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 9.开启 UICollectionView 的分页显示效果  </span></span><br><span class="line">        collection.pagingEnabled = <span class="literal">true</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 10.注册 UICollectionViewCell  </span></span><br><span class="line">collection.registerClass(<span class="type">UICollectionViewCell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="string">"cell"</span>)  </span><br><span class="line">        <span class="comment">// 11.添加到 self.view 上  </span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(collection)  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="自定义UINavigationBar"><a href="#自定义UINavigationBar" class="headerlink" title="自定义UINavigationBar"></a>自定义UINavigationBar</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">myNavigationBar</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="comment">// 1.自定义 NavigationBar, 设置它的位置大小  </span></span><br><span class="line">    <span class="keyword">var</span> navigationBar = <span class="type">UINavigationBar</span>(frame: <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.view.frame.width, <span class="number">64</span>))  </span><br><span class="line">    <span class="comment">// 2.设置 NavigationBar 的背景色  </span></span><br><span class="line">    navigationBar.backgroundColor = <span class="type">UIColor</span>.redColor()  </span><br><span class="line">    <span class="comment">// 3.自定义 NavigationItem 设定它的 Title  </span></span><br><span class="line">    <span class="keyword">let</span> navigationItem = <span class="type">UINavigationItem</span>(title: <span class="string">"UICollectionView演示"</span>)  </span><br><span class="line">    <span class="comment">// 4.自定义 UIBarButtonItem 的Title, Style, Target 的对象, 已经监听的方法  </span></span><br><span class="line">    <span class="keyword">let</span> leftButton = <span class="type">UIBarButtonItem</span>(title: <span class="string">"返回"</span>, style: <span class="type">UIBarButtonItemStyle</span>.<span class="type">Plain</span>, target: <span class="keyword">self</span>, action: <span class="string">"back"</span>)  </span><br><span class="line">    <span class="comment">// 5.设置 Navigation 左边的按钮为 leftButton  </span></span><br><span class="line">    navigationItem.leftBarButtonItem = leftButton  </span><br><span class="line">    <span class="comment">// 6.把 NavigationItem 添加到 NavigationBar  </span></span><br><span class="line">    navigationBar.pushNavigationItem(navigationItem, animated: <span class="literal">true</span>)  </span><br><span class="line">    <span class="comment">// 7.添加到到 self.view 上  </span></span><br><span class="line">    <span class="keyword">self</span>.view.addSubview(navigationBar)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 8.NavigationBar监听方法  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">back</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"点击了返回"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="UICollectionView的代理方法-数据源方法-FlowLayout-方法"><a href="#UICollectionView的代理方法-数据源方法-FlowLayout-方法" class="headerlink" title="UICollectionView的代理方法, 数据源方法, FlowLayout 方法"></a>UICollectionView的代理方法, 数据源方法, FlowLayout 方法</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 1.该方法是用来设置返回 CollectionViewCell 的组数  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfSectionsInCollectionView</span><span class="params">(collectionView: UICollectionView)</span></span> -&gt; <span class="type">Int</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 2.该方法是用来设置返回 CollectionViewCell 的个数  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, numberOfItemsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">15</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 3.该方法是用来设置 CollectionViewCell 的内容  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UICollectionViewCell</span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> collectionCell = collectionView.dequeueReusableCellWithReuseIdentifier(<span class="string">"cell"</span>, forIndexPath: indexPath) <span class="keyword">as</span>! <span class="type">UICollectionViewCell</span>  </span><br><span class="line">    collectionCell.backgroundColor = <span class="type">UIColor</span>.redColor()  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> collectionCell  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 4.该方法是点击了 CollectionViewCell 时调用的监听方法  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, didSelectItemAtIndexPath indexPath: NSIndexPath)</span></span> &#123;  </span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"aaa"</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 5.该方法是用来设置 CollectionViewCell 的大小  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">CGSize</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="type">CGSizeMake</span>(<span class="number">90</span>, <span class="number">120</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 6.该方法是用来设置 CollectionViewCell 四周的边距  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAtIndex section: Int)</span></span> -&gt; <span class="type">UIEdgeInsets</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIEdgeInsetsMake</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 7.该方法是用来设置同一行 CollectionViewCell 之间的间距  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumInteritemSpacingForSectionAtIndex section: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 8.该方法是用来设置同一列 CollectionViewCell 之间的间距  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAtIndex section: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 9.该方法是用来设置 CollectionView 的页头尺寸  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, referenceSizeForHeaderInSection section: Int)</span></span> -&gt; <span class="type">CGSize</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="type">CGSizeMake</span>(<span class="number">100</span>, <span class="number">50</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 10.该方法是用来设置 CollectionView 的页尾尺寸  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, referenceSizeForFooterInSection section: Int)</span></span> -&gt; <span class="type">CGSize</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="type">CGSizeMake</span>(<span class="number">100</span>, <span class="number">50</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UICollectionView </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UICollectionView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UICollectionView-简介</title>
      <link href="/2017/12/13/Swift/Swift/UIKit/UICollectionView-%E7%AE%80%E4%BB%8B/"/>
      <url>/2017/12/13/Swift/Swift/UIKit/UICollectionView-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="UICollectionView的常用属性"><a href="#UICollectionView的常用属性" class="headerlink" title="UICollectionView的常用属性"></a>UICollectionView的常用属性</h1><blockquote><p>1.设置位置和大小  </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>(frame: <span class="type">CGRect</span>, collectionViewLayout layout: <span class="type">UICollectionViewLayout</span>)</span><br></pre></td></tr></table></figure><blockquote><p>2.设置子视图的布局方式 </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> collectionViewLayout: <span class="type">UICollectionViewLayout</span></span><br></pre></td></tr></table></figure><blockquote><p>3.设置UICollectionView的代理对象</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unowned</span>(unsafe) <span class="keyword">var</span> delegate: <span class="type">UICollectionViewDelegate</span>?</span><br></pre></td></tr></table></figure><blockquote><p>4.设置UICollectionView的数据源对象  </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unowned</span>(unsafe) <span class="keyword">var</span> dataSource: <span class="type">UICollectionViewDataSource</span>?</span><br></pre></td></tr></table></figure><blockquote><p>5.设置UICollectionView的背景视图</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var backgroundView: UIView?</span><br></pre></td></tr></table></figure><blockquote><p>6.设置 UICollectionView 的 Cell 是否可以点击  </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> allowsSelection: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p>7.设置 UICollectionView 的 Cell 是否可以多选  </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> allowsMultipleSelection: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><h1 id="UICollectionViewCell显示的样式"><a href="#UICollectionViewCell显示的样式" class="headerlink" title="UICollectionViewCell显示的样式"></a>UICollectionViewCell显示的样式</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">UICollectionViewScrollPosition</span> : <span class="title">RawOptionSetType</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> rawValue: <span class="type">UInt</span>)  </span><br><span class="line">    <span class="keyword">init</span>(rawValue: <span class="type">UInt</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 1.没有样式  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">None</span>: <span class="type">UICollectionViewScrollPosition</span> &#123; <span class="keyword">get</span> &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 2.垂直居中显示  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">CenteredVertically</span>: <span class="type">UICollectionViewScrollPosition</span> &#123; <span class="keyword">get</span> &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 3.向下显示  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">Bottom</span>: <span class="type">UICollectionViewScrollPosition</span> &#123; <span class="keyword">get</span> &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 4.向左显示  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">Left</span>: <span class="type">UICollectionViewScrollPosition</span> &#123; <span class="keyword">get</span> &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 5.水平居中显示  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">CenteredHorizontally</span>: <span class="type">UICollectionViewScrollPosition</span> &#123; <span class="keyword">get</span> &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 6.向右显示  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">Right</span>: <span class="type">UICollectionViewScrollPosition</span> &#123; <span class="keyword">get</span> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="UICollectionView常用的方法"><a href="#UICollectionView常用的方法" class="headerlink" title="UICollectionView常用的方法"></a>UICollectionView常用的方法</h1><blockquote><p>1.设置UICollectionView的注册类, 以及标示符  </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerClass</span><span class="params">(cellClass: AnyClass?, forCellWithReuseIdentifier identifier: String)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>2.设置 UICollectionView的注册Nib, 以及标示符  </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerNib</span><span class="params">(nib: UINib?, forCellWithReuseIdentifier identifier: String)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>3.设置 UICollectionView 的注册类, 以及辅助视图名称, 标示符 </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerClass</span><span class="params">(viewClass: AnyClass?, forSupplementaryViewOfKind elementKind: String, withReuseIdentifier identifier: String)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>4.设置 UICollectionView的注册Nib, 以及辅助视图名称, 标示符  </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerNib</span><span class="params">(nib: UINib?, forSupplementaryViewOfKind kind: String, withReuseIdentifier identifier: String)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>5.设置 UICollectionView 可重用的 Cell 以及所以路径</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dequeueReusableCellWithReuseIdentifier</span><span class="params">(identifier: String, forIndexPath indexPath: NSIndexPath!)</span></span> -&gt; <span class="type">AnyObject</span></span><br></pre></td></tr></table></figure><blockquote><p>6.设置 UICollectionView 可重用的的辅视图, 标示符, 以及索引路径</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dequeueReusableSupplementaryViewOfKind</span><span class="params">(elementKind: String, withReuseIdentifier identifier: String, forIndexPath indexPath: NSIndexPath!)</span></span> -&gt; <span class="type">AnyObject</span></span><br></pre></td></tr></table></figure><blockquote><p>7.选择 Item 的索引路径  </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexPathsForSelectedItems</span><span class="params">()</span></span> -&gt; [<span class="type">AnyObject</span>]</span><br></pre></td></tr></table></figure><blockquote><p>8.选择 Item 的索引路径, 以及是否使用动画, 显示样式</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectItemAtIndexPath</span><span class="params">(indexPath: NSIndexPath?, animated: Bool, scrollPosition: UICollectionViewScrollPosition)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>9.取消选择 Item 的索引路径, 以及是否使用动画 </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deselectItemAtIndexPath</span><span class="params">(indexPath: NSIndexPath?, animated: Bool)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>10.刷新数据  </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reloadData</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><blockquote><p>11.设置 UICollectionView 的集合视图布局, 及是否使用动画 </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setCollectionViewLayout</span><span class="params">(layout: UICollectionViewLayout, </span></span></span><br><span class="line"><span class="function"><span class="params">                           animated: Bool)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>12.设置 UICollectionView 的集合视图布局, 及是否使用动画, 以及完成之后的闭包方法 </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setCollectionViewLayout</span><span class="params">(layout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                           animated: Bool, </span></span></span><br><span class="line"><span class="function"><span class="params">                         completion: <span class="params">(<span class="params">(Bool)</span></span></span></span> -&gt; <span class="type">Void</span>)!)</span><br></pre></td></tr></table></figure><blockquote><p>13.设置 UICollectionView 显示多少个 Item  </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfSections</span><span class="params">()</span></span> -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure><blockquote><p>14.设置 UICollectionView 显示多少组 Item  </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfItemsInSection</span><span class="params">(section: Int)</span></span> -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure><blockquote><p>15.设置 UICollectionView 滚动到第几个 Item 的索引路径, 以及显示样式和是否启用动画 </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scrollToItemAtIndexPath</span><span class="params">(indexPath: NSIndexPath, atScrollPosition scrollPosition: UICollectionViewScrollPosition, animated: Bool)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>16.在 UICollectionView 中插入某个 Item </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertSections</span><span class="params">(sections: NSIndexSet)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>17.在 UICollectionView 中删除某个 Item </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteSections</span><span class="params">(sections: NSIndexSet)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>18.在 UICollectionView 中刷新某个 Item  </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reloadSections</span><span class="params">(sections: NSIndexSet)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>19.移动 UICollectionView 中某个 Item 到某个位置  </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">moveSection</span><span class="params">(section: Int, toSection newSection: Int)</span></span></span><br></pre></td></tr></table></figure><h1 id="UICollectionView代理方法"><a href="#UICollectionView代理方法" class="headerlink" title="UICollectionView代理方法"></a>UICollectionView代理方法</h1><blockquote><p>1.点击 Item 时调用的方法  </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, didSelectItemAtIndexPath indexPath: NSIndexPath)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>2.取消选中 Item 时调用的方法  </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, didDeselectItemAtIndexPath indexPath: NSIndexPath)</span></span></span><br></pre></td></tr></table></figure><h1 id="UICollectionView数据源方法"><a href="#UICollectionView数据源方法" class="headerlink" title="UICollectionView数据源方法"></a>UICollectionView数据源方法</h1><blockquote><p>1.设置UICollectionView有多少个Item </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, numberOfItemsInSection section: Int)</span></span> -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure><blockquote><p>2.设置 UICollectionViewCell 所显示的内容, 以及索引路径</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UICollectionViewCell</span></span><br></pre></td></tr></table></figure><blockquote><p>3.设置 UICollectionView 有多少组 Cell  </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">numberOfSectionsInCollectionView</span><span class="params">(collectionView: UICollectionView)</span></span> -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure><h1 id="UICollectionView的集视图布局方法"><a href="#UICollectionView的集视图布局方法" class="headerlink" title="UICollectionView的集视图布局方法"></a>UICollectionView的集视图布局方法</h1><blockquote><p>1.该方法是用来设置 UICollectionView 的 Item 尺寸大小 </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">CGSize</span></span><br></pre></td></tr></table></figure><blockquote><p>2.该方法是用来设置 UICollectionView 的 Item 四周的边界 </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, </span></span></span><br><span class="line"><span class="function"><span class="params">                layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">             insetForSectionAtIndex section: Int)</span></span> -&gt; <span class="type">UIEdgeInsets</span></span><br></pre></td></tr></table></figure><blockquote><p>3.该方法是用来设置 UICollectionView 的 Item 上下之间的最小间距<br>如果在自定义UICollectionView中实现了该属性, 那么该方法就会覆盖掉原来的属性</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, </span></span></span><br><span class="line"><span class="function"><span class="params">                layout collectionViewLayout: UICollectionViewLayout, </span></span></span><br><span class="line"><span class="function"><span class="params">minimumLineSpacingForSectionAtIndex section: Int)</span></span> -&gt; <span class="type">CGFloat</span></span><br></pre></td></tr></table></figure><blockquote><p>4.该方法是用来设置 UICollectionView 的 Item 左右之间的最小间距(如果在自定义UICollectionView中实现了该属性, 那么该方法就会覆盖掉原来的属性)</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                layout collectionViewLayout: UICollectionViewLayout, </span></span></span><br><span class="line"><span class="function"><span class="params">                minimumInteritemSpacingForSectionAtIndex section: Int)</span></span> -&gt; <span class="type">CGFloat</span></span><br></pre></td></tr></table></figure><blockquote><p>5.该方法是用来设置 UICollectionView 的页头尺寸<br>如果在自定义UICollectionView中实现了该属性, 那么该方法就会覆盖掉原来的属性)</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, </span></span></span><br><span class="line"><span class="function"><span class="params">                layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">    referenceSizeForHeaderInSection section: Int)</span></span> -&gt; <span class="type">CGSize</span></span><br></pre></td></tr></table></figure><blockquote><p>6.该方法是用来设置 UIcollectionView 的页尾尺寸(如果在自定义UICollectionView中实现了该属性, 那么该方法就会覆盖掉原来的属性) </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, referenceSizeForFooterInSection section: Int)</span></span> -&gt; <span class="type">CGSize</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UICollectionView </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UICollectionView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Network-AFNetworking-网络请求</title>
      <link href="/2017/12/13/Swift/Swift/Network/Swift-Network-AFNetworking-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
      <url>/2017/12/13/Swift/Swift/Network/Swift-Network-AFNetworking-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</url>
      <content type="html"><![CDATA[<h1 id="创建数据请求类"><a href="#创建数据请求类" class="headerlink" title="创建数据请求类"></a>创建数据请求类</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">import</span> UIKit  </span><br><span class="line"><span class="keyword">import</span> AFNetworking  </span><br><span class="line"><span class="comment">//请求方法  </span></span><br><span class="line"><span class="comment">/// - GET:  get  </span></span><br><span class="line"><span class="comment">/// - POST: post  </span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RequsetMethod</span>:<span class="title">String</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">GET</span> = <span class="string">"GET"</span>  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">POST</span> =  <span class="string">"POST"</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SPFNetWorkManager</span>: <span class="title">AFHTTPSessionManager</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//单例  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedTools:<span class="type">SPFNetWorkManager</span> = &#123;  </span><br><span class="line">        <span class="keyword">let</span> instance = <span class="type">SPFNetWorkManager</span>()  </span><br><span class="line">        instance.responseSerializer.acceptableContentTypes?.insert(<span class="string">"text/html"</span>)  </span><br><span class="line">        instance.responseSerializer.acceptableContentTypes?.insert(<span class="string">"text/plain"</span>)  </span><br><span class="line">        <span class="keyword">return</span> instance  </span><br><span class="line">    &#125;()  </span><br><span class="line">    <span class="comment">// 定义请求完成的回调的别名  </span></span><br><span class="line">    <span class="keyword">typealias</span> httptoolBack = (response:<span class="type">AnyObject</span>?,error:<span class="type">NSError</span>?)-&gt;()  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/// 请求数据  </span></span><br><span class="line">    <span class="comment">///  </span></span><br><span class="line">    <span class="comment">/// - parameter urlString:  请求地址  </span></span><br><span class="line">    <span class="comment">/// - parameter parameters: 请求参数  </span></span><br><span class="line">    <span class="comment">/// - parameter finished:   请求成功或者失败的回调  </span></span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">request</span><span class="params">(method: RequsetMethod = .GET, urlString: String, parameters: AnyObject?, finished:httptoolBack)</span></span>&#123;  </span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 定义请求成功的闭包  </span></span><br><span class="line">        <span class="keyword">let</span> success = &#123; (dataTask: <span class="type">NSURLSessionDataTask</span>, responseObject: <span class="type">AnyObject</span>?) -&gt; <span class="type">Void</span> <span class="keyword">in</span>  </span><br><span class="line">            finished(response: responseObject, error: <span class="literal">nil</span>)  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 定义请求失败的闭包  </span></span><br><span class="line">        <span class="keyword">let</span> failure = &#123; (dataTask: <span class="type">NSURLSessionDataTask</span>?, error: <span class="type">NSError</span>) -&gt; <span class="type">Void</span> <span class="keyword">in</span>  </span><br><span class="line">            finished(response: <span class="literal">nil</span>, error: error)  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span> method == .<span class="type">GET</span> &#123;  </span><br><span class="line">              </span><br><span class="line">            <span class="type">GET</span>(urlString, parameters: parameters, progress: <span class="literal">nil</span>, success: success, failure: failure)  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="type">POST</span>(urlString, parameters: parameters, progress: <span class="literal">nil</span>, success: success, failure: failure)  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/// 发送请求(上传文件)  </span></span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">requestWithData</span><span class="params">(data: NSData, name: String, urlString: String, parameters: AnyObject?, finished:httptoolBack)</span></span> &#123;  </span><br><span class="line">        <span class="comment">// 定义请求成功的闭包  </span></span><br><span class="line">        <span class="keyword">let</span> success = &#123; (dataTask: <span class="type">NSURLSessionDataTask</span>, responseObject: <span class="type">AnyObject</span>?) -&gt; <span class="type">Void</span> <span class="keyword">in</span>  </span><br><span class="line">            finished(response: responseObject, error: <span class="literal">nil</span>)  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 定义请求失败的闭包  </span></span><br><span class="line">        <span class="keyword">let</span> failure = &#123; (dataTask: <span class="type">NSURLSessionDataTask</span>?, error: <span class="type">NSError</span>) -&gt; <span class="type">Void</span> <span class="keyword">in</span>  </span><br><span class="line">            finished(response: <span class="literal">nil</span>, error: error)  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        <span class="type">POST</span>(urlString, parameters: parameters, constructingBodyWithBlock: &#123; (formData) -&gt; <span class="type">Void</span> <span class="keyword">in</span>  </span><br><span class="line">            formData.appendPartWithFileData(data, name: name, fileName: <span class="string">"aa"</span>, mimeType: <span class="string">"application/octet-stream"</span>)  </span><br><span class="line">            &#125;, progress: <span class="literal">nil</span>, success: success, failure: failure)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> urlString = <span class="string">"http://192.168.3.7:8080/FreshFun/homepage.do"</span>  </span><br><span class="line">       <span class="comment">//创建httpTool 实例  </span></span><br><span class="line">       <span class="keyword">let</span> <span class="type">HttpRequest</span> = <span class="type">SPFNetWorkManager</span>.sharedTools  </span><br><span class="line">       </span><br><span class="line">       <span class="comment">//发送GET请求  </span></span><br><span class="line">       <span class="type">HttpRequest</span>.request(<span class="type">RequsetMethod</span>.<span class="type">GET</span>, urlString: urlString, parameters:<span class="literal">nil</span> ) &#123; (response, error) <span class="keyword">in</span>  </span><br><span class="line">           <span class="built_in">print</span>(response)  </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Optional</span>(&#123;  </span><br><span class="line">           goodsMoney = <span class="string">"22.00"</span>;  </span><br><span class="line">           <span class="string">"goods_des"</span> = <span class="string">"\U9999\U8549\U8089333"</span>;  </span><br><span class="line">           <span class="string">"goods_img"</span> = <span class="string">"/image/2016/9/8/1473340021432.png"</span>;  </span><br><span class="line">           <span class="string">"goods_name"</span> = <span class="type">BananaMeat</span>;  </span><br><span class="line">           id = <span class="number">4</span>;  </span><br><span class="line">           marketMoney = <span class="string">"31.43"</span>;  </span><br><span class="line">       &#125;）</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Network </category>
          
          <category> AFNetworking </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-Lib-SnapKit-自动布局</title>
      <link href="/2017/12/13/Swift/Swift/Lib/SnapKit-%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80/"/>
      <url>/2017/12/13/Swift/Swift/Lib/SnapKit-%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/2bad53a2a180" target="_blank" rel="noopener">https://www.jianshu.com/p/2bad53a2a180</a></p>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Lib </category>
          
          <category> SnapKit </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-Lib-Kingfisher-图片加载库</title>
      <link href="/2017/12/13/Swift/Swift/Lib/Kingfisher-%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93/"/>
      <url>/2017/12/13/Swift/Swift/Lib/Kingfisher-%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93/</url>
      <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/djh996064549/article/details/71085679" target="_blank" rel="noopener">http://blog.csdn.net/djh996064549/article/details/71085679</a></p>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Lib </category>
          
          <category> Kingfisher </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-AccessControl-open</title>
      <link href="/2017/12/11/Swift/Swift/Grammar/AccessControl-open/"/>
      <url>/2017/12/11/Swift/Swift/Grammar/AccessControl-open/</url>
      <content type="html"><![CDATA[<h1 id="open"><a href="#open" class="headerlink" title="open"></a>open</h1><blockquote><p>open弥补public语义上的不足</p></blockquote><h1 id="pubic"><a href="#pubic" class="headerlink" title="pubic"></a>pubic</h1><blockquote><p>现在的pubic有两层含义：</p></blockquote><ul><li>①这个元素可以在其他作用域被访问</li><li>②这个元素可以在其他作用域被继承或者override</li></ul><h1 id="继承问题"><a href="#继承问题" class="headerlink" title="继承问题"></a>继承问题</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote><p>继承是一件危险的事情<br>尤其对于一个framework或者module的设计者而言<br>在自身的module内，类或者属性对于作者而言是清晰的，能否被继承或者override都是可控的,但是对于使用它的人，有时会希望传达出这个类或者属性不应该被继承或者修改,这个对应的就是 final </p></blockquote><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><blockquote><p>问题在于在标记之后，在任何地方都不能override<br>而对于lib的设计者而言，希望得到的是在module内可以被override<br>在被import到其他地方后其他用户使用的时候不能被override</p></blockquote><blockquote><p>这就是open产生的初衷<br>通过open和public标记区别一个元素在其他module中是只能被访问还是可以被override</p></blockquote><p>##举例分析 ModuleA</p><blockquote><p>这个类在ModuleA的范围外是不能被继承的，只能被访问</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonSubclassableParentClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 这是错误的写法，因为class已经不能被继承</span></span><br><span class="line">    <span class="comment">// 所以他的方法的访问权限不能大于类的访问权限</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// final的含义保持不变</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">func</span> <span class="title">baz</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在ModuleA的范围外可以被继承</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">SubclassableParentClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个属性在ModuleA的范围外不能被override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> size : <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法在ModuleA的范围外不能被override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法在任何地方都可以被override</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///final的含义保持不变</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">func</span> <span class="title">baz</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// final的含义保持不变</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalClass</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ModuleB:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ModuleA</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个写法是错误的，编译会失败</span></span><br><span class="line"><span class="comment">// 因为NonSubclassableParentClass类访问权限标记的是public，只能被访问不能被继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubclassA</span> : <span class="title">NonSubclassableParentClass</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样写法可以通过，因为SubclassableParentClass访问权限为 `open`.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubclassB</span> : <span class="title">SubclassableParentClass</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 这样写也会编译失败</span></span><br><span class="line">    <span class="comment">// 因为这个方法在SubclassableParentClass 中的权限为public，不是`open'.</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法因为在SubclassableParentClass中标记为open，所以可以这样写</span></span><br><span class="line">    <span class="comment">// 这里不需要再声明为open，因为这个类是internal的</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">SubclassC</span> : <span class="title">SubclassableParentClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这种写法会编译失败，因为这个类已经标记为open</span></span><br><span class="line">    <span class="comment">// 这个方法override是一个open的方法，则也需要表明访问权限</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> &#123; &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">SubclassD</span> : <span class="title">SubclassableParentClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 正确的写法，方法也需要标记为open</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> &#123; &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">SubclassE</span> : <span class="title">SubclassableParentClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 也可以显式的指出这个方法不能在被override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> &#123; &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Grammar </tag>
            
            <tag> AccessControl </tag>
            
            <tag> open </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-AccessControl-private/filePrivate访问控制-私有</title>
      <link href="/2017/12/11/Swift/Swift/Grammar/AccessControl-private:filePrivate/"/>
      <url>/2017/12/11/Swift/Swift/Grammar/AccessControl-private:filePrivate/</url>
      <content type="html"><![CDATA[<h1 id="private"><a href="#private" class="headerlink" title="private"></a>private</h1><blockquote><p>在原有的swift中的private 并非真正的私有<br>一个变量定义为private，在同一个文件中的其他类依然是可以访问到的<br>在使用extension的时候很明显</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> name = <span class="string">"private"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> accessPrivate: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>带来了两个问题：</p></blockquote><ul><li>标记为private时，意为真的私有还是文件内可共享</li><li>如果意图为真正的私有时，必须保证这个类或者结构体在一个单独的文件里。否则可能同文件里其他的代码访问到</li></ul><h1 id="fileprivate"><a href="#fileprivate" class="headerlink" title="fileprivate"></a>fileprivate</h1><blockquote><p>在swift 3中，新增加 fileprivate 来显式的表明，这个元素的访问权限为 <strong>文件内私有</strong></p></blockquote><ul><li>过去的private对应现在的fileprivate</li><li>现在的private则是真正的私有，离开了这个<strong>类</strong>或者<strong>结构体</strong>的作用域外面就无法访问</li></ul>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
          <category> AccessControl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Grammar </tag>
            
            <tag> AccessControl </tag>
            
            <tag> fileprivate </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-RequiredInit必要初始化器</title>
      <link href="/2017/12/11/Swift/Swift/Grammar/RequiredInit%E5%BF%85%E8%A6%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8/"/>
      <url>/2017/12/11/Swift/Swift/Grammar/RequiredInit%E5%BF%85%E8%A6%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8/</url>
      <content type="html"><![CDATA[<h1 id="必要初始化器"><a href="#必要初始化器" class="headerlink" title="必要初始化器"></a>必要初始化器</h1><blockquote><p>重写类的时候经常提示要添加代码</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">       <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>必要初始化器，这种情况一般会出现在继承了遵守NSCoding protocol的类，比如UIView系列的类、UIViewController系列的类</p></blockquote><h2 id="为什么一定要添加"><a href="#为什么一定要添加" class="headerlink" title="为什么一定要添加"></a>为什么一定要添加</h2><blockquote><p>这是NSCoding protocol定义的，遵守了NSCoding protoaol的所有类必须继承<br>只是有的情况会隐式继承，而有的情况下需要显示实现</p></blockquote><h2 id="什么情况下要显示添加："><a href="#什么情况下要显示添加：" class="headerlink" title="什么情况下要显示添加："></a>什么情况下要显示添加：</h2><blockquote><p>当我们在子类定义了指定初始化器(包括自定义和重写父类指定初始化器)，那么必须显示实现required init?(coder aDecoder: NSCoder)，而其他情况下则会隐式继承，可不用理会。</p></blockquote><h2 id="什么情况下会调用："><a href="#什么情况下会调用：" class="headerlink" title="什么情况下会调用："></a>什么情况下会调用：</h2><blockquote><p>当使用storyboard实现界面的时候，程序会调用这个初始化器。<br>注意要去掉fatalError，fatalError的意思是无条件停止执行并打印。<br>在obj-c中可以通过下面代码实现</p></blockquote><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSException</span> *exception = [<span class="built_in">NSException</span> exceptionWithName:<span class="string">@"HotTeaException"</span> </span><br><span class="line">                                                 reason:<span class="string">@"The tea is too hot"</span> </span><br><span class="line">                                               userInfo:<span class="literal">nil</span>];</span><br><span class="line"> <span class="keyword">@throw</span> exception;</span><br></pre></td></tr></table></figure><h1 id="举例分析"><a href="#举例分析" class="headerlink" title="举例分析"></a>举例分析</h1><h2 id="普通子类"><a href="#普通子类" class="headerlink" title="普通子类"></a>普通子类</h2><blockquote><p>通常情况下，一说到required修饰符，最先想到的应该就是普通类（class）的init()方法</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str:<span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(str:<span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.str = str</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义一个MyClass的子类（subclass）并实例化这个子类"><a href="#定义一个MyClass的子类（subclass）并实例化这个子类" class="headerlink" title="定义一个MyClass的子类（subclass）并实例化这个子类"></a>定义一个MyClass的子类（subclass）并实例化这个子类</h2><blockquote><p>在实例化MySubClass时，其实是继承了它父类MyClass的init()方法<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySubClass</span>:<span class="title">MyClass</span> </span>&#123;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">var</span> <span class="type">MySubClass</span>(str:<span class="string">"Hello Swift"</span>)</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="子类的初始化方法"><a href="#子类的初始化方法" class="headerlink" title="子类的初始化方法"></a>子类的初始化方法</h2><blockquote><p>子类中添加一个init()方法<br>在init()方法前加上override修饰符，表示MySubClass重写了其父类的init()方法，然后还要调用父类的init()方法，并将参数一并传给父类的方法</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySubClass</span>:<span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(str:<span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(str:str)</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="type">MySubClass</span>(str:<span class="string">"Hello Swift"</span></span><br></pre></td></tr></table></figure><blockquote><p>当子类的初始化方法参数类型与父类的初始化方法参数类型不同时，我们就不必在子类的初始化方法前加override修饰符了，但是要把子类初始化方法的参数类型转换为符合父类初始化方法的参数类型，然后传给父类的初始化方法</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> lass <span class="type">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str:<span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(str:<span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.str = str</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySubClass</span>:<span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(i:<span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(str:<span class="type">String</span>(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">MySubClass</span>(i: <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h2 id="给父类的init-方法加上required修饰符"><a href="#给父类的init-方法加上required修饰符" class="headerlink" title="给父类的init()方法加上required修饰符"></a>给父类的init()方法加上required修饰符</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str:<span class="type">String</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(str:<span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.str = str</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySubClass</span>:<span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(i:<span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(str:<span class="type">String</span>(i))</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 编译错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MySubClass</span>(i: <span class="number">10</span>)</span><br></pre></td></tr></table></figure><blockquote><p>因为我们没有实现父类中要去必须要实现的方法</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str:<span class="type">String</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(str:<span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.str = str</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySubClass</span>:<span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(str:<span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(str: str)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(i:<span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(str:<span class="type">String</span>(i))</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MySubClass</span>(i: <span class="number">10</span>)</span><br></pre></td></tr></table></figure><blockquote><p>子类需要添加异于父类的初始化方法时，必须先要实现父类中使用required修饰符修饰过的初始化方法，并且也要使用required修饰符而不是override<br>如果子类中不需要添加任何初始化方法，我们则可以忽略父类的required初始化方法：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str:<span class="type">String</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(str:<span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.str = str</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySubClass</span>:<span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//编译器不会报错，因为如果子类没有任何初始化方法时，Swift会默认使用父类的初始化方法You do not have to provide an explicit implementation of a required initializer if you can satisfy the requirement with an inherited initialiser.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MySubClass</span>(str: <span class="string">"hello swift"</span>)</span><br></pre></td></tr></table></figure><h1 id="required修饰符的使用规则"><a href="#required修饰符的使用规则" class="headerlink" title="required修饰符的使用规则"></a>required修饰符的使用规则</h1><ul><li>required修饰符只能用于修饰类初始化方法</li><li>当子类含有异于父类的初始化方法时（初始化方法参数类型和数量异于父类），子类必须要实现父类的required初始化方法，并且也要使用required修饰符而不是override</li><li>当子类没有初始化方法时，可以不用实现父类的required初始化方法</li></ul><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><blockquote><p>如果代码实现界面，那么我们只要根据编译器提示添加必要初始化器后，就不用理会，我们创建界面的工作可以在自定义的初始化器里实现。</p></blockquote><blockquote><p>补充：let vc = UIViewController()方式初始化类<br>UIViewController类视乎只有两个初始化器，一个是必要初始化器init?(coder aDecoder: NSCoder)，一个是指定初始化器init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: NSBundle?)，那么为什么我们可以用let vc = UIViewController()这种方式初始化类呢？原因可能是这个初始化方式是来自uikit,也就是调用了Object-c下的UIViewController初始化方法，是object-c bridge过来的</p></blockquote>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
          <category> RequiredInit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Grammar </tag>
            
            <tag> RequiredInit </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-4.0更新</title>
      <link href="/2017/12/11/Swift/Swift/Grammar/4-0%E6%9B%B4%E6%96%B0/"/>
      <url>/2017/12/11/Swift/Swift/Grammar/4-0%E6%9B%B4%E6%96%B0/</url>
      <content type="html"><![CDATA[<h1 id="用系统方法setValuesForKeys-赋值问题-swift4"><a href="#用系统方法setValuesForKeys-赋值问题-swift4" class="headerlink" title="用系统方法setValuesForKeys()赋值问题 (swift4)"></a>用系统方法setValuesForKeys()赋值问题 (swift4)</h1><blockquote><p>在swift3中，编译器自动推断@objc，换句话说，它自动添加@objc<br>在swift4中，编译器不再自动推断，你必须显式添加@objc</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@objc</span> <span class="keyword">var</span> content = <span class="string">""</span></span><br><span class="line">swift <span class="number">4.0</span> 版本要在前面加<span class="meta">@objc</span></span><br></pre></td></tr></table></figure><blockquote><p>还有一种更简单的方法，不必一个一个属性的添加,下面这种写法</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@objc</span>Members</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="setValuesForKeys-奔溃-swift4"><a href="#setValuesForKeys-奔溃-swift4" class="headerlink" title="setValuesForKeys()奔溃(swift4)"></a>setValuesForKeys()奔溃(swift4)</h1><blockquote><p>@objc解决了单个属性的问题，一个属性的值是数组字典，用setValuesForKeys()  程序奔溃，xcode9.0.1提示如下 </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[__NSCFConstantString <span class="built_in">count</span>]: unrecognized selector sent to instance <span class="number">0x102cb3290</span></span><br></pre></td></tr></table></figure><blockquote><p>造成崩溃是因为该字段如果为空 用了空串来占位，造成数据类型不一致而崩溃。这个在swift3中没有问题 </p></blockquote>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
          <category> Swift4.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Grammar </tag>
            
            <tag> Swift4.0 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-Guard-关键字/守护</title>
      <link href="/2017/12/11/Swift/Swift/Grammar/%E5%85%B3%E9%94%AE%E5%AD%97-Guard-%E5%AE%88%E6%8A%A4/"/>
      <url>/2017/12/11/Swift/Swift/Grammar/%E5%85%B3%E9%94%AE%E5%AD%97-Guard-%E5%AE%88%E6%8A%A4/</url>
      <content type="html"><![CDATA[<h1 id="guard语句"><a href="#guard语句" class="headerlink" title="guard语句"></a>guard语句</h1><blockquote><p>guard语句判断其后的表达式布尔值为false时，才会执行之后代码块里的代码，如果为true，则跳过整个guard语句<br>guard语句只会有一个代码块，if语句可以if else多个代码块<br>类似  OC里的Continue</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">checkup</span><span class="params">(person: [String: String!])</span></span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 检查身份证，如果身份证没带，则不能进入考场</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> id = person[<span class="string">"id"</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"没有身份证，不能进入考场!"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 检查准考证，如果准考证没带，则不能进入考场</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> examNumber = person[<span class="string">"examNumber"</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"没有准考证，不能进入考场!"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 身份证和准考证齐全，方可进入考场</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"您的身份证号为:<span class="subst">\(id)</span>，准考证号为:<span class="subst">\(examNumber)</span>。请进入考场!"</span>)</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">checkup([<span class="string">"id"</span>: <span class="string">"123456"</span>]) <span class="comment">// 没有准考证，不能进入考场!</span></span><br><span class="line">checkup([<span class="string">"examNumber"</span>: <span class="string">"654321"</span>]) <span class="comment">// 没有身份证，不能进入考场!</span></span><br><span class="line">checkup([<span class="string">"id"</span>: <span class="string">"123456"</span>, <span class="string">"examNumber"</span>: <span class="string">"654321"</span>]) <span class="comment">// 您的身份证号为:123456，准考证号为:654321。请进入考场!</span></span><br></pre></td></tr></table></figure><blockquote><p>上述代码中的第一个guard语句用于检查身份证，如果检查到身份证没带，也就是表达式为false时，执行大括号里的代码，并返回。第二个guard语句则检查准考证。<br>如果两证齐全，则执行最后一个打印语句，上面的两个guard语句大括号内的代码都不会执行，因为他们表达式的布尔值都是true。<br>这里值得注意的是，id和examNumber可以在guard语句之外使用，也就是说当guard对其表达式进行验证后，id和examNumber可在整个方法的作用域中使用，并且是解包后的</p></blockquote><h1 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if else语句"></a>if else语句</h1><blockquote><p>用if else实现的方法显然不如guard实现的那么精准。而且id和examNumber的作用域只限在if的第一个大括号内，超出这个作用域编译就会报错</p></blockquote><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"> func checkupUseIf(person: [String: String!]) &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> let <span class="keyword">id</span> = person[<span class="string">"id"</span>], let examNumber = person[<span class="string">"examNumber"</span>] &#123;</span><br><span class="line">        print(<span class="string">"您的身份证号为:\(id)，准考证号为:\(examNumber)。请进入考场！"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        print(<span class="string">"证件不齐全，不能进入考场!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    print(<span class="string">"您的身份证号为:\(id)，准考证号为:\(examNumber)"</span>)  <span class="comment">// 报异常</span></span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">checkupUseIf([<span class="string">"id"</span>: <span class="string">"123456"</span>]) <span class="comment">// 证件不齐全，不能进入考场!</span></span><br><span class="line">checkupUseIf([<span class="string">"examNumber"</span>: <span class="string">"654321"</span>]) <span class="comment">// 证件不齐全，不能进入考场!</span></span><br><span class="line">checkupUseIf([<span class="string">"id"</span>: <span class="string">"123456"</span>, <span class="string">"examNumber"</span>: <span class="string">"654321"</span>]) <span class="comment">// 您的身份证号为:123456，准考证号为:654321。请进入考场!</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
          <category> Guard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Grammar </tag>
            
            <tag> Guard </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-Inheritance-类继承</title>
      <link href="/2017/12/10/Swift/Swift/Grammar/Inheritance-%E7%B1%BB%E7%BB%A7%E6%89%BF/"/>
      <url>/2017/12/10/Swift/Swift/Grammar/Inheritance-%E7%B1%BB%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<h1 id="Inheritance-类继承-简介"><a href="#Inheritance-类继承-简介" class="headerlink" title="Inheritance-类继承-简介"></a>Inheritance-类继承-简介</h1><blockquote><p>继承性是面向语言特征之一<br>swift的类继承只能发生生在类上，不能发生在枚举和结构体上<br>swift中一个类可以继承另一个类的方法、属性、下标等特征<br>子类   父类（超类）<br>子类继承父类后，可重写父类的方法、属性、下标等<br>单继承，但可遵从多个协议，多重继承可以通过遵从多个协议实现</p></blockquote><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><blockquote><p>场景：面向对象的程序员岳克奎，在编程过程中需要描述和处理个人信息<br>定义类Person</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span>  name:<span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age :<span class="type">Int</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">desription</span><span class="params">()</span></span>-&gt;<span class="type">String</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"<span class="subst">\(name)</span>年龄是：<span class="subst">\(age)</span>岁"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        name = <span class="string">""</span></span><br><span class="line">        age = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>场景：1天后岳克奎遇到新需求，需描述和处理学生的信息，于是定义了一个新的类Student</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span>  name:<span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age :<span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> school: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">desription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"<span class="subst">\(name)</span>年龄是：<span class="subst">\(age)</span>岁"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        name = <span class="string">""</span></span><br><span class="line">        age = <span class="number">1</span></span><br><span class="line">        school = <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>继承方式写</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>:<span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> school: <span class="type">String</span>  <span class="comment">//子类新增</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123; <span class="comment">//重写父类 构造函数</span></span><br><span class="line">        school = <span class="string">""</span>  <span class="comment">// 注意 school 和  super.init() 顺序</span></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        name = <span class="string">""</span></span><br><span class="line">       age = <span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="构造函数的调用规则"><a href="#构造函数的调用规则" class="headerlink" title="构造函数的调用规则"></a>构造函数的调用规则</h1><h2 id="修改上面案例"><a href="#修改上面案例" class="headerlink" title="修改上面案例"></a>修改上面案例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">       <span class="keyword">var</span>  name:<span class="type">String</span></span><br><span class="line">       <span class="keyword">var</span> age :<span class="type">Int</span></span><br><span class="line">       </span><br><span class="line">       <span class="function"><span class="keyword">func</span> <span class="title">desription</span><span class="params">()</span></span>-&gt;<span class="type">String</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"<span class="subst">\(name)</span>年龄是：<span class="subst">\(age)</span>岁"</span></span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">convenience</span> <span class="keyword">init</span> () &#123;       <span class="comment">//  ① 便利构造函数</span></span><br><span class="line">           <span class="keyword">self</span>.<span class="keyword">init</span> (name: <span class="string">"岳克奎"</span>)</span><br><span class="line">           <span class="keyword">self</span>.age = <span class="number">99</span></span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">convenience</span> <span class="keyword">init</span> (name: <span class="type">String</span>) &#123; <span class="comment">// ② 便利构造函数</span></span><br><span class="line">           <span class="keyword">self</span>.<span class="keyword">init</span>(name:name,age:<span class="number">18</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">init</span>(name: <span class="type">String</span>,age: <span class="type">Int</span>) &#123;  <span class="comment">// ③ 指定构造函数</span></span><br><span class="line">           <span class="keyword">self</span>.name = name</span><br><span class="line">           <span class="keyword">self</span>.age = age</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Student</span>:<span class="title">Person</span></span>&#123;</span><br><span class="line">       <span class="keyword">var</span> school: <span class="type">String</span></span><br><span class="line">       <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>,school: <span class="type">String</span> ) &#123; <span class="comment">// ④ 指定构造函数</span></span><br><span class="line">          <span class="keyword">self</span>.school = school</span><br><span class="line">           <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, age: age)</span><br><span class="line">          </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">convenience</span> <span class="keyword">override</span> <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123; <span class="comment">// ⑤ 便利构造函数</span></span><br><span class="line">           <span class="keyword">self</span>.<span class="keyword">init</span> (name: name, age: age, school: <span class="string">"许昌学院"</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">let</span> oneStudent = <span class="type">Student</span>()</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"学生： <span class="subst">\(oneStudent.desription()</span>)"</span>)<span class="comment">//学生： 岳克奎年龄是：99岁</span></span><br></pre></td></tr></table></figure><h2 id="构造函数之间的调用形成构造函数链"><a href="#构造函数之间的调用形成构造函数链" class="headerlink" title="构造函数之间的调用形成构造函数链"></a>构造函数之间的调用形成构造函数链</h2><blockquote><p>swift限制构造函数之间代理调用规则3条：</p></blockquote><blockquote><p>1.指定构造函数必须调用其直接父类的指定构造函数</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student中的 ④ 指定函数调用Person中③ 指定构造函数</span><br></pre></td></tr></table></figure><blockquote><p>2.便利构造函数必须调用同一类中定义的其他构造函数</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student 中的 ⑤ 便利构造函数 调用 同一类中  ④号构造函数，</span><br><span class="line">Person中的  ① 便利构造函数调用同一类中的  ② 便利构造函数，</span><br><span class="line">Person中的 ② 便利构造函数 调用同一类中的 ③ 指定构造函数</span><br></pre></td></tr></table></figure><blockquote><p>3.便利构造函数必须最终以调用一个指定构造函数结束</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student 中的 ⑤ 便利构造函数 调用 同一类中  ④号构造函数，</span><br><span class="line"> Person中的 ② 便利构造函数 调用同一类中的 ③ 指定构造函数</span><br></pre></td></tr></table></figure><h1 id="构造过程安全检查"><a href="#构造过程安全检查" class="headerlink" title="构造过程安全检查"></a>构造过程安全检查</h1><h2 id="类的构造的两个阶段"><a href="#类的构造的两个阶段" class="headerlink" title="类的构造的两个阶段"></a>类的构造的两个阶段</h2><blockquote><p>分析图：书Page 200页</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.分配内存 ---&gt;初始化子类存储属性---&gt;沿构造函数链向上初始父类存储属性 </span><br><span class="line">到达构造函数链顶部，出书画全部的父类存储属性</span><br><span class="line"></span><br><span class="line">2.修改属性  ---&gt; 调用方法</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
          <category> Inheritance </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Grammar </tag>
            
            <tag> Inheritance </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-Character字符</title>
      <link href="/2017/12/08/Swift/Swift/Grammar/Character%E5%AD%97%E7%AC%A6/"/>
      <url>/2017/12/08/Swift/Swift/Grammar/Character%E5%AD%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<h1 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h1><ul><li>swift 采用Unicode编码</li><li><p>一个字符可以用字符本身，也可以用Unicode编码</p><h2 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h2></li><li><p>C 和 OC等，字符放在(‘)之间的</p></li><li>Swift （””）双引号<blockquote><p>Unicode编码可以有 单、双、四字节编码<br>表现形式  \u{}     n为1-8个16尽职数</p></blockquote></li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> andSign1:<span class="type">Character</span> = <span class="string">"&amp;"</span>       <span class="comment">//用字符本</span></span><br><span class="line"><span class="built_in">print</span>(andSign1)                    <span class="comment">// &amp;</span></span><br><span class="line"><span class="keyword">let</span> andSign2:<span class="type">Character</span> = <span class="string">"\u&#123;26&#125;"</span>  <span class="comment">//用Unicode编码</span></span><br><span class="line"><span class="built_in">print</span>(andSign2)                    <span class="comment">// &amp;</span></span><br></pre></td></tr></table></figure><blockquote><p>Swift字符类型是Character。声明let/var<br>如果省略Character类型声明,自动推段是字符串，”&amp;”默认是字符串类型</p></blockquote><h2 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h2><table><thead><tr><th>字符表示</th><th>Uicode编码</th><th>说明</th></tr></thead><tbody><tr><td>\t</td><td>\u{0009}</td><td>水平制表符tab</td></tr><tr><td>\n</td><td>\u{000a}</td><td>换行</td></tr><tr><td>\r</td><td>\u{000d}</td><td>回车</td></tr><tr><td>\”</td><td>\u{0022}</td><td>双引号</td></tr><tr><td>\’</td><td>\u{0027}</td><td>单引号</td></tr><tr><td>\</td><td>\u{005c}</td><td>反斜线</td></tr></tbody></table><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转义符</span></span><br><span class="line">      <span class="keyword">let</span> specialCharTab1 = <span class="string">"Yue\tKekui"</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"specialCharTab1:<span class="subst">\(specialCharTab1)</span>"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
          <category> String </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Grammar </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-Lazy-懒加载</title>
      <link href="/2017/12/08/Swift/Swift/Grammar/Lazy-%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
      <url>/2017/12/08/Swift/Swift/Grammar/Lazy-%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
      <content type="html"><![CDATA[<h1 id="惰性初始化"><a href="#惰性初始化" class="headerlink" title="惰性初始化"></a>惰性初始化</h1><blockquote><p>懒加载本质上是一个 闭包<br>懒加载会在第一次访问的时候执行, 闭包执行结束后, 会把结果保存在 属性 中<br>后续调用, 直接返回 属性 的内容<br>懒加载的属性会分配空间, 存储值<br>只要调用过一次, 懒加载后面的闭包再也不会执行了<br>延迟加载, 减少内存的消耗,初始化并且分配空间, 会提前创建<br>可以解除解包的烦恼<br>被设置为 nil, 懒加载也不会再次执行<br>懒加载的代码只会在第一次调用的时候, 执行闭包, 然后将闭包的结果保存在 的属性中<br>Swift中，有两种方式来惰性初始化</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">DemoLabel</span>: <span class="title">UILabel</span> </span>&#123;</span><br><span class="line">    <span class="comment">//模型 ---&gt; 给视图设置模型, 由视图自己根据模型的数据显示内容</span></span><br><span class="line">    <span class="keyword">var</span> person: <span class="type">Student</span>? &#123;</span><br><span class="line">        <span class="comment">// 就是替代 OC 中重写 setter 方法 , 区别: 再也不需要考虑  _成员变量 = 值, OC 中如果是 copy 属性, 应该 _成员变量 = [值 copy]</span></span><br><span class="line">        <span class="keyword">didSet</span>&#123;</span><br><span class="line">         <span class="comment">// 此时 name 属性已经有值, 可以直接使用设置 UI 内容</span></span><br><span class="line">            text = person?.name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">var</span> label: <span class="type">DemoLabel</span>?</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        &#123;&#125; 包装代码</span></span><br><span class="line"><span class="comment">        () 执行代码</span></span><br><span class="line"><span class="comment">        日常开发:</span></span><br><span class="line"><span class="comment">        1. 闭包中的智能提示不好</span></span><br><span class="line"><span class="comment">        2. 闭包中如果出现 self. 还需要注意循环引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> label2 = &#123; () -&gt; <span class="type">DemoLabel</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> l = <span class="type">DemoLabel</span>()</span><br><span class="line">        <span class="comment">// 设置 Label 的属性...</span></span><br><span class="line">        <span class="keyword">return</span> l</span><br><span class="line">    &#125;()</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 注意: 一旦 label 被设置为 nil, 懒加载也不会再次执行</span></span><br><span class="line">    <span class="comment">// 懒加载的代码只会在第一次调用的时候, 执行闭包, 然后将闭包的结果保存在 label 的属性中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> label3: <span class="type">UILabel</span>? = <span class="type">UILabel</span>()</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 设置 UI</span></span><br><span class="line">        setupUI()</span><br><span class="line">      </span><br><span class="line">        label3?.text = <span class="string">"hello"</span></span><br><span class="line">        label3?.sizeToFit()</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">print</span>(label3 <span class="keyword">as</span> <span class="type">Any</span>)</span><br><span class="line">       </span><br><span class="line">        label3 = <span class="literal">nil</span></span><br><span class="line">       </span><br><span class="line">        <span class="built_in">print</span>(label3 <span class="keyword">as</span> <span class="type">Any</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupUI</span><span class="params">()</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. swvf控件</span></span><br><span class="line">        label = <span class="type">DemoLabel</span>()</span><br><span class="line">        <span class="comment">// ! 解包, 为了参与计算, addSubView 用 subViews 数组记录控件, 数组中不允许加入 nil</span></span><br><span class="line">        <span class="comment">// ? 可选解包, 调用方法, 如果为 nil, 不调用方法, 但是不能参与计算</span></span><br><span class="line">        view.addSubview(label!)</span><br><span class="line">       </span><br><span class="line">        label?.text = <span class="string">"hello"</span></span><br><span class="line">        label?.sizeToFit()</span><br><span class="line">        label?.center = view.center</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Swift 中一定注意不要主动清理视图或者控件// 因为懒加载不会再次创建</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单表达式"><a href="#简单表达式" class="headerlink" title="简单表达式"></a>简单表达式</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> first = <span class="type">NSArray</span>(objects: <span class="string">"1"</span>,<span class="string">"2"</span>)</span><br></pre></td></tr></table></figure><p>##闭包</p><blockquote><p>不要忘记最后的小括号，只有加了小括号，必包才会在掉用的时候立刻执行<br>要类型声明lazy var second:String，这样Xcode会进行类型检</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> second:<span class="type">String</span> = &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"second"</span></span><br><span class="line">       &#125;()  </span><br><span class="line"><span class="comment">//&#123;&#125; 包装代码 () 执行代码</span></span><br></pre></td></tr></table></figure><h1 id="惰性初始化的使用场景"><a href="#惰性初始化的使用场景" class="headerlink" title="惰性初始化的使用场景"></a>惰性初始化的使用场景</h1><h2 id="①属性本身依赖于外部因素才能初始化"><a href="#①属性本身依赖于外部因素才能初始化" class="headerlink" title="①属性本身依赖于外部因素才能初始化"></a>①属性本身依赖于外部因素才能初始化</h2><blockquote><p>completeURL表示完整的URL，这个变量依赖于自身的url是否含有http://前缀</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url:<span class="type">NSString</span></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> completeURL:<span class="type">NSString</span> = &#123;</span><br><span class="line">        [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.url.hasPrefix(<span class="string">"http://"</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.url</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"http://"</span>.stringByAppendingString(<span class="keyword">self</span>.url)</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    <span class="keyword">init</span>(url:<span class="type">NSString</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.url = url</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="②属性需要复杂计算，消耗大量CPU"><a href="#②属性需要复杂计算，消耗大量CPU" class="headerlink" title="②属性需要复杂计算，消耗大量CPU"></a>②属性需要复杂计算，消耗大量CPU</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> second:<span class="type">Int</span> = &#123;</span><br><span class="line">       <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">100000</span>&#123;</span><br><span class="line">           sum += i</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sum</span><br><span class="line">       &#125;()</span><br></pre></td></tr></table></figure><h2 id="③属性不确定是否会使用到"><a href="#③属性不确定是否会使用到" class="headerlink" title="③属性不确定是否会使用到"></a>③属性不确定是否会使用到</h2><blockquote><p>官网的例子，注意，对于Manager来说，使用的时候，可能导入，也可能不倒入数据。从硬盘读取数据的代价是很大的，不导入数据的时候，不要初始化</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataImporter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    DataImporter is a class to import data from an external file.</span></span><br><span class="line"><span class="comment">    The class is assumed to take a non-trivial amount of time to initialize.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> fileName = <span class="string">"data.txt"</span></span><br><span class="line">    <span class="comment">// the DataImporter class would provide data importing functionality here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataManager</span> </span>&#123;</span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> importer = <span class="type">DataImporter</span>()</span><br><span class="line">    <span class="keyword">var</span> data = [<span class="type">String</span>]()</span><br><span class="line">    <span class="comment">// the DataManager class would provide data management functionality here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manager = <span class="type">DataManager</span>()</span><br><span class="line">manager.data.append(<span class="string">"Some data"</span>)</span><br><span class="line">manager.data.append(<span class="string">"Some more data"</span>)</span><br></pre></td></tr></table></figure><h2 id="④定制化的初始化"><a href="#④定制化的初始化" class="headerlink" title="④定制化的初始化"></a>④定制化的初始化</h2><blockquote><p>有些初始化只需要初始化一次，在变量定义的地方初始化，有助于代码维护</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> dataArray:<span class="type">NSMutableArray</span> = &#123;</span><br><span class="line">       <span class="keyword">var</span> array = <span class="type">NSMutableArray</span>()</span><br><span class="line">       <span class="keyword">for</span>  i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">100</span>&#123;</span><br><span class="line">           array.addObject(<span class="type">NSNumber</span>(integer: i))</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> array</span><br><span class="line">       &#125;()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
          <category> Lazy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Grammar </tag>
            
            <tag> Lazy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-Override重写</title>
      <link href="/2017/12/08/Swift/Swift/Grammar/Override-%E9%87%8D%E5%86%99/"/>
      <url>/2017/12/08/Swift/Swift/Grammar/Override-%E9%87%8D%E5%86%99/</url>
      <content type="html"><![CDATA[<h1 id="定义一个类"><a href="#定义一个类" class="headerlink" title="定义一个类"></a>定义一个类</h1><blockquote><p>定义可继承的基础类<br>nameStr： 人名<br>abilityInt ： 能力值</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nameStr: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> abilityInt: <span class="type">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">des</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"<span class="subst">\(nameStr)</span>的能力值<span class="subst">\(abilityInt)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        nameStr    = <span class="string">"YueKekui"</span></span><br><span class="line">        abilityInt = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="重写父类方法"><a href="#重写父类方法" class="headerlink" title="重写父类方法"></a>重写父类方法</h1><h2 id="重写init"><a href="#重写init" class="headerlink" title="重写init"></a>重写init</h2><blockquote><p>init<br>nationalityStr:新加国籍</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinesePeople</span>:<span class="title">People</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nationalityStr = <span class="string">"中国🇨🇳"</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        nameStr    = <span class="string">"ChenJian"</span></span><br><span class="line">        abilityInt = <span class="number">666</span></span><br><span class="line">        <span class="comment">//self.nameStr = "LuGaygay"</span></span><br><span class="line">        <span class="comment">//self.abilityInt = 8888</span></span><br><span class="line">        <span class="comment">//继承了父类的属性，因此nameStr、 self.nameStr的属性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">des</span><span class="params">()</span></span>-&gt;<span class="type">String</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.des() + <span class="string">"他是<span class="subst">\(nationalityStr)</span>人"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> onePeople =  <span class="type">ChinesePeople</span>.<span class="keyword">init</span>()</span><br><span class="line"><span class="built_in">print</span>( onePeople.des()) <span class="comment">// ChenJian的能力值666他是中国🇨🇳人</span></span><br></pre></td></tr></table></figure><h1 id="重写属性"><a href="#重写属性" class="headerlink" title="重写属性"></a>重写属性</h1><blockquote><p>子类并不知道继承来的属性是储值型还是算值型，它只知道继承来的属性有一个名字和类型，所以在重写属性时必须把它的名字和类型都写出来<br>储值属性可以重写为算值属性<br>只读可以重写为读写；读写不能重写为只读<br>不想重写getter，可以直接返回super.Someproperty</p></blockquote><h2 id="Get-Set"><a href="#Get-Set" class="headerlink" title="Get/Set"></a>Get/Set</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AmericanPeople</span>: <span class="title">ChinesePeople</span> </span>&#123;</span><br><span class="line">   <span class="comment">// override var nationalityStr = "美国🇺🇸"</span></span><br><span class="line"><span class="comment">////重写了父类的属性nationalityStr，因此self和super的nationalityStr是两个不同的属性</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> nationalityStr:<span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.nationalityStr</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.nationalityStr = <span class="string">"美国🇺🇸"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印-1"><a href="#打印-1" class="headerlink" title="打印"></a>打印</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> secondPeople = <span class="type">AmericanPeople</span>.<span class="keyword">init</span>()</span><br><span class="line">     secondPeople.nationalityStr = <span class="string">"注意重写set get的返回"</span></span><br><span class="line">     <span class="built_in">print</span>(secondPeople.des()) <span class="comment">// ChenJian的能力值666他是美国🇺🇸人</span></span><br></pre></td></tr></table></figure><h1 id="重写属性观察器"><a href="#重写属性观察器" class="headerlink" title="重写属性观察器"></a>重写属性观察器</h1><blockquote><p>可以为继承来的变量储值属性添加属性观察器<br>可以值重写didSet或willSet</p></blockquote><h2 id="didSet"><a href="#didSet" class="headerlink" title="didSet"></a>didSet</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AustraliansPeople</span>: <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> richInt = <span class="number">1</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> abilityInt: <span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">didSet</span>&#123;</span><br><span class="line">            richInt = <span class="type">Int</span>(abilityInt*<span class="number">2</span>)+<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写打印方法</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">des</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.des()+<span class="string">"财富指标<span class="subst">\(richInt)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印-2"><a href="#打印-2" class="headerlink" title="打印"></a>打印</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thirdPeople = <span class="type">AustraliansPeople</span>.<span class="keyword">init</span>()</span><br><span class="line">     thirdPeople.abilityInt = <span class="number">5</span></span><br><span class="line">     <span class="built_in">print</span>(thirdPeople.des())  <span class="comment">//YueKekui的能力值5财富指标12</span></span><br></pre></td></tr></table></figure><h1 id="防止重写"><a href="#防止重写" class="headerlink" title="防止重写"></a>防止重写</h1><blockquote><p>通过把方法、属性或下标标记为final来防止它们被重写<br>在扩展中，添加到类里的方法、属性或下标也可以在扩展的定义里标记为final<br>可以在class前添加final来将整个定义为不能重写，这样的类是不可继承的</p></blockquote>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Grammar </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UITableView</title>
      <link href="/2017/12/07/Swift/Swift/UIKit/UITableView/"/>
      <url>/2017/12/07/Swift/Swift/UIKit/UITableView/</url>
      <content type="html"><![CDATA[<h1 id="UITableView"><a href="#UITableView" class="headerlink" title="UITableView"></a>UITableView</h1><h2 id="声明tableView-UITableView变量"><a href="#声明tableView-UITableView变量" class="headerlink" title="声明tableView:UITableView变量"></a>声明tableView:UITableView变量</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> kSize=<span class="type">UIScreen</span>.main.bounds;</span><br><span class="line"><span class="keyword">var</span> _tableView:<span class="type">UITableView</span>!          <span class="comment">//tableView</span></span><br><span class="line"><span class="keyword">var</span>  data :[(<span class="type">String</span>,<span class="type">String</span>)] = [(<span class="string">"寥寥"</span>,<span class="string">"有点绿"</span>),(<span class="string">"卢Gaygay"</span>,<span class="string">"有点Gay"</span>),(<span class="string">"222"</span>,<span class="string">"2---2"</span>),(<span class="string">"333"</span>,<span class="string">"3--3"</span>)]      <span class="comment">//数据源</span></span><br></pre></td></tr></table></figure><h2 id="声明tableView的数据源的代理协议"><a href="#声明tableView的数据源的代理协议" class="headerlink" title="声明tableView的数据源的代理协议"></a>声明tableView的数据源的代理协议</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>,<span class="title">UITableViewDataSource</span>,<span class="title">UITableViewDelegate</span> </span>&#123;</span><br></pre></td></tr></table></figure><h2 id="MARK-设置tableView"><a href="#MARK-设置tableView" class="headerlink" title="MARK: 设置tableView"></a>MARK: 设置tableView</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeTableView</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   _tableView = <span class="type">UITableView</span>.<span class="keyword">init</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0.0</span>,</span><br><span class="line">                                               y: <span class="number">64</span>,</span><br><span class="line">                                               width: kSize.width,</span><br><span class="line">                                               height: kSize.height-<span class="number">64</span>),</span><br><span class="line">                                 style:.plain)</span><br><span class="line">    <span class="keyword">self</span>.view.addSubview(_tableView);  <span class="comment">// 添加tableView</span></span><br><span class="line">    _tableView.dataSource = <span class="keyword">self</span>;</span><br><span class="line">    _tableView.delegate = <span class="keyword">self</span>;</span><br><span class="line">    _tableView.showsVerticalScrollIndicator = <span class="literal">false</span></span><br><span class="line">    _tableView.showsHorizontalScrollIndicator = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    _tableView.tableFooterView = <span class="type">UIView</span>()    <span class="comment">//tableFooter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MARK-实现tableView-dataSource协议中方法"><a href="#MARK-实现tableView-dataSource协议中方法" class="headerlink" title="MARK: 实现tableView.dataSource协议中方法"></a>MARK: 实现tableView.dataSource协议中方法</h2><h3 id="MARK-行"><a href="#MARK-行" class="headerlink" title="MARK: 行"></a>MARK: 行</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data.<span class="built_in">count</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MARK-Cell"><a href="#MARK-Cell" class="headerlink" title="MARK: Cell"></a>MARK: Cell</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"陈建"</span>)</span><br><span class="line">    <span class="keyword">if</span> cell == <span class="literal">nil</span> &#123;</span><br><span class="line">        cell = <span class="type">UITableViewCell</span>(style:<span class="type">UITableViewCellStyle</span>.<span class="keyword">default</span>,reuseIdentifier:<span class="string">"陈建"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> btn:<span class="type">UIButton</span> = <span class="type">UIButton</span>.<span class="keyword">init</span>(type:<span class="type">UIButtonType</span>.custom)</span><br><span class="line">    btn.frame = <span class="type">CGRect</span>(x:<span class="type">UIScreen</span>.main.bounds.width - <span class="number">100</span>, y:<span class="number">10</span>, width:<span class="number">80</span>, height:<span class="number">50</span>)</span><br><span class="line">    btn.backgroundColor = <span class="type">UIColor</span>.red;</span><br><span class="line">    btn.setTitle(<span class="string">"btn标题"</span>, <span class="keyword">for</span>: <span class="type">UIControlState</span>.normal)</span><br><span class="line">    btn.setTitleColor(<span class="type">UIColor</span>.blue, <span class="keyword">for</span>: <span class="type">UIControlState</span>.normal)</span><br><span class="line">    btn.tag = indexPath.row</span><br><span class="line">    btn.addTarget(<span class="keyword">self</span>, action:#selector(clickBtnAction), <span class="keyword">for</span>: .touchUpInside)</span><br><span class="line">    </span><br><span class="line">    cell?.textLabel?.text = data[indexPath.row].<span class="number">0</span>;</span><br><span class="line">    cell?.contentView.addSubview(btn);</span><br><span class="line">    cell?.accessoryType=<span class="type">UITableViewCellAccessoryType</span>.disclosureIndicator</span><br><span class="line">    <span class="keyword">return</span> cell!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MARK-cell-高度"><a href="#MARK-cell-高度" class="headerlink" title="MARK: cell- 高度"></a>MARK: cell- 高度</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, heightForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">66</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="头部高度"><a href="#头部高度" class="headerlink" title="头部高度"></a>头部高度</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, heightForHeaderInSection section: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.01</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="底部高度"><a href="#底部高度" class="headerlink" title="底部高度"></a>底部高度</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, heightForFooterInSection section: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.01</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选中cell时触发"><a href="#选中cell时触发" class="headerlink" title="选中cell时触发"></a>选中cell时触发</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, didSelectRowAt indexPath: IndexPath)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"indexPath.row = SelectRow 第<span class="subst">\(indexPath.row)</span>行"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取消选中cell时"><a href="#取消选中cell时" class="headerlink" title="取消选中cell时"></a>取消选中cell时</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, didDeselectRowAt indexPath: IndexPath)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"indexPath.row = DeselectRow 第<span class="subst">\(indexPath.row)</span>行"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="允许编辑cell"><a href="#允许编辑cell" class="headerlink" title="允许编辑cell"></a>允许编辑cell</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, canEditRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="右滑触发删除按钮"><a href="#右滑触发删除按钮" class="headerlink" title="右滑触发删除按钮"></a>右滑触发删除按钮</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, editingStyleForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCellEditingStyle</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UITableViewCellEditingStyle</span>.<span class="keyword">init</span>(rawValue: <span class="number">1</span>)!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="点击删除cell时触发"><a href="#点击删除cell时触发" class="headerlink" title="点击删除cell时触发"></a>点击删除cell时触发</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"indexPath.row = editingStyle第<span class="subst">\(indexPath.row)</span>行"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="点击btn的方法"><a href="#点击btn的方法" class="headerlink" title="点击btn的方法"></a>点击btn的方法</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clickBtnAction</span> <span class="params">(sender:UIButton)</span></span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"点击了 btn"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UITableView </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UITableView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UIWebView/WKWebView</title>
      <link href="/2017/12/07/Swift/Swift/UIKit/Swift-UIKit-UIWebView-WKWebView/"/>
      <url>/2017/12/07/Swift/Swift/UIKit/Swift-UIKit-UIWebView-WKWebView/</url>
      <content type="html"><![CDATA[<h1 id="UIWebView"><a href="#UIWebView" class="headerlink" title="UIWebView"></a>UIWebView</h1><blockquote><p>UIWebView功能强大，除了能够显示页面之外，还能显示HTML语言，CSS，PPT，Word等等，其用法也简单</p></blockquote><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> webView = <span class="type">UIWebView</span>.<span class="keyword">init</span>(frame:<span class="keyword">self</span>.view.frame)</span><br></pre></td></tr></table></figure><p>##添加<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.view.addSubview(webView)</span><br></pre></td></tr></table></figure></p><h2 id="加载网页"><a href="#加载网页" class="headerlink" title="加载网页"></a>加载网页</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">webView.loadRequest(<span class="type">NSURLRequest</span>(url:<span class="type">NSURL</span>.<span class="keyword">init</span>(string:<span class="string">"http://www.jianshu.com/u/1acf2b5a2f69"</span>) <span class="keyword">as</span>! <span class="type">URL</span>) <span class="keyword">as</span> <span class="type">URLRequest</span>)</span><br></pre></td></tr></table></figure><h2 id="脚本注入"><a href="#脚本注入" class="headerlink" title="脚本注入"></a>脚本注入</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsPath =  <span class="type">NSBundle</span>.mainBundle().pathForResource(<span class="string">"app"</span>, ofType: <span class="string">"js"</span>)</span><br></pre></td></tr></table></figure><h2 id="获取到脚本中的内容"><a href="#获取到脚本中的内容" class="headerlink" title="获取到脚本中的内容"></a>获取到脚本中的内容</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsString :<span class="type">String</span> = <span class="keyword">try</span>! <span class="type">String</span>(contentsOfFile: jsPath!, encoding: <span class="number">4</span>)</span><br><span class="line"><span class="comment">//将获得的文本内容后面的\n替换为空的字符串</span></span><br><span class="line">jsString = jsString.stringByReplacingOccurrencesOfString(<span class="string">"\n"</span>, withString: <span class="string">""</span>)</span><br></pre></td></tr></table></figure><h2 id="触发脚本"><a href="#触发脚本" class="headerlink" title="触发脚本"></a>触发脚本</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">webView.stringByEvaluatingJavaScriptFromString(jsString <span class="keyword">as</span> <span class="type">String</span>)</span><br></pre></td></tr></table></figure><h2 id="webView-scalesPageToFit"><a href="#webView-scalesPageToFit" class="headerlink" title="webView.scalesPageToFit"></a>webView.scalesPageToFit</h2><blockquote><p>有点时候我们加载的网页页面比较大的话 是无法的完全显示在webView上，这个时候我们需要调节webView的scalesPageToFit属性来实现页面适应webView区域的效果</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">webView.scalesPageToFit = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="dataDetectorTypes"><a href="#dataDetectorTypes" class="headerlink" title="dataDetectorTypes"></a>dataDetectorTypes</h2><blockquote><p>我们可以通过设置webView的dataDetectorTypes属性来识别出网页上的电话号码，超链接，邮箱等一些特殊信息，在我们对其进行相关操作的时候可以出发关联事件</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> webView.dataDetectorTypes = .address</span><br><span class="line"></span><br><span class="line"><span class="comment">//dataDetectorTypes包含以下类型：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">UIDataDetectorTypes</span> : <span class="title">OptionSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(rawValue: <span class="type">UInt</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> phoneNumber: <span class="type">UIDataDetectorTypes</span> &#123; <span class="keyword">get</span> &#125; <span class="comment">// Phone number detection</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> link: <span class="type">UIDataDetectorTypes</span> &#123; <span class="keyword">get</span> &#125; <span class="comment">// URL detection</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">4.0</span>, *)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> address: <span class="type">UIDataDetectorTypes</span> &#123; <span class="keyword">get</span> &#125; <span class="comment">// Street address detection</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">4.0</span>, *)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> calendarEvent: <span class="type">UIDataDetectorTypes</span> &#123; <span class="keyword">get</span> &#125; <span class="comment">// Event detection</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">10.0</span>, *)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> shipmentTrackingNumber: <span class="type">UIDataDetectorTypes</span> &#123; <span class="keyword">get</span> &#125; <span class="comment">// Shipment tracking number detection</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">10.0</span>, *)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> flightNumber: <span class="type">UIDataDetectorTypes</span> &#123; <span class="keyword">get</span> &#125; <span class="comment">// Flight number detection</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">10.0</span>, *)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> lookupSuggestion: <span class="type">UIDataDetectorTypes</span> &#123; <span class="keyword">get</span> &#125; <span class="comment">// Information users may want to look up</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> all: <span class="type">UIDataDetectorTypes</span> &#123; <span class="keyword">get</span> &#125; <span class="comment">// Enable all types, including types that may be added later</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>UIWebView在加载网页的时候有一些对应的状态，我们可以进行检测：<br>首先实现其代理：UIWebViewDelegate<br>然后设置其代理对象：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">webView.delegate = <span class="keyword">self</span>;</span><br></pre></td></tr></table></figure><blockquote><p>实现代理方法：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">UIWebViewDelegate</span> : <span class="title">NSObjectProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链接地址发生改变的时候调用</span></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">2.0</span>, *)</span><br><span class="line">    <span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(<span class="number">_</span> webView: UIWebView, shouldStartLoadWith request: URLRequest, navigationType: UIWebViewNavigationType)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始加载</span></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">2.0</span>, *)</span><br><span class="line">    <span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">webViewDidStartLoad</span><span class="params">(<span class="number">_</span> webView: UIWebView)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//完成加载</span></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">2.0</span>, *)</span><br><span class="line">    <span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">webViewDidFinishLoad</span><span class="params">(<span class="number">_</span> webView: UIWebView)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加载失败</span></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">2.0</span>, *)</span><br><span class="line">    <span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(<span class="number">_</span> webView: UIWebView, didFailLoadWithError error: Error)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以对webView加载状态进行控制，比如：停止加载，继续加载等，其设置方法为：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//重新加载</span></span><br><span class="line">- (void)reload;</span><br><span class="line"><span class="comment">//停止加载</span></span><br><span class="line">- (void)stopLoading;</span><br><span class="line"><span class="comment">//返回</span></span><br><span class="line">- (void)goBack;</span><br><span class="line"><span class="comment">//前往</span></span><br><span class="line">- (void)goForward;</span><br></pre></td></tr></table></figure><blockquote><p>以下是UIWebView对于HTML语言，本地文件等信息的加载：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//加载HTML文本</span></span><br><span class="line">- (void)loadHTMLString:(<span class="type">NSString</span> *)string baseURL:(nullable <span class="type">NSURL</span> *)baseURL;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载Data类型</span></span><br><span class="line">- (void)loadData:(<span class="type">NSData</span> *)data <span class="type">MIMEType</span>:(<span class="type">NSString</span> *)<span class="type">MIMEType</span> textEncodingName:(<span class="type">NSString</span> *)textEncodingName baseURL:(<span class="type">NSURL</span> *)baseURL;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现与JS的交互</span></span><br><span class="line">- (nullable <span class="type">NSString</span> *)stringByEvaluatingJavaScriptFromString:(<span class="type">NSString</span> *)script;</span><br></pre></td></tr></table></figure><h1 id="WKWebView"><a href="#WKWebView" class="headerlink" title="WKWebView"></a>WKWebView</h1><blockquote><p>使用方法</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//创建</span></span><br><span class="line"><span class="keyword">let</span> wkWebView = <span class="type">WKWebView</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置位置和大小</span></span><br><span class="line">wkWebView.frame = <span class="keyword">self</span>.view.frame;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建的时候就设置位置和大小</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    public init(frame: CGRect, configuration: WKWebViewConfiguration)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> webview = <span class="type">WKWebView</span>(frame: <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.view.frame.width, <span class="keyword">self</span>.view.frame.height))</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加</span></span><br><span class="line"><span class="keyword">self</span>.view.addSubview(wkWebView)</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    open func load(_ request: URLRequest) -&gt; WKNavigation?</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">wkWebView.load(<span class="type">NSURLRequest</span>(url: <span class="type">NSURL</span>(string:<span class="string">"http://www.baidu.com"</span>) <span class="keyword">as</span>! <span class="type">URL</span>) <span class="keyword">as</span> <span class="type">URLRequest</span>)</span><br></pre></td></tr></table></figure><blockquote><p>WKWebView的代理方法：<br>WKNavigationDelegate<br>通过WKNavigationDelegate提供的代理方法，我们可以追踪WKWebView加载的过程</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> /页面开始加载时调用</span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</span><br><span class="line">    <span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(<span class="number">_</span> webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面加载失败时调用</span></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</span><br><span class="line">    <span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(<span class="number">_</span> webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation!, withError error: Error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当内容开始返回时调用</span></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</span><br><span class="line">    <span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(<span class="number">_</span> webView: WKWebView, didCommit navigation: WKNavigation!)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面加载完成之后调用</span></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</span><br><span class="line">    <span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(<span class="number">_</span> webView: WKWebView, didFinish navigation: WKNavigation!)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>页面跳转的代理方法有三种，分为（收到跳转与决定是否跳转两种）</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 接收到服务器跳转请求之后调用</span></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</span><br><span class="line">    <span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(<span class="number">_</span> webView: WKWebView, didReceiveServerRedirectForProvisionalNavigation navigation: WKNavigation!)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在发送请求之前，决定是否跳转</span></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</span><br><span class="line">    <span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(<span class="number">_</span> webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping <span class="params">(WKNavigationActionPolicy)</span></span></span> -&gt; <span class="type">Swift</span>.<span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在收到响应后，决定是否跳转</span></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</span><br><span class="line">    <span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(<span class="number">_</span> webView: WKWebView, decidePolicyFor navigationResponse: WKNavigationResponse, decisionHandler: @escaping <span class="params">(WKNavigationResponsePolicy)</span></span></span> -&gt; <span class="type">Swift</span>.<span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//web内容视图被终止的时候触发</span></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">9.0</span>, *)</span><br><span class="line">    <span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">webViewWebContentProcessDidTerminate</span><span class="params">(<span class="number">_</span> webView: WKWebView)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>WKUIDelegate</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">/ 创建一个新的<span class="type">WebView</span></span><br><span class="line">   <span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</span><br><span class="line">   <span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(<span class="number">_</span> webView: WKWebView, createWebViewWith configuration: WKWebViewConfiguration, <span class="keyword">for</span> navigationAction: WKNavigationAction, windowFeatures: WKWindowFeatures)</span></span> -&gt; <span class="type">WKWebView</span>?</span><br></pre></td></tr></table></figure><blockquote><p>web界面的三种提示框（警告框、确认框、输入框）分别对应三种代理方法</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  web界面中有弹出警告框时调用</span></span><br><span class="line"><span class="comment"> *  @param webView           实现该代理的webview</span></span><br><span class="line"><span class="comment"> *  @param message           警告框中的内容</span></span><br><span class="line"><span class="comment"> *  @param frame             主窗口</span></span><br><span class="line"><span class="comment"> *  @param completionHandler 警告框消失调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</span><br><span class="line">    <span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(<span class="number">_</span> webView: WKWebView, runJavaScriptAlertPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Swift</span>.<span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  web界面中有弹出确认框时调用</span></span><br><span class="line"><span class="comment"> *  @param webView           实现该代理的webview</span></span><br><span class="line"><span class="comment"> *  @param message           确认框中的内容</span></span><br><span class="line"><span class="comment"> *  @param frame             主窗口</span></span><br><span class="line"><span class="comment"> *  @param completionHandler 确认框消失调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</span><br><span class="line">    <span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(<span class="number">_</span> webView: WKWebView, runJavaScriptConfirmPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping <span class="params">(Bool)</span></span></span> -&gt; <span class="type">Swift</span>.<span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  web界面中有弹出输入框时调用</span></span><br><span class="line"><span class="comment"> *  @param webView           实现该代理的webview</span></span><br><span class="line"><span class="comment"> *  @param message           输入框中的内容</span></span><br><span class="line"><span class="comment"> *  @param frame             主窗口</span></span><br><span class="line"><span class="comment"> *  @param completionHandler 输入框消失调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</span><br><span class="line">    <span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(<span class="number">_</span> webView: WKWebView, runJavaScriptTextInputPanelWithPrompt prompt: String, defaultText: String?, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping <span class="params">(String?)</span></span></span> -&gt; <span class="type">Swift</span>.<span class="type">Void</span>)</span><br></pre></td></tr></table></figure><blockquote><p>WKScriptMessageHandler</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</span><br><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">userContentController</span><span class="params">(<span class="number">_</span> userContentController: WKUserContentController, didReceive message: WKScriptMessage)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>这个方法是WKscriptMessageHandler协议中必须实现的方法，是提高App与web端交互的关键，它可以直接将接收到的JS脚本转为OC或Swift对象<br>获取网页标题<br>需要遵守WKNavigationDelegate协议并设置：webview.navigationDelegate = self<br>网页加载完的时候我们能获取网页的标题，所以这个步骤应该写在网页状态加载完成的方法里面：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(webView: WKWebView, didFinishNavigation navigation: WKNavigation!)</span></span> &#123;</span><br><span class="line">   <span class="comment">//print(self.webview.title) </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>获取当前网页的url</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(webView: WKWebView, decidePolicyForNavigationAction navigationAction:WKNavigationAction, decisionHandler: <span class="params">(WKNavigationActionPolicy)</span></span></span> -&gt;<span class="type">Void</span>) &#123;</span><br><span class="line">         </span><br><span class="line"><span class="keyword">var</span> urlString:<span class="type">NSString</span>! = navigationAction.request.<span class="type">URL</span>?.absoluteString</span><br><span class="line"></span><br><span class="line">decisionHandler(<span class="type">WKNavigationActionPolicy</span>.<span class="type">Allow</span>)<span class="comment">//一定要加上这一句代码不然会出异常          </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>前进，后退，停止。。。<br>WKWebView想UIWebView一样，可以获取一些状态，以及进行对应操作</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">reload</span><span class="params">()</span></span><span class="comment">//重新加载</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">stopLoading</span><span class="params">()</span></span><span class="comment">//停止加载</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">goBack</span><span class="params">()</span></span><span class="comment">//返回</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">goForward</span><span class="params">()</span></span><span class="comment">//前进</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//能不能后退 前往 加载</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">var</span> canGoBack: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">var</span> canGoForward: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">var</span> isLoading: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UIWebView/WKWebView </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UIImageView</title>
      <link href="/2017/12/07/Swift/Swift/UIKit/UIImageView/"/>
      <url>/2017/12/07/Swift/Swift/UIKit/UIImageView/</url>
      <content type="html"><![CDATA[<h1 id="UIImageView"><a href="#UIImageView" class="headerlink" title="UIImageView"></a>UIImageView</h1><h2 id="创建的时候直接设置图片"><a href="#创建的时候直接设置图片" class="headerlink" title="创建的时候直接设置图片"></a>创建的时候直接设置图片</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> imageView = <span class="type">UIImageView</span>(image:<span class="type">UIImage</span>(named:<span class="string">"girl"</span>))</span><br></pre></td></tr></table></figure><h2 id="先创建出对象再设置图片"><a href="#先创建出对象再设置图片" class="headerlink" title="先创建出对象再设置图片"></a>先创建出对象再设置图片</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> imageView1 = <span class="type">UIImageView</span>()</span><br><span class="line">imageView1.image = <span class="type">UIImage</span>(named:<span class="string">"girl"</span>)</span><br></pre></td></tr></table></figure><h2 id="图片获取"><a href="#图片获取" class="headerlink" title="图片获取"></a>图片获取</h2><blockquote><p>从文件目录中获取图片</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> path = <span class="type">Bundle</span>.main.path(forResource:<span class="string">"girl"</span>, ofType: <span class="string">"png"</span>)</span><br><span class="line"><span class="keyword">let</span> newImage = <span class="type">UIImage</span>(contentsOfFile: path!)</span><br></pre></td></tr></table></figure><blockquote><p>网络地址获取图片</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string:<span class="string">"http://image.cnpp.cn/upload/images/20160905/09380421552_400x300.jpg"</span>)</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">try</span>! <span class="type">Data</span>(contentsOf: url!)</span><br><span class="line"><span class="keyword">let</span> smallImage = <span class="type">UIImage</span>(data: data)</span><br><span class="line"><span class="comment">//imageView1.image = smallImage</span></span><br><span class="line"><span class="keyword">let</span> imageView1 = <span class="type">UIImageView</span>(image:smallImage)</span><br></pre></td></tr></table></figure><h2 id="图片显示填充样式"><a href="#图片显示填充样式" class="headerlink" title="图片显示填充样式"></a>图片显示填充样式</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">imageView1.contentMode = <span class="type">UIViewContentMode</span>.scaleAspectFit</span><br></pre></td></tr></table></figure><h2 id="对于UIImageView的图片填充样式有多种"><a href="#对于UIImageView的图片填充样式有多种" class="headerlink" title="对于UIImageView的图片填充样式有多种"></a>对于UIImageView的图片填充样式有多种</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">UIViewContentMode</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> scaleToFill</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> scaleAspectFit <span class="comment">// contents scaled to fit with fixed aspect. remainder is transparent</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> scaleAspectFill <span class="comment">// contents scaled to fill with fixed aspect. some portion of content may be clipped.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> redraw <span class="comment">// redraw on bounds change (calls -setNeedsDisplay)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> center <span class="comment">// contents remain same size. positioned adjusted.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> top</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> bottom</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">left</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">right</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> topLeft</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> topRight</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> bottomLeft</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> bottomRight</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分组图片轮展"><a href="#分组图片轮展" class="headerlink" title="分组图片轮展"></a>分组图片轮展</h2><blockquote><p>UIImageView中有设置多张图片一块展示的功能，类似于幻灯片的自动播放。其实现过程如下：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//设置图片数组</span></span><br><span class="line">imageView1.animationImages = [<span class="type">UIImage</span>(named:<span class="string">"2"</span>)!,<span class="type">UIImage</span>(named:<span class="string">"3"</span>)!]</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有图片展示完一遍的总时长</span></span><br><span class="line">imageView1.animationDuration = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始</span></span><br><span class="line">imageView1.startAnimating()</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束</span></span><br><span class="line">imageView1.stopAnimating()</span><br></pre></td></tr></table></figure><h2 id="添加点击事件"><a href="#添加点击事件" class="headerlink" title="添加点击事件"></a>添加点击事件</h2><blockquote><p>UIImageView和UILabel类似，其用户交互默认关闭，我们要给其添加点击事件，需要打开其用户交互</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  imageView1.isUserInteractionEnabled = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tapGestureRecognizer = <span class="type">UITapGestureRecognizer</span>(target: <span class="keyword">self</span>, action:#selector(<span class="type">ViewController</span>.tapGestureRecognizer(sender:)))</span><br><span class="line"></span><br><span class="line">imageView1.addGestureRecognizer(tapGestureRecognizer)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tapGestureRecognizer</span><span class="params">(sender:UITapGestureRecognizer)</span></span> &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//边框设置</span></span><br><span class="line">imageView.layer.borderColor = <span class="type">UIColor</span>.redColor().<span class="type">CGColor</span></span><br><span class="line">imageView.layer.borderWidth = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//圆角的设置</span></span><br><span class="line">imageView.layer.cornerRadius = <span class="number">150</span></span><br><span class="line">imageView.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="type">UIImageView</span>继承<span class="type">UIView</span>，很多常见的属性在此就不列举。。</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UIImageView </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UIImageView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UISegmentedControl-分段选择控件</title>
      <link href="/2017/12/07/Swift/Swift/UIKit/UISegmentedControl-%E5%88%86%E6%AE%B5%E9%80%89%E6%8B%A9%E6%8E%A7%E4%BB%B6/"/>
      <url>/2017/12/07/Swift/Swift/UIKit/UISegmentedControl-%E5%88%86%E6%AE%B5%E9%80%89%E6%8B%A9%E6%8E%A7%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h1 id="UISegmentedControl"><a href="#UISegmentedControl" class="headerlink" title="UISegmentedControl"></a>UISegmentedControl</h1><blockquote><p>继承自UIControl</p></blockquote><h2 id="分段选项显示"><a href="#分段选项显示" class="headerlink" title="分段选项显示"></a>分段选项显示</h2><p>###初始化数据源</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> items = [<span class="string">"见哥1"</span>,<span class="string">"见哥2"</span>,<span class="type">UIImage</span>(named:<span class="string">"1"</span>)!] <span class="keyword">as</span> [<span class="type">Any</span>]</span><br></pre></td></tr></table></figure><h3 id="初始化对象"><a href="#初始化对象" class="headerlink" title="初始化对象"></a>初始化对象</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> segmentedControl = <span class="type">UISegmentedControl</span>(items:items)</span><br></pre></td></tr></table></figure><h3 id="设置位置"><a href="#设置位置" class="headerlink" title="设置位置"></a>设置位置</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">segmentedControl.center = <span class="keyword">self</span>.view.center</span><br></pre></td></tr></table></figure><h3 id="当前选中下标"><a href="#当前选中下标" class="headerlink" title="当前选中下标"></a>当前选中下标</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">segmentedControl.selectedSegmentIndex = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>##添加事件</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">segmentedControl.addTarget(<span class="keyword">self</span>, action: #selector(segmentedControlChanged), <span class="keyword">for</span>: <span class="type">UIControlEvents</span>.valueChanged)</span><br></pre></td></tr></table></figure><h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.view.addSubview(segmentedControl)</span><br></pre></td></tr></table></figure><h2 id="选择点击后的事件"><a href="#选择点击后的事件" class="headerlink" title="选择点击后的事件"></a>选择点击后的事件</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">segmentedControlChanged</span><span class="params">(sender:UISegmentedControl)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(sender.selectedSegmentIndex)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(sender.titleForSegment(at: sender.selectedSegmentIndex))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加删除选项"><a href="#添加删除选项" class="headerlink" title="添加删除选项"></a>添加删除选项</h2><blockquote><p>UISegmentedControl每个选项的宽度在默认情况下会根据选项的个数自动分配，而个数在初始化控件之后可以添加和删除</p></blockquote><h3 id="添加图片选项"><a href="#添加图片选项" class="headerlink" title="添加图片选项"></a>添加图片选项</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">segmentedControl.insertSegment(with: <span class="type">UIImage</span>(named:<span class="string">"2"</span>), at: <span class="number">0</span>, animated: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h3 id="添加文字选项"><a href="#添加文字选项" class="headerlink" title="添加文字选项"></a>添加文字选项</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">segmentedControl.insertSegment(withTitle: <span class="string">"见哥0"</span>, at: <span class="number">1</span>, animated: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h3 id="移除制定下标的选项"><a href="#移除制定下标的选项" class="headerlink" title="移除制定下标的选项"></a>移除制定下标的选项</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">segmentedControl.removeSegment(at: <span class="number">1</span>, animated: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h3 id="移出所有segment"><a href="#移出所有segment" class="headerlink" title="移出所有segment"></a>移出所有segment</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">segment.removeAllSegments()</span><br></pre></td></tr></table></figure><h3 id="颜色设定"><a href="#颜色设定" class="headerlink" title="颜色设定"></a>颜色设定</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">segmentedControl.tintColor = <span class="type">UIColor</span>.red</span><br></pre></td></tr></table></figure><h3 id="获取颜色"><a href="#获取颜色" class="headerlink" title="获取颜色"></a>获取颜色</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> segmentColor = segment.tintColor</span><br></pre></td></tr></table></figure><h3 id="显示文字修改"><a href="#显示文字修改" class="headerlink" title="显示文字修改"></a>显示文字修改</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">segmented.setTitle(<span class="string">"swfit"</span>, forSegmentAt:<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="获取某一个下标下的标题"><a href="#获取某一个下标下的标题" class="headerlink" title="获取某一个下标下的标题"></a>获取某一个下标下的标题</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> title = segment.titleForSegmentAtIndex(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="修改选项图片"><a href="#修改选项图片" class="headerlink" title="修改选项图片"></a>修改选项图片</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">segmented.setImage(<span class="type">UIImage</span>(named:<span class="string">"icon"</span>), forSegmentAt:<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="获取某一个下标下得图片"><a href="#获取某一个下标下得图片" class="headerlink" title="获取某一个下标下得图片"></a>获取某一个下标下得图片</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> image = segment.imageForSegmentAtIndex(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="修改选项内容偏移位置"><a href="#修改选项内容偏移位置" class="headerlink" title="修改选项内容偏移位置"></a>修改选项内容偏移位置</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">segmented.setContentOffset(<span class="type">CGSize</span>(width:<span class="number">10</span>, height:<span class="number">7</span>), forSegmentAt:<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="宽度"><a href="#宽度" class="headerlink" title="宽度"></a>宽度</h2><blockquote><p>UISegmentedControl每个选项的宽度在默认情况下会根据选项的个数自动分配，但是有时候根据项目情况的需要，我们也是可以手动来进行设置/获取的。</p></blockquote><h3 id="设置指定下标选项的宽度"><a href="#设置指定下标选项的宽度" class="headerlink" title="设置指定下标选项的宽度"></a>设置指定下标选项的宽度</h3><p>segmentedControl.setWidth(10, forSegmentAt: 1)</p><h3 id="获取某一个下标segment的宽度"><a href="#获取某一个下标segment的宽度" class="headerlink" title="获取某一个下标segment的宽度"></a>获取某一个下标segment的宽度</h3><p>var width = segment.widthForSegmentAtIndex(2)</p><h3 id="是否根据segment的内容改变segment的宽度"><a href="#是否根据segment的内容改变segment的宽度" class="headerlink" title="是否根据segment的内容改变segment的宽度"></a>是否根据segment的内容改变segment的宽度</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">segment.apportionsSegmentWidthsByContent = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>###momentary属性</p><blockquote><p>分段选择控件在点击之后一直处于选中状态，除非点击其他分段，才恢复。 momentary属性用来设置是否一直保持选中状态，当设置为YES时，点击选中，但一会就是恢复到正常状态<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">segment.momentary = <span class="literal">true</span></span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UISegmentedControl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UISegmentedControl </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UISwitch</title>
      <link href="/2017/12/07/Swift/Swift/UIKit/UISwitch/"/>
      <url>/2017/12/07/Swift/Swift/UIKit/UISwitch/</url>
      <content type="html"><![CDATA[<h1 id="UISwitch"><a href="#UISwitch" class="headerlink" title="UISwitch"></a>UISwitch</h1><blockquote><p>继承自UIControl</p></blockquote><h2 id="UISwitch的大小是确定的不能进行修改-51-31"><a href="#UISwitch的大小是确定的不能进行修改-51-31" class="headerlink" title="UISwitch的大小是确定的不能进行修改 51*31"></a>UISwitch的大小是确定的不能进行修改 51*31</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> switchOne = <span class="type">UISwitch</span>(frame:<span class="type">CGRect</span>(x:<span class="number">10.0</span>, y:<span class="number">100.0</span>, width:<span class="number">0.0</span>,height: <span class="number">0.0</span>))</span><br><span class="line"><span class="keyword">self</span>.view.addSubview(switchOne)</span><br><span class="line">switchOne.backgroundColor = <span class="type">UIColor</span> .yellow;</span><br></pre></td></tr></table></figure><h2 id="设置打开状态背景颜色"><a href="#设置打开状态背景颜色" class="headerlink" title="设置打开状态背景颜色"></a>设置打开状态背景颜色</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">switchOne.onTintColor = <span class="type">UIColor</span>.brown</span><br></pre></td></tr></table></figure><h2 id="设置关闭状态的背景颜色"><a href="#设置关闭状态的背景颜色" class="headerlink" title="设置关闭状态的背景颜色"></a>设置关闭状态的背景颜色</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">switchOne.tintColor = <span class="type">UIColor</span>.orange</span><br></pre></td></tr></table></figure><h2 id="开关快的颜色"><a href="#开关快的颜色" class="headerlink" title="开关快的颜色"></a>开关快的颜色</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">switchOne.thumbTintColor = <span class="type">UIColor</span>.red</span><br></pre></td></tr></table></figure><h2 id="设置开关状态"><a href="#设置开关状态" class="headerlink" title="设置开关状态"></a>设置开关状态</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">switchOne.setOn(<span class="literal">true</span>, animated: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h2 id="添加按钮事件"><a href="#添加按钮事件" class="headerlink" title="添加按钮事件"></a>添加按钮事件</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">switchOne.addTarget(<span class="keyword">self</span>, action: #selector(<span class="type">ViewController</span>.switchOneValueChanged(sender:)), <span class="keyword">for</span>: <span class="type">UIControlEvents</span>.valueChanged)</span><br></pre></td></tr></table></figure><h2 id="状态改变之后的执行方法"><a href="#状态改变之后的执行方法" class="headerlink" title="状态改变之后的执行方法"></a>状态改变之后的执行方法</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchOneValueChanged</span><span class="params">(sender:UISwitch)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"我是一个帅哥，你信不？value=%d"</span>,sender.isOn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switchOne.onImage = <span class="type">UIImage</span>(named:<span class="string">"1"</span>)</span><br><span class="line">switchOne.offImage = <span class="type">UIImage</span>(named:<span class="string">"2"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UISwitch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UISwitch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UIStepper</title>
      <link href="/2017/12/07/Swift/Swift/UIKit/UIStepper/"/>
      <url>/2017/12/07/Swift/Swift/UIKit/UIStepper/</url>
      <content type="html"><![CDATA[<h1 id="UIStepper"><a href="#UIStepper" class="headerlink" title="UIStepper"></a>UIStepper</h1><h2 id="创建-frame"><a href="#创建-frame" class="headerlink" title="创建+frame"></a>创建+frame</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stepper = <span class="type">UIStepper</span>()</span><br><span class="line">stepper.center = <span class="keyword">self</span>.view.center</span><br></pre></td></tr></table></figure><h2 id="设置最大和最小值"><a href="#设置最大和最小值" class="headerlink" title="设置最大和最小值"></a>设置最大和最小值</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">stepper.maximumValue = <span class="number">10</span></span><br><span class="line">stepper.minimumValue = <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="当前值"><a href="#当前值" class="headerlink" title="当前值"></a>当前值</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">stepper.value = <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="每次变化的单位"><a href="#每次变化的单位" class="headerlink" title="每次变化的单位"></a>每次变化的单位</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">stepper.stepValue = <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="按住的时候连续变化"><a href="#按住的时候连续变化" class="headerlink" title="按住的时候连续变化"></a>按住的时候连续变化</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">stepper.isContinuous = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="是否循环-当增长到最大值的时候再从新开始"><a href="#是否循环-当增长到最大值的时候再从新开始" class="headerlink" title="是否循环 当增长到最大值的时候再从新开始"></a>是否循环 当增长到最大值的时候再从新开始</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">stepper.wraps = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="改变事件添加"><a href="#改变事件添加" class="headerlink" title="改变事件添加"></a>改变事件添加</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">stepper.addTarget(<span class="keyword">self</span>, action:#selector(<span class="type">ViewController</span>.stepperChanged(stepper:)), <span class="keyword">for</span>: <span class="type">UIControlEvents</span>.valueChanged)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stepperChanged</span><span class="params">(stepper:UIStepper)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"我是一个帅哥，你信不？value=%d"</span>,stepper.value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">self</span>.view.addSubview(stepper)</span><br></pre></td></tr></table></figure><h2 id="设置颜色"><a href="#设置颜色" class="headerlink" title="设置颜色"></a>设置颜色</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">stepper.tintColor = <span class="type">UIColor</span>.green</span><br></pre></td></tr></table></figure><h2 id="设置img"><a href="#设置img" class="headerlink" title="设置img"></a>设置img</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">stepper.setDecrementImage(<span class="type">UIImage</span>(named:<span class="string">"1"</span>), <span class="keyword">for</span>: .normal)</span><br><span class="line">stepper.setIncrementImage(<span class="type">UIImage</span>(named:<span class="string">"1"</span>), <span class="keyword">for</span>: .normal)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UIStepper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UIStepper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift—UIKit-UISlider</title>
      <link href="/2017/12/07/Swift/Swift/UIKit/UISlider/"/>
      <url>/2017/12/07/Swift/Swift/UIKit/UISlider/</url>
      <content type="html"><![CDATA[<h1 id="UISlider"><a href="#UISlider" class="headerlink" title="UISlider"></a>UISlider</h1><h2 id="创建-frame"><a href="#创建-frame" class="headerlink" title="创建+frame"></a>创建+frame</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> slider = <span class="type">UISlider</span>()</span><br><span class="line">slider.frame = <span class="type">CGRect</span>(x: <span class="number">50</span>, y: <span class="number">100</span>, width: <span class="number">200</span>, height: <span class="number">50</span>)</span><br></pre></td></tr></table></figure><p>##最小/大值</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">slider.minimumValue = <span class="number">0</span></span><br><span class="line">slider.maximumValue = <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="当前值（在取值范围之内的位置）"><a href="#当前值（在取值范围之内的位置）" class="headerlink" title="当前值（在取值范围之内的位置）"></a>当前值（在取值范围之内的位置）</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">slider.value = <span class="number">0.5</span></span><br></pre></td></tr></table></figure><p>##按钮最小/大端图片<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">slider.minimumValueImage = <span class="type">UIImage</span>(named:<span class="string">"SSS"</span>)</span><br><span class="line">slider.maximumValueImage = <span class="type">UIImage</span>(named:<span class="string">"DDD"</span>)</span><br></pre></td></tr></table></figure></p><h2 id="不同状态之下，圆点显示图片"><a href="#不同状态之下，圆点显示图片" class="headerlink" title="不同状态之下，圆点显示图片"></a>不同状态之下，圆点显示图片</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">slider.setThumbImage(<span class="type">UIImage</span>(named:<span class="string">""</span>), <span class="keyword">for</span>: .normal)</span><br><span class="line">slider.setThumbImage(<span class="type">UIImage</span>(named:<span class="string">""</span>), <span class="keyword">for</span>: .highlighted)</span><br><span class="line">slider.setThumbImage(<span class="type">UIImage</span>(named:<span class="string">""</span>), <span class="keyword">for</span>: .disabled)</span><br><span class="line">slider.setThumbImage(<span class="type">UIImage</span>(named:<span class="string">""</span>), <span class="keyword">for</span>: .selected)</span><br></pre></td></tr></table></figure><p>##设置圆点的颜色</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">slider.thumbTintColor = <span class="type">UIColor</span>.red</span><br></pre></td></tr></table></figure><h2 id="设置划过和没有划过颜色（圆点左-右）"><a href="#设置划过和没有划过颜色（圆点左-右）" class="headerlink" title="设置划过和没有划过颜色（圆点左/右）"></a>设置划过和没有划过颜色（圆点左/右）</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">slider.minimumTrackTintColor = <span class="type">UIColor</span>.yellow</span><br><span class="line">slider.maximumTrackTintColor = <span class="type">UIColor</span>.brown</span><br></pre></td></tr></table></figure><h2 id="改变事件"><a href="#改变事件" class="headerlink" title="改变事件"></a>改变事件</h2><blockquote><p>滑块滑动停止后才触发ValueChanged事件 </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">slider.isContinuous = <span class="literal">false</span></span><br><span class="line">slider.addTarget(<span class="keyword">self</span>, action: #selector(<span class="type">ViewController</span>.change(slider:)), <span class="keyword">for</span>: <span class="type">UIControlEvents</span>.valueChanged)</span><br><span class="line">slider.addTarget(<span class="keyword">self</span>, action: #selector(<span class="type">ViewController</span>.sliderDragUp(sender:)), <span class="keyword">for</span>: <span class="type">UIControlEvents</span>.touchUpInside)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(slider:UISlider)</span></span> &#123;</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">"slider.value = %d"</span>,slider.value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliderDragUp</span><span class="params">(sender: UISlider)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"value:(sender.value)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UISlider </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UISlider </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UITextField</title>
      <link href="/2017/12/07/Swift/Swift/UIKit/Swift-UIKit-UITextField/"/>
      <url>/2017/12/07/Swift/Swift/UIKit/Swift-UIKit-UITextField/</url>
      <content type="html"><![CDATA[<h1 id="文本输入框"><a href="#文本输入框" class="headerlink" title="文本输入框"></a>文本输入框</h1><blockquote><p>创建+frame</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> textField = <span class="type">UITextField</span>(frame: <span class="type">CGRect</span>(x:<span class="number">10</span>, y:<span class="number">60</span>, width:<span class="number">200</span>, height:<span class="number">30</span>))</span><br><span class="line"><span class="comment">// let textField = UITextField()</span></span><br><span class="line"><span class="comment">// textField.frame = CGRect(x:20,y:30,width:100,height:30)</span></span><br></pre></td></tr></table></figure><blockquote><p>设置边框样式为圆角矩形</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">textField.borderStyle = <span class="type">UITextBorderStyle</span>.roundedRect</span><br><span class="line"><span class="keyword">self</span>.view.addSubview(textField)</span><br></pre></td></tr></table></figure><blockquote><p>文本输入框的边框样式</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">UITextBorderStyle</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">none</span> 无边框</span><br><span class="line">        <span class="keyword">case</span> line 直线边框</span><br><span class="line">        <span class="keyword">case</span> bezel 圆角矩形边框</span><br><span class="line">        <span class="keyword">case</span> roundedRect 边线+阴影</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>文本输入框的提示文字</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">textField.placeholder = <span class="string">"请输入相关信息"</span></span><br></pre></td></tr></table></figure><blockquote><p>文字大小超过文本框长度时自动缩小字号，而不是隐藏显示省略号</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> textField.adjustsFontSizeToFitWidth=<span class="literal">true</span>  <span class="comment">//当文字超出文本框宽度时，自动调整文字大小</span></span><br><span class="line">textField.minimumFontSize=<span class="number">14</span>              <span class="comment">//最小可缩小的字号</span></span><br></pre></td></tr></table></figure><blockquote><p>水平/垂直对齐方式</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/** 水平对齐 **/</span></span><br><span class="line">textField.textAlignment = .<span class="keyword">right</span> <span class="comment">//水平右对齐</span></span><br><span class="line">textField.textAlignment = .center <span class="comment">//水平居中对齐</span></span><br><span class="line">textField.textAlignment = .<span class="keyword">left</span> <span class="comment">//水平左对齐</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/** 垂直对齐 **/</span></span><br><span class="line">textField.contentVerticalAlignment = .top  <span class="comment">//垂直向上对齐</span></span><br><span class="line">textField.contentVerticalAlignment = .center  <span class="comment">//垂直居中对齐</span></span><br><span class="line">textField.contentVerticalAlignment = .bottom  <span class="comment">//垂直向下对齐</span></span><br></pre></td></tr></table></figure><blockquote><p>背景图片设置</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">textField.borderStyle = .<span class="keyword">none</span> <span class="comment">//先要去除边框样式</span></span><br><span class="line">textField.background = <span class="type">UIImage</span>(named:<span class="string">"background1"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>清除按钮（输入框内右侧小叉）</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">textField.clearButtonMode = .whileEditing  <span class="comment">//编辑时出现清除按钮</span></span><br><span class="line">textField.clearButtonMode = .unlessEditing  <span class="comment">//编辑时不出现，编辑后才出现清除按钮</span></span><br><span class="line">textField.clearButtonMode = .always  <span class="comment">//一直显示清除按钮</span></span><br></pre></td></tr></table></figure><blockquote><p>键盘类型</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Default</span>：                系统默认的虚拟键盘</span><br><span class="line"><span class="type">ASCII</span> <span class="type">Capable</span>：          显示英文字母的虚拟键盘</span><br><span class="line"><span class="type">Numbers</span> and <span class="type">Punctuation</span>：显示数字和标点的虚拟键盘</span><br><span class="line"><span class="type">URL</span>：                    显示便于输入url网址的虚拟键盘</span><br><span class="line"><span class="type">Number</span> <span class="type">Pad</span>：             显示便于输入数字的虚拟键盘</span><br><span class="line"><span class="type">Phone</span> <span class="type">Pad</span>：              显示便于拨号呼叫的虚拟键盘</span><br><span class="line"><span class="type">Name</span> <span class="type">Phone</span> <span class="type">Pad</span>：         显示便于聊天拨号的虚拟键盘</span><br><span class="line"><span class="type">Email</span> <span class="type">Address</span>：          显示便于输入<span class="type">Email</span>的虚拟键盘</span><br><span class="line"><span class="type">Decimal</span> <span class="type">Pad</span>：            显示用于输入数字和小数点的虚拟键盘</span><br><span class="line"><span class="type">Twitter</span>：                显示方便些<span class="type">Twitter</span>的虚拟键盘</span><br><span class="line"><span class="type">Web</span> <span class="type">Search</span>：             显示便于在网页上书写的虚拟键盘</span><br></pre></td></tr></table></figure><blockquote><p>设置文本框关联的键盘</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">textField.keyboardType = <span class="type">UIKeyboardType</span>.numberPad</span><br></pre></td></tr></table></figure><blockquote><p>使文本框失去焦点，并收回键盘</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">textField.resignFirstResponder()</span><br></pre></td></tr></table></figure><blockquote><p>设置键盘return键的样式</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> extField.returnKeyType = <span class="type">UIReturnKeyType</span>.done     <span class="comment">//表示完成输入</span></span><br><span class="line">textField.returnKeyType = <span class="type">UIReturnKeyType</span>.go      <span class="comment">//表示完成输入，同时会跳到另一页</span></span><br><span class="line">textField.returnKeyType = <span class="type">UIReturnKeyType</span>.search  <span class="comment">//表示搜索</span></span><br><span class="line">textField.returnKeyType = <span class="type">UIReturnKeyType</span>.<span class="built_in">join</span>    <span class="comment">//表示注册用户或添加数据</span></span><br><span class="line">textField.returnKeyType = <span class="type">UIReturnKeyType</span>.next    <span class="comment">//表示继续下一步</span></span><br><span class="line">textField.returnKeyType = <span class="type">UIReturnKeyType</span>.send    <span class="comment">//表示发送</span></span><br></pre></td></tr></table></figure><blockquote><p>键盘return键的响应</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> UIKit</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>,<span class="title">UITextFieldDelegate</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">let</span> textField = <span class="type">UITextField</span>(frame: <span class="type">CGRect</span>(x:<span class="number">10</span>,y:<span class="number">160</span>,width:<span class="number">200</span>,height:<span class="number">30</span>))</span><br><span class="line">        <span class="comment">//设置边框样式为圆角矩形</span></span><br><span class="line">        textField.borderStyle = <span class="type">UITextBorderStyle</span>.roundedRect</span><br><span class="line">        textField.returnKeyType = <span class="type">UIReturnKeyType</span>.done</span><br><span class="line">        textField.delegate=<span class="keyword">self</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(textField)</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">textFieldShouldReturn</span><span class="params">(<span class="number">_</span> textField: UITextField)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="comment">//收起键盘</span></span><br><span class="line">        textField.resignFirstResponder()</span><br><span class="line">        <span class="comment">//打印出文本框中的值</span></span><br><span class="line">        <span class="built_in">print</span>(textField.text)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输入/显示文本字体的颜色</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">textField.textColor = <span class="type">UIColor</span>.cyan</span><br></pre></td></tr></table></figure><blockquote><p>文本框的字体大小设置</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//text.font = [UIFont fontWithName:@"Arial" size:20.0f];   //设置输入框内容的字体样式和大小</span></span><br><span class="line">textField.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">14</span>)</span><br></pre></td></tr></table></figure><blockquote><p>文本输入框的代理设置（遵守UITextFieldDelegate协议）</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>,<span class="title">UITextFieldDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">textField.delegate = <span class="keyword">self</span></span><br></pre></td></tr></table></figure><blockquote><p>输入框的背景颜色</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">text.backgroundColor = [<span class="type">UIColor</span> whiteColor]<span class="comment">//设置输入框的背景颜色，此时设置为白色 如果使用了自定义的背景图片边框会被忽略掉 ~~~</span></span><br></pre></td></tr></table></figure><blockquote><p>输入框中一开始就有的文字</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">text.text = @<span class="string">"文字"</span>;</span><br></pre></td></tr></table></figure><blockquote><p>是否自动纠错</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> text.autocorrectionType = <span class="type">UITextAutocorrectionTypeNo</span></span><br><span class="line"> 几种选择样式</span><br><span class="line">typedef <span class="class"><span class="keyword">enum</span> </span>&#123;</span><br><span class="line"><span class="type">UITextAutocorrectionTypeDefault</span>, 默认</span><br><span class="line"><span class="type">UITextAutocorrectionTypeNo</span>, 不自动纠错</span><br><span class="line"><span class="type">UITextAutocorrectionTypeYes</span>, 自动纠错</span><br><span class="line">&#125; <span class="type">UITextAutocorrectionType</span>;</span><br></pre></td></tr></table></figure><blockquote><p>再次编辑就清空</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">text.clearsOnBeginEditing = <span class="type">YES</span></span><br></pre></td></tr></table></figure><blockquote><p>首字母是否自动大</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> text.autocapitalizationType = <span class="type">UITextAutocapitalizationTypeNone</span>;</span><br><span class="line">typedef <span class="class"><span class="keyword">enum</span> </span>&#123;</span><br><span class="line"><span class="type">UITextAutocapitalizationTypeNone</span>, 不自动大写</span><br><span class="line"><span class="type">UITextAutocapitalizationTypeWords</span>, 单词首字母大写</span><br><span class="line"><span class="type">UITextAutocapitalizationTypeSentences</span>, 句子的首字母大写</span><br><span class="line"><span class="type">UITextAutocapitalizationTypeAllCharacters</span>, 所有字母都大写</span><br><span class="line">&#125; <span class="type">UITextAutocapitalizationType</span>;</span><br></pre></td></tr></table></figure><blockquote><p>键盘外观</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> textView.keyboardAppearance=<span class="type">UIKeyboardAppearanceDefault</span></span><br><span class="line"> </span><br><span class="line">typedef <span class="class"><span class="keyword">enum</span> </span>&#123;</span><br><span class="line"><span class="type">UIKeyboardAppearanceDefault</span>， 默认外观，浅灰色</span><br><span class="line"><span class="type">UIKeyboardAppearanceAlert</span>， 深灰 石墨色</span><br><span class="line">&#125; <span class="type">UIReturnKeyType</span>;</span><br></pre></td></tr></table></figure><blockquote><p>最右侧加图片是以下代码（左侧类似）</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="type">UIImageView</span> *image=[[<span class="type">UIImageView</span> alloc] initWithImage:[<span class="type">UIImage</span> imageNamed:@<span class="string">"right.png"</span>]] <span class="comment">//</span></span><br><span class="line">text.rightView=image;</span><br><span class="line">text.rightViewMode = <span class="type">UITextFieldViewModeAlways</span></span><br><span class="line"></span><br><span class="line">typedef <span class="class"><span class="keyword">enum</span> </span>&#123;</span><br><span class="line"><span class="type">UITextFieldViewModeNever</span>,</span><br><span class="line"><span class="type">UITextFieldViewModeWhileEditing</span>,</span><br><span class="line"><span class="type">UITextFieldViewModeUnlessEditing</span>,</span><br><span class="line"><span class="type">UITextFieldViewModeAlways</span></span><br><span class="line">&#125; <span class="type">UITextFieldViewMode</span>;</span><br></pre></td></tr></table></figure><blockquote><p>重写绘制行为<br>除了UITextField对象的风格选项，你还可以定制化UITextField对象，为他添加许多不同的重写方法，来改变文本字段的显示行为。这些方法都会返回一个CGRect结构，制定了文本字段每个部件的边界范围。以下方法都可以重写</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> – textRectForBounds:　　 <span class="comment">//重写来重置文字区域</span></span><br><span class="line">– drawTextInRect:　　 <span class="comment">//改变绘文字属性.重写时调用super可以按默认图形属性绘制,若自己完全重写绘制函数，就不用调用super了.</span></span><br><span class="line">– placeholderRectForBounds:　　<span class="comment">//重写来重置占位符区域</span></span><br><span class="line">– drawPlaceholderInRect:　　<span class="comment">//重写改变绘制占位符属性.重写时调用super可以按默认图形属性绘制,若自己完全重写绘制函数，就不用调用super了.</span></span><br><span class="line">– borderRectForBounds:　　<span class="comment">//重写来重置边缘区域</span></span><br><span class="line">– editingRectForBounds:　　<span class="comment">//重写来重置编辑区域</span></span><br><span class="line">– clearButtonRectForBounds:　　<span class="comment">//重写来重置clearButton位置,改变size可能导致button的图片失真</span></span><br><span class="line">– leftViewRectForBounds:</span><br><span class="line">– rightViewRectForBounds:</span><br></pre></td></tr></table></figure><blockquote><p>委托方法</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> (<span class="type">BOOL</span>)textFieldShouldBeginEditing:(<span class="type">UITextField</span> *)textField&#123;</span><br><span class="line"><span class="comment">//返回一个BOOL值，指定是否循序文本字段开始编辑</span></span><br><span class="line"><span class="keyword">return</span> <span class="type">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line">(void)textFieldDidBeginEditing:(<span class="type">UITextField</span> *)textField&#123;</span><br><span class="line"><span class="comment">//开始编辑时触发，文本字段将成为first responder</span></span><br><span class="line">&#125;</span><br><span class="line">(<span class="type">BOOL</span>)textFieldShouldEndEditing:(<span class="type">UITextField</span> *)textField&#123;</span><br><span class="line"><span class="comment">//返回BOOL值，指定是否允许文本字段结束编辑，当编辑结束，文本字段会让出first responder</span></span><br><span class="line"><span class="comment">//要想在用户结束编辑时阻止文本字段消失，可以返回NO</span></span><br><span class="line"><span class="comment">//这对一些文本字段必须始终保持活跃状态的程序很有用，比如即时消息</span></span><br><span class="line"><span class="keyword">return</span> <span class="type">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="type">BOOL</span>)textField:(<span class="type">UITextField</span>*)textField shouldChangeCharactersInRange:(<span class="type">NSRange</span>)range replacementString:(<span class="type">NSString</span> *)string&#123;</span><br><span class="line"><span class="comment">//当用户使用自动更正功能，把输入的文字修改为推荐的文字时，就会调用这个方法。</span></span><br><span class="line"><span class="comment">//这对于想要加入撤销选项的应用程序特别有用</span></span><br><span class="line"><span class="comment">//可以跟踪字段内所做的最后一次修改，也可以对所有编辑做日志记录,用作审计用途。</span></span><br><span class="line"><span class="comment">//要防止文字被改变可以返回NO</span></span><br><span class="line"><span class="comment">//这个方法的参数中有一个NSRange对象，指明了被改变文字的位置，建议修改的文本也在其中</span></span><br><span class="line"><span class="keyword">return</span> <span class="type">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="type">BOOL</span>)textFieldShouldClear:(<span class="type">UITextField</span> *)textField&#123;</span><br><span class="line"><span class="comment">//返回一个BOOL值指明是否允许根据用户请求清除内容</span></span><br><span class="line"><span class="comment">//可以设置在特定条件下才允许清除内容</span></span><br><span class="line"><span class="keyword">return</span> <span class="type">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="type">BOOL</span>)textFieldShouldReturn:(<span class="type">UITextField</span> *)textField&#123;</span><br><span class="line"><span class="comment">//返回一个BOOL值，指明是否允许在按下回车键时结束编辑</span></span><br><span class="line"><span class="comment">//如果允许要调用resignFirstResponder 方法，这回导致结束编辑，而键盘会被收起[textField resignFirstResponder];</span></span><br><span class="line"><span class="comment">//查一下resign这个单词的意思就明白这个方法了</span></span><br><span class="line"><span class="keyword">return</span> <span class="type">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通知</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="type">UITextField</span>派生自<span class="type">UIControl</span>，所以<span class="type">UIControl</span>类中的通知系统在文本字段中也可以使用。除了<span class="type">UIControl</span>类的标准事件，你还可以使用下列<span class="type">UITextField</span>类特有的事件</span><br><span class="line"><span class="type">UITextFieldTextDidBeginEditingNotification</span></span><br><span class="line"><span class="type">UITextFieldTextDidChangeNotification</span></span><br><span class="line"><span class="type">UITextFieldTextDidEndEditingNotification</span></span><br><span class="line">当文本字段退出编辑模式时触发。通知的object属性存储了最终文本。</span><br><span class="line">因为文本字段要使用键盘输入文字，所以下面这些事件发生时，也会发送动作通知</span><br><span class="line"><span class="type">UIKeyboardWillShowNotification</span>   <span class="comment">//键盘显示之前发送</span></span><br><span class="line"><span class="type">UIKeyboardDidShowNotification</span>    <span class="comment">//键盘显示之后发送</span></span><br><span class="line"><span class="type">UIKeyboardWillHideNotification</span>   <span class="comment">//键盘隐藏之前发送</span></span><br><span class="line"><span class="type">UIKeyboardDidHideNotification</span>    <span class="comment">//键盘隐藏之后发送</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加通知方法</span></span><br><span class="line"><span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(<span class="keyword">self</span>, selector: <span class="type">Selector</span>(<span class="string">"textFiledEditChanged:"</span>), name: <span class="type">UITextFieldTextDidChangeNotification</span>, object: textfield)</span><br></pre></td></tr></table></figure><blockquote><p>限制只能输入特定的字符</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> -(<span class="type">BOOL</span>)textField:(<span class="type">UITextField</span> *)textField shouldChangeCharactersInRange:(<span class="type">NSRange</span>)range replacementString:(<span class="type">NSString</span> *)string&#123;</span><br><span class="line"><span class="type">NSCharacterSet</span> *cs;</span><br><span class="line">cs = [[<span class="type">NSCharacterSet</span> characterSetWithCharactersInString:<span class="type">NUMBERS</span>]invertedSet];</span><br><span class="line"><span class="type">NSString</span> *filtered = [[string componentsSeparatedByCharactersInSet:cs]componentsJoinedByString:@<span class="string">""</span>];<span class="comment">//按cs分离出数组,数组按@""分离出字符串</span></span><br><span class="line"><span class="type">BOOL</span> canChange = [string isEqualToString:filtered];</span><br><span class="line"><span class="keyword">return</span> canChange;</span><br><span class="line">&#125;</span><br><span class="line">上面这个<span class="type">NUMBERS</span>是一个宏，可以在文件顶部定义：</span><br><span class="line">define <span class="type">NUMBERS</span> @”<span class="number">0123456789</span>\n”</span><br><span class="line">如果你要限制输入英文和数字的话，就可以把这个定义为：</span><br><span class="line">define kAlphaNum @”<span class="type">ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789</span>″</span><br></pre></td></tr></table></figure><blockquote><p>限制只能输入一定长度的字符</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> (<span class="type">BOOL</span>)textField:(<span class="type">UITextField</span> *)textField shouldChangeCharactersInRange:(<span class="type">NSRange</span>)range replacementString:(<span class="type">NSString</span> *)string;</span><br><span class="line">&#123; <span class="comment">//string就是此时输入的那个字符 textField就是此时正在输入的那个输入框 返回YES就是可以改变输入框的值 NO相反</span></span><br><span class="line"><span class="keyword">if</span> ([string isEqualToString:@<span class="string">"\n"</span>]) <span class="comment">//按会车可以改变</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">NSString</span> * toBeString = [textField.text stringByReplacingCharactersInRange:range withString:string];<span class="comment">//得到输入框的内容</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.myTextField == textField) <span class="comment">//判断是否时我们想要限定的那个输入框</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ([toBeString length] &gt; <span class="number">20</span>) &#123; <span class="comment">//如果输入框内容大于20则弹出警告</span></span><br><span class="line">textField.text = [toBeString substringToIndex:<span class="number">20</span>];</span><br><span class="line"><span class="type">UIAlertView</span> *alert = [[[<span class="type">UIAlertView</span> alloc] initWithTitle:<span class="literal">nil</span> message:@<span class="string">"超过最大字数不能输入了"</span> delegate:<span class="literal">nil</span> cancelButtonTitle:@<span class="string">"Ok"</span> otherButtonTitles:<span class="literal">nil</span>, <span class="literal">nil</span>] autorelease];</span><br><span class="line">[alert show];</span><br><span class="line"><span class="keyword">return</span> <span class="type">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="type">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置能不能进行编辑/用户交互的开关</span></span><br><span class="line">textfield.enabled = <span class="literal">true</span></span><br><span class="line">textfield.userInteractionEnabled = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置圆角属性</span></span><br><span class="line">textField.layer.cornerRadius = <span class="number">10.0</span></span><br><span class="line">textField.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义输入源控件</span></span><br><span class="line"><span class="keyword">let</span> inputview = <span class="type">UIButton</span>(frame: <span class="type">CGRectMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="type">CGRectGetWidth</span>(<span class="keyword">self</span>.view.bounds), <span class="number">100.0</span>))</span><br><span class="line">inputview.setImage(<span class="type">UIImage</span>(named: <span class="string">"normalImage"</span>), forState: <span class="type">UIControlState</span>.<span class="type">Normal</span>)</span><br><span class="line">inputview.backgroundColor = <span class="type">UIColor</span>.lightGrayColor()</span><br><span class="line">inputview.addTarget(<span class="keyword">self</span>, action: <span class="type">Selector</span>(<span class="string">"click:"</span>), forControlEvents: <span class="type">UIControlEvents</span>.<span class="type">TouchUpInside</span>)</span><br><span class="line">textfield.inputView = inputview</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义输入源控件副视图</span></span><br><span class="line"><span class="keyword">let</span> accessoryview = <span class="type">UIView</span>(frame: <span class="type">CGRectMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="type">CGRectGetWidth</span>(<span class="keyword">self</span>.view.bounds), <span class="number">40.0</span>))</span><br><span class="line">accessoryview.backgroundColor = <span class="type">UIColor</span>.greenColor()</span><br><span class="line"><span class="keyword">let</span> accessoryLeft = <span class="type">UIButton</span>(frame: <span class="type">CGRectMake</span>(<span class="number">10.0</span>, <span class="number">10.0</span>, <span class="number">60.0</span>, <span class="number">20.0</span>))</span><br><span class="line">accessoryview.addSubview(accessoryLeft)</span><br><span class="line">accessoryLeft.setTitle(<span class="string">"取消"</span>, forState: <span class="type">UIControlState</span>.<span class="type">Normal</span>)</span><br><span class="line">accessoryLeft.backgroundColor = <span class="type">UIColor</span>.orangeColor()</span><br><span class="line">accessoryLeft.addTarget(<span class="keyword">self</span>, action: <span class="type">Selector</span>(<span class="string">"leftClick:"</span>), forControlEvents: <span class="type">UIControlEvents</span>.<span class="type">TouchUpInside</span>)</span><br><span class="line"><span class="keyword">let</span> accessoryRight = <span class="type">UIButton</span>(frame: <span class="type">CGRectMake</span>((<span class="type">CGRectGetWidth</span>(accessoryview.bounds) - <span class="number">10.0</span> - <span class="number">60.0</span>), <span class="number">10.0</span>, <span class="number">60.0</span>, <span class="number">20.0</span>))</span><br><span class="line">accessoryview.addSubview(accessoryRight)</span><br><span class="line">accessoryRight.setTitle(<span class="string">"确定"</span>, forState: <span class="type">UIControlState</span>.<span class="type">Normal</span>)</span><br><span class="line">accessoryRight.backgroundColor = <span class="type">UIColor</span>.orangeColor()</span><br><span class="line">accessoryRight.addTarget(<span class="keyword">self</span>, action: <span class="type">Selector</span>(<span class="string">"rightClick:"</span>), forControlEvents: <span class="type">UIControlEvents</span>.<span class="type">TouchUpInside</span>)</span><br><span class="line">textfield.inputAccessoryView = accessoryview</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义输入源控件时响应事件</span></span><br><span class="line"><span class="comment">// MARK: - click</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">click</span><span class="params">(button:UIButton)</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">self</span>.view.endEditing(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MARK: - left/right click</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">leftClick</span><span class="params">(button:UIButton)</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"取消"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rightClick</span><span class="params">(button:UIButton)</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">self</span>.view.endEditing(<span class="literal">true</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"确定"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UITextField </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UITextField </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UIButton</title>
      <link href="/2017/12/06/Swift/Swift/UIKit/UIButton/"/>
      <url>/2017/12/06/Swift/Swift/UIKit/UIButton/</url>
      <content type="html"><![CDATA[<h1 id="UIButton"><a href="#UIButton" class="headerlink" title="UIButton"></a>UIButton</h1><blockquote><p>UIButton继承自UIControl</p></blockquote><h2 id="创建btn"><a href="#创建btn" class="headerlink" title="创建btn"></a>创建btn</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn: <span class="type">UIButton</span> = <span class="type">UIButton</span>()   <span class="comment">//没有样式</span></span><br><span class="line"><span class="comment">//let btns:UIButton =UIButton(type: UIButtonType)//有样式</span></span><br><span class="line"><span class="comment">//let button = UIButton(frame:CGRect(x:10, y:150, width:100, height:30))//简化创建方式</span></span><br><span class="line"><span class="keyword">self</span>.view.addSubview(button)</span><br></pre></td></tr></table></figure><h2 id="UIButtonType有以下类型"><a href="#UIButtonType有以下类型" class="headerlink" title="UIButtonType有以下类型"></a>UIButtonType有以下类型</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">UIButtonType</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> custom <span class="comment">// no button type</span></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line">    <span class="keyword">case</span> system <span class="comment">// standard system button</span></span><br><span class="line">    <span class="keyword">case</span> detailDisclosure</span><br><span class="line">    <span class="keyword">case</span> infoLight</span><br><span class="line">    <span class="keyword">case</span> infoDark</span><br><span class="line">    <span class="keyword">case</span> contactAdd</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> roundedRect: <span class="type">UIButtonType</span> &#123; <span class="keyword">get</span> &#125; <span class="comment">// Deprecated, use UIButtonTypeSystem instead</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">let</span>  btn: <span class="type">UIButton</span> = <span class="type">UIButton</span>(type: .<span class="type">Custom</span>)</span><br></pre></td></tr></table></figure><h2 id="UIButton设置字内容和颜色"><a href="#UIButton设置字内容和颜色" class="headerlink" title="UIButton设置字内容和颜色"></a>UIButton设置字内容和颜色</h2><blockquote><p>UIButton所对应的状态有几种</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     Normal          (默认状态)</span></span><br><span class="line"><span class="comment">     Highlighted    （高亮状态）点击按钮不放</span></span><br><span class="line"><span class="comment">     Disabled       （使能状态）就是是否可用状态--&gt;禁用的状态才会显现</span></span><br><span class="line"><span class="comment">     Selected       （选中状态）通过selected属性设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> /显示文字</span><br><span class="line">button1.setTitle(<span class="string">"普通状态"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">button1.setTitle(<span class="string">"高粱状态"</span>, <span class="keyword">for</span>: .highlighted)</span><br><span class="line">button1.setTitle(<span class="string">"禁用状态"</span>, <span class="keyword">for</span>: .disabled)</span><br><span class="line"><span class="comment">//显示文字颜色</span></span><br><span class="line">button1.setTitleColor(<span class="type">UIColor</span>.red, <span class="keyword">for</span>: .normal)</span><br><span class="line">button1.setTitleColor(<span class="type">UIColor</span>.blue, <span class="keyword">for</span>: .highlighted)</span><br><span class="line">button1.setTitleColor(<span class="type">UIColor</span>.cyan, <span class="keyword">for</span>: .selected)</span><br><span class="line">button1.setTitleColor(<span class="type">UIColor</span>.cyan, <span class="keyword">for</span>: .disabled)</span><br><span class="line"><span class="comment">//阴影文字颜色设置</span></span><br><span class="line">button1.setTitleShadowColor(<span class="type">UIColor</span>.cyan, <span class="keyword">for</span>: .normal)</span><br><span class="line">button1.setTitleShadowColor(<span class="type">UIColor</span>.green, <span class="keyword">for</span>: .highlighted)</span><br><span class="line">button1.setTitleShadowColor(<span class="type">UIColor</span>.brown, <span class="keyword">for</span>: .disabled)</span><br><span class="line">button1.setTitleShadowColor(<span class="type">UIColor</span>.darkGray, <span class="keyword">for</span>: .selected)</span><br></pre></td></tr></table></figure><h2 id="UIButton设置背景颜色和背景图片"><a href="#UIButton设置背景颜色和背景图片" class="headerlink" title="UIButton设置背景颜色和背景图片"></a>UIButton设置背景颜色和背景图片</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//背景颜色</span></span><br><span class="line">button2.backgroundColor = <span class="type">UIColor</span>.orange</span><br><span class="line"><span class="comment">//背景图片    button4.setBackgroundImage(UIImage(named:"XXX"), for: .normal)</span></span><br></pre></td></tr></table></figure><h2 id="UIButton设置字体大小"><a href="#UIButton设置字体大小" class="headerlink" title="UIButton设置字体大小"></a>UIButton设置字体大小</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">button.titleLabel?.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>)</span><br></pre></td></tr></table></figure><h2 id="禁用UIButton"><a href="#禁用UIButton" class="headerlink" title="禁用UIButton"></a>禁用UIButton</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> button.isEnabled = <span class="literal">false</span></span><br><span class="line">button.isEnabled = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="设置圆角"><a href="#设置圆角" class="headerlink" title="设置圆角"></a>设置圆角</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> button.layer.cornerRadius = <span class="number">5</span></span><br><span class="line">button.layer.masksToBounds = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="设置边框宽度-颜色"><a href="#设置边框宽度-颜色" class="headerlink" title="设置边框宽度/颜色"></a>设置边框宽度/颜色</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> button.layer.borderWidth = <span class="number">2</span></span><br><span class="line">button.layer.borderColor = <span class="type">UIColor</span>.red.cgColor</span><br></pre></td></tr></table></figure><h2 id="设置背景图片为圆角"><a href="#设置背景图片为圆角" class="headerlink" title="设置背景图片为圆角"></a>设置背景图片为圆角</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> buttonImage.setImage(<span class="type">UIImage</span>(named:<span class="string">"1"</span>) , forState: <span class="type">UIControlState</span>.<span class="type">Normal</span>)</span><br><span class="line"><span class="comment">//设置背景图片为圆角</span></span><br><span class="line">buttonImage.imageView?.layer.cornerRadius = <span class="number">50</span></span><br><span class="line"></span><br><span class="line">默认情况下按钮会被渲染成单一颜色；系统蓝</span><br><span class="line">button.setImage(<span class="type">UIImage</span>(named:<span class="string">"icon1"</span>),forState:.<span class="type">Normal</span>)  <span class="comment">//设置图标</span></span><br><span class="line">button.adjustsImageWhenHighlighted=<span class="literal">false</span> <span class="comment">//使触摸模式下按钮也不会变暗（半透明）</span></span><br><span class="line">button.adjustsImageWhenDisabled=<span class="literal">false</span> <span class="comment">//使禁用模式下按钮也不会变暗（半透明）</span></span><br><span class="line"></span><br><span class="line">也可以设置成保留图标原来的颜色</span><br><span class="line"><span class="keyword">let</span> iconImage = <span class="type">UIImage</span>(named:<span class="string">"icon2"</span>)?.withRenderingMode(.alwaysOriginal)</span><br><span class="line">button.setImage(iconImage, <span class="keyword">for</span>:.normal)  <span class="comment">//设置图标</span></span><br><span class="line">button.adjustsImageWhenHighlighted = <span class="literal">false</span> <span class="comment">//使触摸模式下按钮也不会变暗（半透明）</span></span><br><span class="line">button.adjustsImageWhenDisabled = <span class="literal">false</span> <span class="comment">//使禁用模式下按钮也不会变暗（半透明）</span></span><br></pre></td></tr></table></figure><h2 id="UIButton上图片和文字调整"><a href="#UIButton上图片和文字调整" class="headerlink" title="UIButton上图片和文字调整"></a>UIButton上图片和文字调整</h2><blockquote><p>UIButton上添加图片和文字，有时需要我们调整,方向为逆时针方向，上、左、下、右依次去设置的</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  btn.imageEdgeInsets =<span class="type">UIEdgeInsetsMake</span>(top: <span class="type">CGFloat</span>, <span class="keyword">left</span>: <span class="type">CGFloat</span>, bottom: <span class="type">CGFloat</span>, <span class="keyword">right</span>: <span class="type">CGFloat</span>)</span><br><span class="line"></span><br><span class="line">btn.titleEdgeInsets =<span class="type">UIEdgeInsetsMake</span>(top: <span class="type">CGFloat</span>, <span class="keyword">left</span>: <span class="type">CGFloat</span>, bottom: <span class="type">CGFloat</span>, <span class="keyword">right</span>: <span class="type">CGFloat</span>)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//创建一个图片一个文字的按钮  </span></span><br><span class="line"><span class="keyword">let</span> btn2: <span class="type">UIButton</span> = <span class="type">UIButton</span>(type: .<span class="type">Custom</span>)  </span><br><span class="line">btn2.frame = <span class="type">CGRectMake</span>(<span class="number">50</span>, <span class="number">100</span>, <span class="number">120</span>, <span class="number">35</span>)  </span><br><span class="line">btn2.setImage(<span class="type">UIImage</span>(named: <span class="string">"1"</span>), forState: .<span class="type">Normal</span>)  </span><br><span class="line">btn2.backgroundColor = <span class="type">UIColor</span>.blackColor()  </span><br><span class="line">btn2.titleLabel?.font = <span class="type">UIFont</span>.systemFontOfSize(<span class="number">20</span>)  </span><br><span class="line">btn2.imageView?.contentMode = <span class="type">UIViewContentMode</span>.<span class="type">ScaleAspectFit</span>  </span><br><span class="line">btn2.setTitle(<span class="string">"图片按钮"</span>, forState: .<span class="type">Normal</span>)  </span><br><span class="line"><span class="comment">//偏移量，分别为上下左右  </span></span><br><span class="line">btn2.imageEdgeInsets = <span class="type">UIEdgeInsetsMake</span>(<span class="number">0</span>, -<span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>)  </span><br><span class="line">btn2.titleEdgeInsets = <span class="type">UIEdgeInsetsMake</span>(<span class="number">0</span>, -<span class="number">80</span>, <span class="number">0</span>, <span class="number">5</span>)  </span><br><span class="line">btn2.setTitleColor(<span class="type">UIColor</span>.whiteColor(), forState: .<span class="type">Normal</span>)  </span><br><span class="line">btn2.adjustsImageWhenHighlighted = <span class="literal">false</span>  </span><br><span class="line"><span class="keyword">self</span>.view.addSubview(btn2)</span><br></pre></td></tr></table></figure><h2 id="添加按钮的点击事件"><a href="#添加按钮的点击事件" class="headerlink" title="添加按钮的点击事件"></a>添加按钮的点击事件</h2><blockquote><p>按钮的触摸时间有以下类型</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> touchDown：单点触摸按下事件，点触屏幕</span><br><span class="line">touchDownRepeat：多点触摸按下事件，点触计数大于<span class="number">1</span>，按下第<span class="number">2</span>、<span class="number">3</span>或第<span class="number">4</span>根手指的时候</span><br><span class="line">touchDragInside：触摸在控件内拖动时</span><br><span class="line">touchDragOutside：触摸在控件外拖动时</span><br><span class="line">touchDragEnter：触摸从控件之外拖动到内部时</span><br><span class="line">touchDragExit：触摸从控件内部拖动到外部时</span><br><span class="line">touchUpInside：在控件之内触摸并抬起事件</span><br><span class="line">touchUpOutside：在控件之外触摸抬起事件</span><br><span class="line">touchCancel：触摸取消事件，即一次触摸因为放上太多手指而被取消，或者电话打断</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  button1.addTarget(<span class="keyword">self</span>,action:#selector(methodName), <span class="keyword">for</span>: .touchUpInside)</span><br><span class="line">button1.addTarget(<span class="keyword">self</span>, action:#selector(someMethod(button:)), <span class="keyword">for</span>:.touchUpInside)</span><br><span class="line"><span class="comment">//上</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">methodName</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"tapped"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">someMethod</span><span class="params">(button:UIButton)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"你是谁啊，其实就是一个按钮"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="按钮文字过长时候的显示处理"><a href="#按钮文字过长时候的显示处理" class="headerlink" title="按钮文字过长时候的显示处理"></a>按钮文字过长时候的显示处理</h2><blockquote><p>修改 button 按钮中 titleLabel 的 lineBreakMode 属性，便可以调整按钮在文字超长的情况下如何显示，以及是否换行</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> button = <span class="type">UIButton</span>(frame:<span class="type">CGRect</span>(x:<span class="number">20</span>, y:<span class="number">50</span>, width:<span class="number">130</span>, height:<span class="number">50</span>))</span><br><span class="line">button.setTitle(<span class="string">"这个是一长长长长长长长长长长的文字"</span>, <span class="keyword">for</span>:.normal) <span class="comment">//普通状态下的文字</span></span><br><span class="line">button.setTitleColor(<span class="type">UIColor</span>.white, <span class="keyword">for</span>: .normal) <span class="comment">//普通状态下文字的颜色</span></span><br><span class="line">button.titleLabel?.lineBreakMode = .byTruncatingTail</span><br><span class="line">button.backgroundColor = <span class="type">UIColor</span>.orange</span><br><span class="line"><span class="keyword">self</span>.view.addSubview(button)</span><br></pre></td></tr></table></figure><blockquote><p>NSLineBreakMode样式可供选择，API的介绍也是简单明</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">NSLineBreakMode</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> byWordWrapping <span class="comment">// Wrap at word boundaries, default</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> byCharWrapping <span class="comment">// Wrap at character boundaries</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> byClipping <span class="comment">// Simply clip</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> byTruncatingHead <span class="comment">// Truncate at head of line: "...wxyz"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> byTruncatingTail <span class="comment">// Truncate at tail of line: "abcd..."</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> byTruncatingMiddle <span class="comment">// Truncate middle of line:  "ab...yz"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UIButton </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIButton </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-UILabel</title>
      <link href="/2017/12/06/Swift/Swift/UIKit/UILabel/"/>
      <url>/2017/12/06/Swift/Swift/UIKit/UILabel/</url>
      <content type="html"><![CDATA[<h1 id="lab"><a href="#lab" class="headerlink" title="lab"></a>lab</h1><blockquote><p>创建&amp;&amp; 设置frame</p></blockquote> <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lab = <span class="type">UILabel</span>(frame:<span class="type">CGRect</span>(x:<span class="number">10</span>,y:<span class="number">100</span>,width:<span class="keyword">self</span>.view.frame.size.width - <span class="number">40</span>,height:<span class="number">200</span>))</span><br><span class="line"></span><br><span class="line"> 或</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> lab = <span class="type">UILabel</span>()</span><br><span class="line">lab.frame = <span class="type">CGRect</span>(x:<span class="number">10</span>,y:<span class="number">100</span>,width:<span class="keyword">self</span>.view.frame.size.width - <span class="number">40</span>,height:<span class="number">200</span>)</span><br></pre></td></tr></table></figure><blockquote><p>添加父层</p></blockquote> <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.view.addSubview(lab);</span><br></pre></td></tr></table></figure><blockquote><p>显示文本内容</p></blockquote> <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">lab.text = <span class="string">"chen jian !"</span></span><br></pre></td></tr></table></figure><blockquote><p>设置bg颜色</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">lab.backgroundColor = <span class="type">UIColor</span>.green</span><br></pre></td></tr></table></figure><blockquote><p>文字颜色</p></blockquote> <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">lab.textColor = <span class="type">UIColor</span>.white</span><br></pre></td></tr></table></figure><blockquote><p>文字对齐方式</p></blockquote> <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">lab.textAlignment = <span class="type">NSTextAlignment</span>.<span class="keyword">left</span></span><br></pre></td></tr></table></figure><blockquote><p>高亮文字颜色</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">lab.highlightedTextColor = <span class="type">UIColor</span>.cyan</span><br></pre></td></tr></table></figure><blockquote><p>阴影颜色</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">lab.shadowColor = <span class="type">UIColor</span>.black</span><br></pre></td></tr></table></figure><blockquote><p>阴影偏移位置</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">lab.shadowOffset = <span class="type">CGSize</span>(width:-<span class="number">5</span>,height:<span class="number">5</span>)</span><br></pre></td></tr></table></figure><blockquote><p>设置圆角</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">lab.layer.cornerRadius = <span class="number">20</span></span><br><span class="line">lab.layer.masksToBounds = <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>边框的宽度和颜色</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">lab.layer.borderColor = <span class="type">UIColor</span>.green.cgColor</span><br><span class="line">lab.layer.borderWidth = <span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p>文字类型/大小</p></blockquote> <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">lab.font = <span class="type">UIFont</span>.boldSystemFont(ofSize: <span class="number">20</span>)  <span class="comment">//加粗类型</span></span><br><span class="line">lab.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">20</span>)      <span class="comment">//文字大小</span></span><br><span class="line">lab.font = <span class="type">UIFont</span>.italicSystemFont(ofSize: <span class="number">20</span>)<span class="comment">//斜体类型</span></span><br><span class="line">lab.font = <span class="type">UIFont</span>(name:<span class="string">"您好"</span>,size:<span class="number">50</span>)         <span class="comment">//大小和文字一起设置</span></span><br></pre></td></tr></table></figure><blockquote><p>显示de样式</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   lab.lineBreakMode = <span class="type">NSLineBreakMode</span>.byCharWrapping</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// NSParagraphStyle</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">6.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">NSLineBreakMode</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> byWordWrapping <span class="comment">// Wrap at word boundaries, default</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> byCharWrapping <span class="comment">// Wrap at character boundaries</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> byClipping <span class="comment">// Simply clip</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> byTruncatingHead <span class="comment">// Truncate at head of line: "...wxyz"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> byTruncatingTail <span class="comment">// Truncate at tail of line: "abcd..."</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> byTruncatingMiddle <span class="comment">// Truncate middle of line:  "ab...yz"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>多行de显示</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">lab.numberOfLines = <span class="number">2</span> <span class="comment">//最多显示2行</span></span><br><span class="line">lab.numberOfLines = <span class="number">0</span> <span class="comment">// 默认没有行数显示</span></span><br><span class="line">lab.numberOfLines = <span class="number">1</span> <span class="comment">//只能显示一行</span></span><br></pre></td></tr></table></figure><blockquote><p>自动调整文字de大小</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">lab.adjustsFontSizeToFitWidth  =  <span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="富文本设置"><a href="#富文本设置" class="headerlink" title="富文本设置"></a>富文本设置</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//创建对象</span></span><br><span class="line"><span class="keyword">let</span> attributeString = <span class="type">NSMutableAttributedString</span>(string:<span class="string">"Welcome to Swift! Welcome to Swift! Welcome to Swift! Welcome to Swift!"</span>)</span><br><span class="line"><span class="comment">//设置字体大小/字体类型</span></span><br><span class="line">attributeString.addAttribute(<span class="type">NSFontAttributeName</span>, value: <span class="type">UIFont</span>(name: <span class="string">"HelveticaNeue-Bold"</span>, size: <span class="number">16</span>)!, range: <span class="type">NSMakeRange</span>(<span class="number">0</span>, <span class="number">6</span>))</span><br><span class="line"><span class="comment">//设置背景颜色           </span></span><br><span class="line">attributeString.addAttribute(<span class="type">NSForegroundColorAttributeName</span>, value: <span class="type">UIColor</span>.red, range: <span class="type">NSMakeRange</span>(<span class="number">0</span>, <span class="number">3</span>))          </span><br><span class="line"><span class="comment">//设置文档背景色     attributeString.addAttribute(NSBackgroundColorDocumentAttribute, value: UIColor.lightGray, range: NSMakeRange(10, 10))</span></span><br><span class="line"><span class="comment">//设置下划线</span></span><br><span class="line">attributeString.addAttribute(<span class="type">NSUnderlineStyleAttributeName</span>, value:<span class="type">NSUnderlineStyle</span>.<span class="type">StyleSingle</span>.rawValue, range: <span class="type">NSMakeRange</span>(<span class="number">5</span>,<span class="number">12</span>))</span><br><span class="line">        </span><br><span class="line">testLable.attributedText = attributeString;</span><br></pre></td></tr></table></figure><h1 id="文本高度计算"><a href="#文本高度计算" class="headerlink" title="文本高度计算"></a>文本高度计算</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">extension</span> <span class="title">NSString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">textSizeWithFont</span><span class="params">(font: UIFont, constrainedToSize size:CGSize)</span></span> -&gt; <span class="type">CGSize</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> textSize:<span class="type">CGSize</span>!</span><br><span class="line">        <span class="keyword">if</span> <span class="type">CGSizeEqualToSize</span>(size, <span class="type">CGSizeZero</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> attributes = <span class="type">NSDictionary</span>(object: font, forKey: <span class="type">NSFontAttributeName</span>)</span><br><span class="line">            textSize = <span class="keyword">self</span>.sizeWithAttributes(attributes)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> option = <span class="type">NSStringDrawingOptions</span>.<span class="type">UsesLineFragmentOrigin</span></span><br><span class="line">            <span class="keyword">let</span> attributes = <span class="type">NSDictionary</span>(object: font, forKey: <span class="type">NSFontAttributeName</span>)</span><br><span class="line">            <span class="keyword">let</span> stringRect = <span class="keyword">self</span>.boundingRectWithSize(size, options: option, attributes: attributes, context: <span class="literal">nil</span>)</span><br><span class="line">            textSize = stringRect.size</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> textSize</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UILabel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UILabel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-UIKit-AppDelegate项目入口</title>
      <link href="/2017/12/06/Swift/Swift/UIKit/AppDelegate%E9%A1%B9%E7%9B%AE%E5%85%A5%E5%8F%A3/"/>
      <url>/2017/12/06/Swift/Swift/UIKit/AppDelegate%E9%A1%B9%E7%9B%AE%E5%85%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<h1 id="AppDelegate-swift"><a href="#AppDelegate-swift" class="headerlink" title="AppDelegate.swift"></a>AppDelegate.swift</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//import是导入文件的/库的关键字</span></span><br><span class="line"><span class="comment">//UIKit是iOS中所有的控件的所在库文件</span></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="meta">@UIApplicationMain</span> <span class="comment">//调用了OC中的UIApplicationMain函数;</span></span><br><span class="line"><span class="comment">//UIApplicationMain是IOS应用程序的入口</span></span><br><span class="line"><span class="comment">//UIApplacationMain:1.创建了一个UIApplication对象,代表当前应用程序.作用是用来检测当前应用程序状态的改变</span></span><br><span class="line"><span class="comment">//                  2.创建一个遵守UIApplicationDelegate的协议的子类对象作为UIApplication的代理,作用是处理应用程序状态的改变(创建AppDelegate对象并且设置为UIApplication对象的代理)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIApplicationDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性:</span></span><br><span class="line">    <span class="keyword">var</span> window: <span class="type">UIWindow</span>?</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法:</span></span><br><span class="line">    <span class="comment">//一.当应用程序已经启动成功后,会自动调用这个方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">        <span class="comment">//1.在这个方法中来搭建应用程序中的所有的界面</span></span><br><span class="line">        <span class="comment">//2.获取应用程序需要展示的数据</span></span><br><span class="line">        <span class="comment">//3.使用界面展示数据</span></span><br><span class="line">        <span class="comment">//注意:如果不再做这个方法中去创建window,那么程序会通过Main.stroyboard去创建应用程序的界面</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"程序启动成功"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//二.当应用程序将要成为非活跃状态的时候会自动调用这个方法.</span></span><br><span class="line">    <span class="comment">//活跃状态:程序在屏幕上可见</span></span><br><span class="line">    <span class="comment">//非活跃状态:程序没有显示在屏幕上(按home键进入后台,来电打断,在当前应用程序中打开其他的应用程序)</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">applicationWillResignActive</span><span class="params">(application: UIApplication)</span></span> &#123;</span><br><span class="line">        <span class="comment">//按下home键:command + shift + h</span></span><br><span class="line">        <span class="comment">//在这个方法中一般去暂停视频/音频播放;游戏需要暂停;保存数据</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"将要成为非活跃状态"</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//三.应用程序已经进入后台的时候会自动调用</span></span><br><span class="line">    <span class="comment">//进入后台:按home键</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">applicationDidEnterBackground</span><span class="params">(application: UIApplication)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"进入后台"</span>)</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//四.应用程序将要进入前台的时候会自动调用</span></span><br><span class="line">    <span class="comment">//进入前台:</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">applicationWillEnterForeground</span><span class="params">(application: UIApplication)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"将要进入前台"</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//五.应用程序已经变成活跃状态的时候会自动调用</span></span><br><span class="line">    <span class="comment">//1.程序启动成功后</span></span><br><span class="line">    <span class="comment">//2.程序从后台重新进入前台</span></span><br><span class="line">    <span class="comment">//3.来电打断结束...</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">applicationDidBecomeActive</span><span class="params">(application: UIApplication)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"已经变成活跃状态"</span>)</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//六.应用程序将要终止的时候会调用这个方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">applicationWillTerminate</span><span class="params">(application: UIApplication)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"应用程序将要终止"</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ViewController-swift"><a href="#ViewController-swift" class="headerlink" title="ViewController.swift"></a>ViewController.swift</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">//UIView:是IOS中所有视图(控件)直接/间接的父类;所以UIView的属性和方法,对于其他类型的视图都有效</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//视图:在屏幕上能看到的所有的东西都属于视图</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一.创建UIView的对象</span></span><br><span class="line">        <span class="keyword">let</span> redView = <span class="type">UIView</span>.<span class="keyword">init</span>()</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//想要将视图展示在屏幕上的两个必要条件</span></span><br><span class="line">            <span class="comment">//1.必须设置坐标的大小(默认坐标是(0,0),大小(0,0,))</span></span><br><span class="line">            <span class="comment">//2.将视图添加到已经展示在屏幕上的视图上</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//二.设置frame属性(由坐标(x,y)和大小(width,height)两个部分组成)</span></span><br><span class="line">        </span><br><span class="line">        redView.frame = <span class="type">CGRect</span>(x: <span class="number">10</span>, y: <span class="number">10</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">        <span class="comment">//IOS中所有的结构体都有一个对应的Make方法用来快速的创建一个结构体变量</span></span><br><span class="line">        redView.frame = <span class="type">CGRectMake</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">        <span class="comment">//三.将视图添加到界面上</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(redView)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//四.设置背景颜色</span></span><br><span class="line">        <span class="comment">//视图的背景颜色默认是透明色</span></span><br><span class="line">        <span class="comment">//颜色的创建方式:</span></span><br><span class="line">        <span class="comment">//1.通过类型方法创建指定颜色</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        redView.backgroundColor = <span class="type">UIColor</span>.redColor()</span><br><span class="line">        <span class="comment">//通过三原色来创建颜色</span></span><br><span class="line">        <span class="comment">//CGFloat就是UI中的浮点型</span></span><br><span class="line">        <span class="comment">//参数1,2,3:红,绿,蓝的值(0~1)-(0/255~255/255)</span></span><br><span class="line">        <span class="comment">//参数4:透明度</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//redView.backgroundColor = UIColor(red: 149/255.0, green: 106/255.0, blue: 55/255.0, alpha: 1)</span></span><br><span class="line">        <span class="comment">//设置不同程度的灰色</span></span><br><span class="line">        <span class="comment">//redView.backgroundColor = UIColor(white: 0.2, alpha: 1)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//练习:创建一个黄色的矩形,显示在红色视图的中心位置,大小(50,50)</span></span><br><span class="line">        <span class="comment">//方式1:</span></span><br><span class="line">        <span class="comment">//创建视图对象并且设置frame属性</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        let yellowView = UIView.init()</span></span><br><span class="line"><span class="comment">        yellowView.frame = CGRectMake(35, 35, 50, 50)</span></span><br><span class="line"><span class="comment">        //添加到界面上</span></span><br><span class="line"><span class="comment">        self.view.addSubview(yellowView)</span></span><br><span class="line"><span class="comment">        //设置背景颜色</span></span><br><span class="line"><span class="comment">        yellowView.backgroundColor = UIColor.yellowColor()</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方式2:</span></span><br><span class="line">        <span class="keyword">let</span> yellowView = <span class="type">UIView</span>(frame: <span class="type">CGRectMake</span>(<span class="number">25</span>,<span class="number">25</span>,<span class="number">50</span>,<span class="number">50</span>))</span><br><span class="line">        redView.addSubview(yellowView)</span><br><span class="line">        yellowView.backgroundColor = <span class="type">UIColor</span>.yellowColor()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//GET:计算视图的坐标的时候,注意相对性.当前视图被添加到那个视图上,那么当前视图的坐标就是相对于谁来算的</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="视图对象的基本属性"><a href="#视图对象的基本属性" class="headerlink" title="视图对象的基本属性"></a>视图对象的基本属性</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  mport <span class="type">UIKit</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个视图对象</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> redView = <span class="type">UIView</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="comment">//添加到界面上</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(redView)</span><br><span class="line">        <span class="comment">//设置背景颜色</span></span><br><span class="line">        redView.backgroundColor = <span class="type">UIColor</span>.redColor()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.frame(坐标和大小)</span></span><br><span class="line">        redView.frame = <span class="type">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">        <span class="comment">//2.center(中心点坐标)</span></span><br><span class="line">        <span class="comment">//通过frame和确定视图的中心点坐标</span></span><br><span class="line">        <span class="built_in">print</span>(redView.center)</span><br><span class="line">        <span class="built_in">print</span>(redView.frame)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        redView.center = <span class="type">CGPointMake</span>(<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(redView.frame)</span><br><span class="line">        <span class="comment">//3.bounds(坐标和大小)</span></span><br><span class="line">        <span class="comment">//默认情况下bounds的坐标(0,0),大小和视图的frame大小一样</span></span><br><span class="line">        <span class="built_in">print</span>(redView.bounds)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//了解:</span></span><br><span class="line">        <span class="comment">//如果改变bounds的大小,不改变center的坐标,改变frame的坐标和大小</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        redView.bounds = CGRectMake(0, 0, 200, 200)</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        print(redView.frame)</span></span><br><span class="line"><span class="comment">        print("center\(redView.center)")</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果改变bounds的坐标,不影响当前视图的位置.但是影响添加到当前视图上的子视图的坐标,不建议修改bounds</span></span><br><span class="line">        </span><br><span class="line">        redView.bounds = <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> yellowView = <span class="type">UIView</span>.<span class="keyword">init</span>(frame:<span class="type">CGRectMake</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">40</span>, <span class="number">40</span>))</span><br><span class="line">        yellowView.backgroundColor = <span class="type">UIColor</span>.yellowColor()</span><br><span class="line">        redView.addSubview(yellowView)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.transform(形变)</span></span><br><span class="line">        <span class="comment">// 当前视图发生形变,那么添加到当前视图上的所有的视图会跟着一起形变</span></span><br><span class="line">        <span class="comment">//1). 缩放</span></span><br><span class="line">        <span class="comment">//参数1:x方向上的缩放比例</span></span><br><span class="line">        <span class="comment">//参数2:y方向上的缩放比例</span></span><br><span class="line">        redView.transform = <span class="type">CGAffineTransformMakeScale</span>(<span class="number">0.5</span>, <span class="number">0.5</span>)</span><br><span class="line">        <span class="comment">//2).旋转</span></span><br><span class="line">        <span class="comment">//参数:旋转角度(圆周率对应的角度)</span></span><br><span class="line">        redView.transform = <span class="type">CGAffineTransformMakeRotation</span>(<span class="type">CGFloat</span>(<span class="type">M_PI_4</span>))</span><br><span class="line">        <span class="comment">//3).平移</span></span><br><span class="line">        <span class="comment">//参数1:在x方向上平移的距离</span></span><br><span class="line">        <span class="comment">//参数2:在y方向上平移的距离</span></span><br><span class="line">        redView.transform = <span class="type">CGAffineTransformMakeTranslation</span>(<span class="number">0</span>, <span class="number">300</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4).多个形变同时进行</span></span><br><span class="line">        <span class="comment">//在另外一个形变的前提下旋转</span></span><br><span class="line">        <span class="comment">//参数1:另外一个形变</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在拥有缩放这个形变的前提下旋转(既可以缩放又可以旋转)</span></span><br><span class="line">        redView.transform = <span class="type">CGAffineTransformRotate</span>(<span class="type">CGAffineTransformMakeScale</span>(<span class="number">0.5</span>, <span class="number">0.5</span>), <span class="type">CGFloat</span>(<span class="type">M_PI_4</span> / <span class="number">2</span>))</span><br><span class="line">        <span class="comment">//在另外一个形变的前提下平移(既可以缩放和旋转又可以平移)</span></span><br><span class="line">        redView.transform = <span class="type">CGAffineTransformTranslate</span>(redView.transform, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//既可以平移又可以缩放</span></span><br><span class="line">        </span><br><span class="line">        redView.transform = <span class="type">CGAffineTransformScale</span>(<span class="type">CGAffineTransformMakeTranslation</span>(<span class="number">100</span>, <span class="number">0</span>), <span class="number">0.5</span>, <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//组合两个形变</span></span><br><span class="line">        <span class="comment">//旋转形变</span></span><br><span class="line">        <span class="keyword">let</span> rotate = <span class="type">CGAffineTransformMakeRotation</span>(<span class="number">0.2</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//平移形变</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> transLation = <span class="type">CGAffineTransformMakeTranslation</span>(<span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将旋转形变和平移形变组合</span></span><br><span class="line">        redView.transform = <span class="type">CGAffineTransformConcat</span>(rotate, transLation)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> AppDelegate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> AppDelegate </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-基础</title>
      <link href="/2017/12/06/Swift/Swift/Grammar/%E5%9F%BA%E7%A1%80/"/>
      <url>/2017/12/06/Swift/Swift/Grammar/%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello,Word!"</span>)</span><br></pre></td></tr></table></figure><h2 id="定义变量和常量"><a href="#定义变量和常量" class="headerlink" title="定义变量和常量"></a>定义变量和常量</h2><blockquote><p>let/var<br>在同一行代码中 不用书写分号</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> myCount = <span class="number">11</span> <span class="comment">//定义一个常量为myCount = 11 常量是不可改变的量</span></span><br><span class="line"><span class="keyword">var</span> myVariable = <span class="number">22</span></span><br><span class="line">myVariable = <span class="number">33</span> <span class="comment">//定义一个变量为myVariable = 22 然后改变它的值,将33赋给myVariable。现在myVariable的值为33。</span></span><br></pre></td></tr></table></figure><h2 id="字符串插值打印"><a href="#字符串插值打印" class="headerlink" title="字符串插值打印"></a>字符串插值打印</h2><blockquote><p>符串插值的是在print的过程中，将你定义的常量或变量插入你要输出的字符串中</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"ChenJian,<span class="subst">\(myCount)</span>!"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"YueKekui!<span class="subst">\(myVariable)</span>"</span>)</span><br></pre></td></tr></table></figure><h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><blockquote><p>在swift中 如果可以的话 尽可能省略类型标记，让swift自己推断类型</p></blockquote><h2 id="关于Swift中类型int，float，double相关的"><a href="#关于Swift中类型int，float，double相关的" class="headerlink" title="关于Swift中类型int，float，double相关的"></a>关于Swift中类型int，float，double相关的</h2><blockquote><p>Double(three) 和C语言的强制转换有很大区别<br>Double(three) swift 中是将three这个数据的值取出来，从新定义一个Double类型的变量，并将Three的值赋这个变量</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> three = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> pointOneFourOneFiveNine = <span class="number">0.14159</span></span><br><span class="line"><span class="keyword">let</span> pi = <span class="type">Double</span>(three) + pointOneFourOneFiveNine</span><br></pre></td></tr></table></figure><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><blockquote><p>元组是用一个变量或常量，保存多项数据</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> http404Error = (<span class="number">404</span>, <span class="string">"Not Found"</span>)</span><br><span class="line"><span class="comment">// http404Error is of type (Int, String), and equals (404, "Not Found")</span></span><br></pre></td></tr></table></figure><blockquote><p>下划线的意思 忽略这一项</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> (justTheStatusCode, <span class="number">_</span>) = http404Error</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status code is <span class="subst">\(justTheStatusCode)</span>"</span>)</span><br><span class="line"><span class="comment">// Prints "The status code is 404</span></span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><blockquote><p>运算符 可以分为一元运算符，二元运算符，三元运算符</p></blockquote><h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><blockquote><p>数字前面代表数字正负的正负号是唯一的一元运算符</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">-<span class="number">8</span>,-<span class="number">14</span>,+<span class="number">8</span>(正数我们一般省略前面的正号写为：<span class="number">8</span>)</span><br></pre></td></tr></table></figure><h3 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h3><blockquote><p>赋值运算符</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">5</span></span><br><span class="line">a = b</span><br><span class="line"><span class="comment">// a is now equal to 10</span></span><br></pre></td></tr></table></figure><blockquote><p>关系运算符</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="number">1</span> == <span class="number">1</span>  </span><br><span class="line"><span class="number">2</span> != <span class="number">1</span>   </span><br><span class="line"><span class="number">2</span> &gt; <span class="number">1</span>    </span><br><span class="line"><span class="number">1</span> &lt; <span class="number">2</span>    </span><br><span class="line"><span class="number">1</span> &gt;= <span class="number">1</span>   </span><br><span class="line"><span class="number">2</span> &lt;= <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>算术运算符：加减乘除取余</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span>       <span class="comment">// equals 3</span></span><br><span class="line"><span class="number">5</span> - <span class="number">3</span>       <span class="comment">// equals 2</span></span><br><span class="line"><span class="number">2</span> * <span class="number">3</span>       <span class="comment">// equals 6</span></span><br><span class="line"><span class="number">10.0</span> / <span class="number">2.5</span>  <span class="comment">// equals 4.0 </span></span><br><span class="line"><span class="number">9</span> % <span class="number">2</span>       <span class="comment">// equals 1</span></span><br></pre></td></tr></table></figure><blockquote><p>三元运算符</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//让c 取a 和b中较小的值</span></span><br><span class="line"><span class="keyword">let</span> a =<span class="number">5</span> , b=<span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a &lt; b ? a : b</span><br><span class="line"></span><br><span class="line"><span class="comment">//问号前面是一个产生Bool类型的变量，常量或表达式</span></span><br></pre></td></tr></table></figure><h2 id="Parentheses-圆括号的作用"><a href="#Parentheses-圆括号的作用" class="headerlink" title="Parentheses 圆括号的作用"></a>Parentheses 圆括号的作用</h2><blockquote><p>可以使用圆括号改变运算顺序 ，如果不清楚运算的执行程序也可以直接使用圆括号来改变运算顺序</p></blockquote><h2 id="容器类型-数组"><a href="#容器类型-数组" class="headerlink" title="容器类型-数组"></a>容器类型-数组</h2><blockquote><p>数组是一个有序的集合<br>数组的第一个元素的下标是从0开始的 而不是1</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> threeDoubles = [<span class="type">Double</span>](<span class="built_in">count</span>: <span class="number">3</span>, repeatedValue: <span class="number">0.0</span>)</span><br><span class="line"><span class="keyword">var</span> array1 = [<span class="type">Int</span>]()</span><br><span class="line"><span class="keyword">var</span> array2: [<span class="type">Int</span>] = []</span><br><span class="line"><span class="keyword">var</span> array3 = [<span class="number">99</span>,<span class="number">12</span>,<span class="number">34</span>,<span class="number">156</span>,<span class="number">7</span>]</span><br><span class="line"><span class="keyword">var</span> array4 = [<span class="type">Int</span>](<span class="built_in">count</span>: <span class="number">100</span>, repeatedValue: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrayString1 = [<span class="type">String</span>]()</span><br><span class="line"><span class="keyword">var</span> arrayString2: [<span class="type">String</span>] = []</span><br><span class="line"><span class="keyword">var</span> arrayString3 = [<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"apple"</span>,<span class="string">"orange"</span>]</span><br><span class="line"><span class="keyword">var</span> arrayString4 = [<span class="type">String</span>](<span class="built_in">count</span>: <span class="number">100</span>, repeatedValue: <span class="string">""</span>)</span><br></pre></td></tr></table></figure><blockquote><p>两个数组可以相加</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> anotherThreeDoubles = [<span class="type">Double</span>](<span class="built_in">count</span>: <span class="number">3</span>, repeatedValue: <span class="number">2.5</span>)</span><br><span class="line"><span class="comment">// anotherThreeDoubles is of type [Double], and equals [2.5, 2.5, 2.5]</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> sixDoubles = threeDoubles + anotherThreeDoubles</span><br><span class="line"><span class="comment">// sixDoubles is inferred as [Double], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.</span></span><br></pre></td></tr></table></figure><blockquote><p>向数组中添加元素的方法</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  shoppingList.append(<span class="string">"Flour"</span>)</span><br><span class="line"><span class="comment">//可以使用append这个函数</span></span><br><span class="line">shoppingList += [<span class="string">"Baking Powder"</span>]</span><br><span class="line"><span class="comment">// shoppingList now contains 4 items</span></span><br><span class="line">shoppingList += [<span class="string">"Chocolate Spread"</span>, <span class="string">"Cheese"</span>, <span class="string">"Butter"</span>]</span><br><span class="line"><span class="comment">//也可以用+=向数组中添加一个或多个元素</span></span><br></pre></td></tr></table></figure><blockquote><p>对数组进行遍历（迭代）</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> shoppingList = [<span class="string">"Six egg"</span>,<span class="string">"Milk"</span>,<span class="string">"Flour"</span>,<span class="string">"Baking Powder"</span>,<span class="string">"Bananas"</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> shoppingList &#123;</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> shoppingList.<span class="built_in">enumerate</span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Item <span class="subst">\(index + <span class="number">1</span>)</span>: <span class="subst">\(value)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Item 1: Six eggs</span></span><br><span class="line"><span class="comment">// Item 2: Milk</span></span><br><span class="line"><span class="comment">// Item 3: Flour</span></span><br><span class="line"><span class="comment">// Item 4: Baking Powder</span></span><br><span class="line"><span class="comment">// Item 5: Bananas”</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者：芒果微笑</span><br><span class="line">链接：http:<span class="comment">//www.jianshu.com/p/8e8ff60121c4</span></span><br><span class="line">來源：简书</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h1 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h1><p>##顺序结构 ,程序按正常顺序执行。</p><p>##分支结构</p><p>##循环结构</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//循环</span></span><br><span class="line"> <span class="comment">//第一种循环</span></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">10</span>  &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(i)</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    i += <span class="number">1</span><span class="comment">//i++</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//第二种循环  这种循环和上一种循环主要的区别是  --repeat循环至少执行一次</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">repeat</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(i)</span>.Hello,Word"</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">while</span> i &lt;= <span class="number">100</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//第三种循环</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(i)</span>.Hello,World!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不想用循环变量 i可以使用 _ 来省略i</span></span><br></pre></td></tr></table></figure><h3 id="猜数字"><a href="#猜数字" class="headerlink" title="猜数字"></a>猜数字</h3><blockquote><p>题目要求：书写一段Swift代码实现，随机出现一个1-100的数字，让用户猜这个数字是几，每次提示用户猜的数字是比实际数字大还是小，直到用户猜中为止</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> answer = <span class="type">Int</span>(arc4random_uniform(<span class="number">100</span>)) + <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> thyAnswer:<span class="type">Int</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"><span class="keyword">repeat</span>&#123;</span><br><span class="line">    counter += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"请输入你猜的数字："</span>,terminator:<span class="string">""</span>)</span><br><span class="line">    thyAnswer = inputInt()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> thyAnswer &gt; answer&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"猜小一点"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> thyAnswer &lt; answer&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"猜大一点"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"恭喜你猜对了！您一共猜了<span class="subst">\(counter)</span>次"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span> thyAnswer != answer</span><br><span class="line"><span class="keyword">if</span> counter &gt; <span class="number">7</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"你的智商该充值了！！！"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="得出1-100的素数"><a href="#得出1-100的素数" class="headerlink" title="得出1-100的素数"></a>得出1-100的素数</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//得出1-100的素数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPrime</span><span class="params">(n: Int)</span></span> -&gt; <span class="type">Bool</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= <span class="type">Int</span>(sqrt(<span class="type">Double</span>(n)))&#123;</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果上面的循环没有返回false 就说明在2到n开根号之间没有n的因子 因此返回true 表示n是素数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">1</span>...<span class="number">100</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> isPrime(n)&#123;</span><br><span class="line">        <span class="built_in">print</span>(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="百钱白鸡"><a href="#百钱白鸡" class="headerlink" title="百钱白鸡"></a>百钱白鸡</h3><blockquote><p>题目要求：现在有100块钱，公鸡5块一只，母鸡3块一只，小鸡1块三只，现在要用这100块买100只鸡，问公鸡，母鸡，小鸡各有多少只？</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> <span class="number">0</span>...<span class="number">20</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="number">0</span>...<span class="number">33</span>&#123;</span><br><span class="line">        <span class="keyword">let</span>  z = <span class="number">100</span> - x - y</span><br><span class="line">        <span class="keyword">if</span>  <span class="number">5</span> * x + <span class="number">3</span> * y + z / <span class="number">3</span> == <span class="number">100</span> &amp;&amp; z % <span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"公鸡：<span class="subst">\(x)</span>,母鸡:<span class="subst">\(y)</span>,小鸡<span class="subst">\(z)</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// GET:穷举法（穷尽所有的可能性直到正确答案</span></span><br></pre></td></tr></table></figure><h3 id="摇色子游戏"><a href="#摇色子游戏" class="headerlink" title="摇色子游戏"></a>摇色子游戏</h3><blockquote><p>题目要求：现有两人，一个玩家，一个庄家。玩家摇两个色子，如果第一次摇到7，11点玩家胜，摇到2，3，12庄家胜，摇到其他点数记住这个点数并继续摇下一次；以后每次玩家摇色子的点数和第一次记住的点数相同玩家胜，摇到7点庄家胜。用swift代码实现以上要求</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">roll</span><span class="params">()</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Int</span>(arc4random_uniform(<span class="number">6</span>)) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> money = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">repeat</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"玩家总资产:￥<span class="subst">\(money)</span>元"</span>)   </span><br><span class="line">    <span class="keyword">var</span> debt:<span class="type">Int</span></span><br><span class="line">    <span class="keyword">repeat</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"请下注:"</span>,terminator:<span class="string">""</span>)</span><br><span class="line">    debt = inputInt()</span><br><span class="line">    &#125;<span class="keyword">while</span> debt &lt;= <span class="number">0</span> || debt &gt; money</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> needsGoOn = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> fristPoint = roll() + roll()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"玩家摇出了<span class="subst">\(fristPoint)</span>"</span>)</span><br><span class="line">    <span class="keyword">switch</span> fristPoint&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>,<span class="number">11</span>:</span><br><span class="line">        money += debt</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"玩家胜!!!"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>,<span class="number">3</span>,<span class="number">12</span>:</span><br><span class="line">        money -= debt</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"庄家胜!!!"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        needsGoOn = <span class="literal">true</span> <span class="comment">//游戏继续</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> needsGoOn&#123;</span><br><span class="line">        <span class="keyword">let</span> currentPoint = roll() + roll()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"玩家摇出了<span class="subst">\(currentPoint)</span>"</span>)</span><br><span class="line">        <span class="keyword">if</span> currentPoint == <span class="number">7</span> &#123;</span><br><span class="line">            money -= debt</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"庄家胜!!!"</span>)</span><br><span class="line">            needsGoOn = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> currentPoint == fristPoint&#123;</span><br><span class="line">            money += debt</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"玩家胜!!!"</span>)</span><br><span class="line">            needsGoOn = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">while</span> money &gt; <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"你破产了！！！！"</span>)</span><br></pre></td></tr></table></figure><h2 id="排序选择"><a href="#排序选择" class="headerlink" title="排序选择"></a>排序选择</h2><blockquote><p>题目要求：一个数组中无序的数字，使用简单选择排序法排序。ps：简单选择排序:每次从剩下元素中找最小的元素放到对应的位置</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> array = [<span class="number">27</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">58</span>,<span class="number">44</span>,<span class="number">89</span>,<span class="number">12</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;array.<span class="built_in">count</span> - <span class="number">1</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mindex = i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> i+<span class="number">1</span>..&lt;array.<span class="built_in">count</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> array[j] &lt; array[mindex]&#123;</span><br><span class="line">            mindex = j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">(array[i],array[mindex]) = (array[mindex],array[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(array)</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><blockquote><p>题目要求：一个数组中无序的数字，使用冒泡排序法排序。ps:冒泡排序：两个数字排序将大的数字排在后面</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> array = [<span class="number">27</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">58</span>,<span class="number">44</span>,<span class="number">89</span>,<span class="number">12</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;array.<span class="built_in">count</span> - <span class="number">1</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> swapped = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..&lt;array.<span class="built_in">count</span> - <span class="number">1</span> - i&#123;</span><br><span class="line">        <span class="keyword">if</span> array[j] &gt; array[j+<span class="number">1</span>]&#123;</span><br><span class="line">            (array[j],array[j+<span class="number">1</span>]) = (array[j+<span class="number">1</span>],array[j])</span><br><span class="line">            swapped = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> swapped == <span class="literal">false</span> <span class="comment">// if !swapped</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(array)</span><br></pre></td></tr></table></figure><h1 id="字典和集合"><a href="#字典和集合" class="headerlink" title="字典和集合"></a>字典和集合</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">//字典(存放键值对组合的容器)</span></span><br><span class="line"><span class="comment">//字典中的每个元素都是由两部分构成,冒号前面的是键，冒号后面的是值</span></span><br><span class="line"><span class="keyword">var</span> dict:[<span class="type">String</span>:<span class="type">String</span>] = [<span class="string">"abacus"</span>:<span class="string">"算盘"</span>,<span class="string">"abnormal"</span>:<span class="string">"异常的"</span>,<span class="string">"hello"</span>:<span class="string">"你好"</span>,<span class="string">"good"</span>:<span class="string">"好的"</span>]</span><br><span class="line"><span class="comment">//print 前面的键 就会输出后面的值</span></span><br><span class="line"><span class="comment">//但是print 后面的值 不会输出前面的键</span></span><br><span class="line"><span class="built_in">print</span>(dict[<span class="string">"hello"</span>]!)</span><br><span class="line"><span class="built_in">print</span>(dict[<span class="string">"abcxyz"</span>])</span><br><span class="line"><span class="built_in">print</span>(dict[<span class="string">"你好"</span>])</span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">dict[<span class="string">"shit"</span>] = <span class="string">"狗屎"</span></span><br><span class="line">dict[<span class="string">"delicious"</span>] = <span class="string">"好吃的"</span></span><br><span class="line"><span class="built_in">print</span>(dict)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"> dict.removeValueForKey(<span class="string">"hello"</span>) <span class="comment">//第一种</span></span><br><span class="line">dict[<span class="string">"hello"</span>] = <span class="literal">nil</span> <span class="comment">//第二种</span></span><br><span class="line"><span class="built_in">print</span>(dict)</span><br><span class="line"><span class="built_in">print</span>(dict[<span class="string">"hello"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改元素</span></span><br><span class="line">dict[<span class="string">"shit"</span>] = <span class="string">"牛粪"</span></span><br><span class="line"><span class="built_in">print</span>(dict)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历字典中所有的值</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> dict.values &#123;</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历字典中所有的键</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dict.keys &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(key)</span> ---&gt; <span class="subst">\(dict[key])</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接通过一个元组获得字典中的键和值(原始类型)</span></span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> dict &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(key)</span> ---&gt; <span class="subst">\(value)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><blockquote><p>集合中两个值相同的元素，会合并到一起</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> a: <span class="type">Set</span>&lt;<span class="type">Int</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">a.insert(<span class="number">100</span>)           <span class="comment">// 添加元素</span></span><br><span class="line">a.remove(<span class="number">2</span>)             <span class="comment">// 删除元素</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="keyword">var</span> b: <span class="type">Set</span>&lt;<span class="type">Int</span>&gt; = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>]</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.intersect(b))   <span class="comment">// 交集(a和b都有的元素)</span></span><br><span class="line"><span class="built_in">print</span>(a.union(b))       <span class="comment">// 并集(a和b的所有元素)</span></span><br><span class="line"><span class="built_in">print</span>(a.subtract(b))    <span class="comment">// 差集(a有b没有的元素)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a == b)</span><br><span class="line"><span class="built_in">print</span>(b.isSubsetOf(a))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span>: <span class="type">Set</span>&lt;<span class="type">Int</span>&gt; = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">c</span>.isSubsetOf(a))      <span class="comment">// 判断c是不是a的子集</span></span><br><span class="line"><span class="built_in">print</span>(a.isSupersetOf(<span class="built_in">c</span>))    <span class="comment">// 判断a是不是c的超集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d: <span class="type">Set</span>&lt;<span class="type">Int</span>&gt; = [<span class="number">2</span>, <span class="number">1000</span>, <span class="number">10000</span>]</span><br><span class="line"><span class="built_in">print</span>(a.isDisjointWith(d))  <span class="comment">// 判断两个集合是否相交</span></span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><blockquote><p>函数我认为是swift语言中最重要的章节之一。<br>定义函数的关键词为func</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 函数的参数名</span></span><br><span class="line"><span class="comment">// 函数名(外部参数名 内部参数名: 类型, 外部参数名 内部参数名: 类型)</span></span><br><span class="line"><span class="comment">// 如果不写外部参数名那么内部参数名也是外部参数名</span></span><br><span class="line"><span class="comment">// 可以使用_来作为外部参数名表示省略外部参数名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myMin</span><span class="params">(a x: Int, b y: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y ? x : y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数的时候要写函数的外部参数名</span></span><br><span class="line"><span class="built_in">print</span>(myMin(a: <span class="number">3</span>, b: <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数</span></span><br><span class="line"><span class="comment">// func 函数名(参数列表) -&gt; 返回类型 &#123; 函数的执行体 &#125;</span></span><br><span class="line"><span class="comment">// Swift中函数的参数可以设定默认值</span></span><br><span class="line"><span class="comment">// 如果调用函数的时候没有给该参数赋值就直接使用默认值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(personName: String, alreadyGreeted: Bool = <span class="literal">false</span>)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="comment">// let greeting = "Hello, " + personName + "!"</span></span><br><span class="line">    <span class="comment">// 如果函数的返回类型不是Void 那么函数中一定有return语句</span></span><br><span class="line">    <span class="comment">// return greeting</span></span><br><span class="line">    <span class="comment">// personName = "王小锤"   // 编译错误</span></span><br><span class="line">    <span class="keyword">if</span> alreadyGreeted &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"怎么又是你, "</span> + personName + <span class="string">"!"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"你好, "</span> + personName + <span class="string">"!"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="comment">// 函数名(参数值)</span></span><br><span class="line"><span class="comment">// 调用Swift的函数时, 在默认情况下从第二个参数开始需要写参数名</span></span><br><span class="line"><span class="built_in">print</span>(sayHello(<span class="string">"王大锤"</span>, alreadyGreeted: <span class="literal">true</span>))</span><br><span class="line"><span class="comment">// 如果没有给第二个参数赋值那么就直接使用默认值false</span></span><br><span class="line"><span class="keyword">let</span> str = sayHello(<span class="string">"Jack"</span>)</span><br><span class="line"><span class="built_in">print</span>(str)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift中函数的参数列表可以是可变参数列表(参数的个数是任意多个)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums: Int...)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums &#123;</span><br><span class="line">        total += num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sum())</span><br><span class="line"><span class="built_in">print</span>(sum(<span class="number">999</span>))</span><br><span class="line"><span class="built_in">print</span>(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(sum(<span class="number">90</span>, <span class="number">82</span>, <span class="number">37</span>, <span class="number">68</span>, <span class="number">55</span>, <span class="number">11</span>, <span class="number">99</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用元组(tuple)让函数一次返回多条数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minMax</span><span class="params">(array: [Int])</span></span> -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>)? &#123;</span><br><span class="line">    <span class="keyword">if</span> array.<span class="built_in">count</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> currentMin = array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> currentMax = array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span>..&lt;array.<span class="built_in">count</span>] &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; currentMin &#123;</span><br><span class="line">            currentMin = value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> value &gt; currentMax &#123;</span><br><span class="line">            currentMax = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (currentMin, currentMax)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> b = minMax([<span class="number">23</span>, <span class="number">45</span>, <span class="number">99</span>, <span class="number">68</span>, <span class="number">72</span>, <span class="number">12</span>, <span class="number">55</span>]) &#123;</span><br><span class="line">    <span class="built_in">print</span>(b.<span class="built_in">min</span>)        <span class="comment">// print(b.0)</span></span><br><span class="line">    <span class="built_in">print</span>(b.<span class="built_in">max</span>)        <span class="comment">// print(b.1)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"数组中没有元素!!!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(<span class="keyword">inout</span> a: Int, <span class="keyword">inout</span> <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">    (a, b) = (b, a)</span><br><span class="line"><span class="comment">//    let temp = a</span></span><br><span class="line"><span class="comment">//    a = b</span></span><br><span class="line"><span class="comment">//    b = temp</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">300</span>, b = <span class="number">500</span></span><br><span class="line"><span class="built_in">swap</span>(&amp;a, &amp;b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"a = <span class="subst">\(a)</span>"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"b = <span class="subst">\(b)</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// inout - 输入输出参数(不仅将数据传入函数还要从函数中取出数据)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createX</span><span class="params">(<span class="keyword">inout</span> x: Int)</span></span> &#123;</span><br><span class="line">    x = <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"><span class="comment">// inout类型的参数前要加上&amp;符号</span></span><br><span class="line">createX(&amp;x)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 设计一个函数根据系统时间返回不同的问候语</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(name: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> date = <span class="type">NSDate</span>()</span><br><span class="line">    <span class="keyword">let</span> cal = <span class="type">NSCalendar</span>.currentCalendar()</span><br><span class="line">    <span class="keyword">let</span> hour = cal.component(.<span class="type">Hour</span>, fromDate: date)</span><br><span class="line"><span class="comment">//这三句代码的意思为：第一句 获取当前系统时间 </span></span><br><span class="line"><span class="comment">//第二句是 当前历法</span></span><br><span class="line"><span class="comment">//第三句是 当前小时</span></span><br><span class="line">    <span class="keyword">var</span> greeting: <span class="type">String</span></span><br><span class="line">    <span class="keyword">switch</span> hour &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>...<span class="number">6</span>:         <span class="comment">// 不同的分支可以有重叠的部分</span></span><br><span class="line">        greeting = <span class="string">"滚去碎觉了"</span></span><br><span class="line">        <span class="comment">// fallthrough  // 继续执行下一个case</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>...<span class="number">10</span>:        <span class="comment">// 匹配了一个分支之后不再匹配其他的分支</span></span><br><span class="line">        greeting = <span class="string">"早起的鸟儿有虫吃"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>...<span class="number">13</span>:</span><br><span class="line">        greeting = <span class="string">"中午好"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">14</span>...<span class="number">18</span>:</span><br><span class="line">        greeting = <span class="string">"下午好"</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        greeting = <span class="string">"晚上好"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name + <span class="string">", "</span> + greeting + <span class="string">"!"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sayHello(<span class="string">"小刚"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设计一个函数传入两个正整数m和n, 计算从m加到n的和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(m: Int, <span class="number">_</span> n: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> (a, b) = m &gt; n ? (n, m) : (m, n)</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a...b &#123;</span><br><span class="line">        value += i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sum(<span class="number">1</span>, <span class="number">100</span>))</span><br><span class="line"><span class="built_in">print</span>(sum(<span class="number">5</span>, -<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(sum(-<span class="number">1</span>, -<span class="number">5</span>))</span><br></pre></td></tr></table></figure><h2 id="调用苹果自身的Api，进行程序应用开发"><a href="#调用苹果自身的Api，进行程序应用开发" class="headerlink" title="调用苹果自身的Api，进行程序应用开发"></a>调用苹果自身的Api，进行程序应用开发</h2><h2 id="调用苹果的指纹识别，开发一个带有指纹识别的支付功能的app"><a href="#调用苹果的指纹识别，开发一个带有指纹识别的支付功能的app" class="headerlink" title="调用苹果的指纹识别，开发一个带有指纹识别的支付功能的app"></a>调用苹果的指纹识别，开发一个带有指纹识别的支付功能的app</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> errPointer = <span class="type">NSErrorPointer</span>()</span><br><span class="line">        <span class="keyword">let</span> ctx = <span class="type">LAContext</span>()</span><br><span class="line">        <span class="comment">// 判断设备是否支持指纹识别</span></span><br><span class="line">        <span class="keyword">if</span> ctx.canEvaluatePolicy(.<span class="type">DeviceOwnerAuthenticationWithBiometrics</span>, error: errPointer) &#123;</span><br><span class="line">            <span class="comment">// z = f(x, g(y))</span></span><br><span class="line">            <span class="comment">// Swift中允许将一个函数作为另一个函数的参数</span></span><br><span class="line">            <span class="comment">// evalutePolicy方法的第三个参数是一个函数</span></span><br><span class="line">            <span class="comment">// 该函数有两个参数没有返回值</span></span><br><span class="line">            <span class="comment">// 给该参数传参时可以在花括号中写一个匿名函数传进去</span></span><br><span class="line">            <span class="comment">// 该匿名函数通常也称之为闭包(closure)</span></span><br><span class="line">            ctx.evaluatePolicy(.<span class="type">DeviceOwnerAuthenticationWithBiometrics</span>, localizedReason: <span class="string">"请输入指纹进行支付"</span>, reply: &#123; (isOK, err) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> isOK &#123;</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">"支付成功!!!"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">"指纹验证失败, 请输入支付密码"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"你的设备不支持指纹识别"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote><p>闭包也称：匿名函数 意思是没有名字的函数<br>闭包由来：<br>在swift中函数也是一种类型<br>这也就意味着函数可以作为变量或常量的类型<br>同理函数也可以作为另一个函数和参数或返回值</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mul</span><span class="params">(a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(array: [Int], fn: <span class="params">(Int, Int)</span></span></span> -&gt; <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> array[<span class="number">1</span>..&lt;array.<span class="built_in">count</span>] &#123;</span><br><span class="line">        sum = fn(sum, x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于在swift中能省则省的原则和传统就将调用函数做了以下几步写法省略</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment">// 当调用foo函数时第二个参数可以传什么?</span></span><br><span class="line"><span class="comment">// 1. 所有自定义的(Int, Int) -&gt; Int类型的函数</span></span><br><span class="line"><span class="built_in">print</span>(foo(a, fn: sum))</span><br><span class="line"><span class="comment">// 2. 传入已有的二元运算符: +-*/%(因为运算符也是函数)</span></span><br><span class="line"><span class="built_in">print</span>(foo(a, fn: +))</span><br><span class="line"><span class="comment">// 3. 传入匿名函数(闭包)</span></span><br><span class="line"><span class="comment">// 3.1 完整的闭包写法</span></span><br><span class="line"><span class="built_in">print</span>(foo(a, fn: &#123; (a, b) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;))</span><br><span class="line"><span class="comment">// 3.2 省略掉类型和不必要的括号</span></span><br><span class="line"><span class="built_in">print</span>(foo(a, fn: &#123; a, b <span class="keyword">in</span> a + b &#125;))</span><br><span class="line"><span class="comment">// 3.3 省略参数名</span></span><br><span class="line"><span class="built_in">print</span>(foo(a, fn: &#123; $<span class="number">0</span> + $<span class="number">1</span> &#125;))</span><br><span class="line"><span class="comment">// 3.4 尾随闭包</span></span><br><span class="line"><span class="built_in">print</span>(foo(a) &#123; (a, b) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">print</span>(foo(a) &#123; $<span class="number">0</span> + $<span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是：<br>如果函数的最后一个参数是闭包可以写成尾随闭包的形式<br>也就是将闭包放到函数参数的圆括号外面写在一对花括号中<br>如果函数后面有尾随闭包且函数的圆括号中没有参数<br>那么函数的圆括号也可以省略(仅限于有尾随闭包的场景）<br>例如</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> array = [<span class="string">"game"</span>, <span class="string">"abacus"</span>, <span class="string">"hello"</span>, <span class="string">"cat"</span>, <span class="string">"good"</span>, <span class="string">"internationalization"</span>, <span class="string">"chaos"</span>, <span class="string">"dislike"</span>, <span class="string">"zealot"</span>, <span class="string">"young"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// array.sortInPlace(&gt;)</span></span><br><span class="line">array.sortInPlace(&#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125;)</span><br><span class="line">array.sortInPlace() &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125;</span><br><span class="line">array.sortInPlace &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125; <span class="comment">//这就是尾随闭包的最简写法</span></span><br></pre></td></tr></table></figure><h2 id="数组最重要的三个功能"><a href="#数组最重要的三个功能" class="headerlink" title="数组最重要的三个功能"></a>数组最重要的三个功能</h2><blockquote><p>1.过滤 2.映射 3.缩减</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> array = [<span class="number">23</span>, <span class="number">37</span>, <span class="number">96</span>, <span class="number">55</span>, <span class="number">40</span>, <span class="number">92</span>, <span class="number">68</span>, <span class="number">88</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 过滤</span></span><br><span class="line"><span class="keyword">let</span> newArray1 = array.<span class="built_in">filter</span> &#123; $<span class="number">0</span> &gt; <span class="number">50</span> &#125; <span class="comment">//找到数组中比50大的数输出出来</span></span><br><span class="line"><span class="built_in">print</span>(newArray1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newArray2 = array.<span class="built_in">filter</span> &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125; <span class="comment">//找到数组中得偶数</span></span><br><span class="line"><span class="built_in">print</span>(newArray2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 映射</span></span><br><span class="line"><span class="keyword">let</span> newArray3 = array.<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125; <span class="comment">//将数组中的每个数平方</span></span><br><span class="line"><span class="built_in">print</span>(newArray3)</span><br><span class="line"><span class="keyword">let</span> newArray4 = array.<span class="built_in">map</span> &#123; sqrt(<span class="type">Double</span>($<span class="number">0</span>)) &#125; <span class="comment">//将数组中得每个数开根号</span></span><br><span class="line"><span class="built_in">print</span>(newArray4)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 缩减</span></span><br><span class="line"><span class="keyword">let</span> result1 = array.<span class="built_in">reduce</span>(<span class="number">0</span>, combine: +)<span class="comment">// 将数组中的每个数想加</span></span><br><span class="line"><span class="built_in">print</span>(result1)</span><br><span class="line"><span class="keyword">let</span> result2 = array.<span class="built_in">reduce</span>(<span class="number">1</span>, combine: *)<span class="comment">//将数组中的每个数相乘</span></span><br><span class="line"><span class="built_in">print</span>(result2)</span><br><span class="line"><span class="keyword">let</span> result3 = array.<span class="built_in">reduce</span>(array[<span class="number">0</span>]) &#123; <span class="comment">//取数组中最大的数</span></span><br><span class="line">    $<span class="number">1</span> &gt; $<span class="number">0</span> ? $<span class="number">1</span> : $<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(result3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strArray = [<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>]</span><br><span class="line"><span class="keyword">let</span> result4 = strArray.<span class="built_in">reduce</span>(<span class="string">""</span>) &#123; $<span class="number">0</span> + <span class="string">" "</span> + $<span class="number">1</span> &#125;<span class="comment">//将数组中的三个元素合为一个</span></span><br><span class="line"><span class="built_in">print</span>(result4)</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><blockquote><p>类和上文提到的函数 紧密相关<br>类是一类事物 而对象是这类事物中具体的实例</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> 步骤<span class="number">1</span>: 定义类(如果你要用的类苹果已经提供了就直接进入第<span class="number">2</span>步)</span><br><span class="line"> 定义类就可以创建出新的类型</span><br><span class="line"> 学生类</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 变量定义到类的外面就叫变量 - variable</span></span><br><span class="line">    <span class="comment">// 变量定义到类的里面就叫属性 - property</span></span><br><span class="line">    <span class="comment">// 数据抽象 - 找到和学生相关的属性(找名词)</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化方法(构造方法/构造器) - constructor</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 函数写到类的外面就叫函数 - function</span></span><br><span class="line">    <span class="comment">// 函数写到类的里面就叫方法 - method</span></span><br><span class="line">    <span class="comment">// 行为抽象 - 找到和学生相关的方法(找动词)</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span>正在吃饭."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">study</span><span class="params">(courseName: String)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span>正在学习<span class="subst">\(courseName)</span>."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">watchJapaneseAV</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> age &gt;= <span class="number">18</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span>正在动作片."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"亲爱的<span class="subst">\(name)</span>, 我们推荐你观看《熊出没》"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2: 创建对象(调用初始化方法)</span></span><br><span class="line"><span class="keyword">let</span> stu1 = <span class="type">Student</span>(name: <span class="string">"小刚"</span>, age: <span class="number">35</span>)</span><br><span class="line"><span class="comment">// 步骤3: 给对象发消息(通过给对象发消息来解决问题)</span></span><br><span class="line">stu1.eat()</span><br><span class="line">stu1.study(<span class="string">"Swift程序设计"</span>)</span><br><span class="line">stu1.watchJapaneseAV()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu2 = <span class="type">Student</span>(name: <span class="string">"王大锤"</span>, age: <span class="number">15</span>)</span><br><span class="line">stu2.eat()</span><br><span class="line">stu2.study(<span class="string">"中国近代史"</span>)</span><br><span class="line">stu2.watchJapaneseAV()</span><br></pre></td></tr></table></figure><blockquote><p>下面定义一个圆的类<br>类里面有求圆的面积和周长的方法（函数）<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 0. 发现类</span></span><br><span class="line"><span class="comment">//  - 在对问题的描述中找名词和动词</span></span><br><span class="line"><span class="comment">//  - 名词会成为类或者类中的属性 动词会成为类中的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义类</span></span><br><span class="line"><span class="comment">//  - 数据抽象(属性)</span></span><br><span class="line"><span class="comment">//  - 行为抽象(方法)</span></span><br><span class="line"><span class="comment">//  - 初始化方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问修饰符</span></span><br><span class="line"><span class="comment">//  - public (公开)</span></span><br><span class="line"><span class="comment">//  - internal (内部的) - 默认</span></span><br><span class="line"><span class="comment">//  - private (私有)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// stored property</span></span><br><span class="line">    <span class="comment">// 存储属性(保存和圆相关的数据的属性)</span></span><br><span class="line">    <span class="keyword">var</span> center: <span class="type">Point</span></span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(center: <span class="type">Point</span>, radius: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.center = center</span><br><span class="line">        <span class="keyword">self</span>.radius = radius</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通常获得某个计算出的值的方法都可以设计成计算属性</span></span><br><span class="line">    <span class="comment">// computational property</span></span><br><span class="line">    <span class="comment">// 计算属性(通过对存储属性做运算得到的属性)</span></span><br><span class="line">    <span class="keyword">var</span> perimeter: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="comment">// 圆的周长是一个只读属性</span></span><br><span class="line">        <span class="comment">// 所以此处只有get&#123;&#125;没有set&#123;&#125;</span></span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="number">2</span> * <span class="type">M_PI</span> * radius &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="type">M_PI</span> * radius * radius &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">注意：运算符重载</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line"><span class="comment">//运算符重载（为自定义的类型定义运算符）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> +<span class="params">(one: Fraction, two: Fraction)</span></span> -&gt; <span class="type">Fraction</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> one.add(two)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> -<span class="params">(one: Fraction, two: Fraction)</span></span> -&gt; <span class="type">Fraction</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> one.sub(two)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> *<span class="params">(one: Fraction, two: Fraction)</span></span> -&gt; <span class="type">Fraction</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> one.mul(two)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> /<span class="params">(one: Fraction, two: Fraction)</span></span> -&gt; <span class="type">Fraction</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> one.div(two)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 继承: 从已有的类创建新类的过程</span></span><br><span class="line"><span class="comment">// 提供继承信息的称为父类(超类/基类)</span></span><br><span class="line"><span class="comment">// 得到继承信息的称为子类(派生类/衍生类)</span></span><br><span class="line"><span class="comment">// 通常子类除了得到父类的继承信息还会增加一些自己特有的东西</span></span><br><span class="line"><span class="comment">// 所以子类的能力一定比父类更强大</span></span><br><span class="line"><span class="comment">// 继承的意义在于子类可以复用父类的代码并且增强系统现有的功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>, gender: <span class="type">Gender</span>, title: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.title = title</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, age: age, gender: gender)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">teach</span><span class="params">(courseName: String)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span><span class="subst">\(title)</span>正在教<span class="subst">\(courseName)</span>."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//父类和子类关系</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Person</span>(name: <span class="string">"王大锤"</span>, age: <span class="number">25</span>, gender: .<span class="type">Male</span>)</span><br><span class="line">p1.eat()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以将子类型的对象赋值给父类型的变量(因为子类跟父类之间是IS-A关系)</span></span><br><span class="line"><span class="comment">// 学生是人, 老师是人, 所以学生和老师的对象可以赋值给人类型的变量</span></span><br><span class="line"><span class="keyword">let</span> p2: <span class="type">Person</span> = <span class="type">Student</span>(name: <span class="string">"张尼玛"</span>, age: <span class="number">18</span>, gender: .<span class="type">Female</span>, major: <span class="string">"计算机科学与技术"</span>)</span><br><span class="line">p2.eat()</span><br><span class="line"><span class="comment">// 如果要将父类型的变量转换成子类型需要用as运算符进行类型转换</span></span><br><span class="line"><span class="comment">// 如果能够确认父类型的变量中就是某种子类型的对象可以用as!进行转换</span></span><br><span class="line"><span class="comment">// 如果不确定父类型的变量中是哪种子类型可以用as?尝试转换</span></span><br><span class="line">(p2 <span class="keyword">as</span>! <span class="type">Student</span>).study(<span class="string">"Swift程序设计"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> temp = p2 <span class="keyword">as</span>? <span class="type">Teacher</span> &#123;</span><br><span class="line">    temp.teach(<span class="string">"Java"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(p2.name)</span>不是老师!!!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3: <span class="type">Person</span> = <span class="type">Teacher</span>(name: <span class="string">"骆昊"</span>, age: <span class="number">35</span>, gender: .<span class="type">Male</span>, title: <span class="string">"叫兽"</span>)</span><br><span class="line"></span><br><span class="line">p3.eat()</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><blockquote><p>同样的对象类型(pet类型)接受了相同的消息(调用了相同的方法)<br>但是做了不同的事情 这就是多态(polymorphism)<br>例如：猫(cat)继承它的父类动物(pet)</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  / <span class="type">Cat</span>和<span class="type">Pet</span>之间是<span class="type">IS</span>-<span class="type">A</span>关系(继承)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>: <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hairColor: <span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 父类有的方法子类可以重新实现 这个过程叫方法重写</span></span><br><span class="line">    <span class="comment">// 需要在方法前添加override关键字</span></span><br><span class="line">    <span class="comment">// 重写有时也被称为置换/覆盖/覆写</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">play</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.play()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(nickname)</span>正在玩毛线球."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">shout</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(nickname)</span>: 喵喵喵……"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">catchTheMouse</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(nickname)</span>正在抓老鼠."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对父类的方法可以重新实现， 这个过程叫方法重写<br>这是实现多态的重要步骤之一！<br>下面是实现多态的第二个步骤：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> petsArray = [</span><br><span class="line">    <span class="type">Cat</span>(nickname:<span class="string">"加菲"</span>,gender: .<span class="type">Male</span>,age:<span class="number">2</span>),</span><br><span class="line">    <span class="type">Dog</span>(nickname: <span class="string">"吉娃娃"</span>, gender: .<span class="type">Male</span>, age: <span class="number">3</span>, isLarge: <span class="literal">false</span>),</span><br><span class="line">    <span class="type">Dog</span>(nickname: <span class="string">"大黄"</span>, gender: .<span class="type">FeMale</span>, age: <span class="number">2</span>, isLarge: <span class="literal">true</span>),</span><br><span class="line">    <span class="type">Mistress</span>(nickname: <span class="string">"小花"</span>,gender: .<span class="type">FeMale</span>,age:<span class="number">16</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pet <span class="keyword">in</span> petsArray&#123;</span><br><span class="line">    pet.eat()</span><br><span class="line">    <span class="comment">// 同样的对象类型(pet类型)接受了相同的消息(调用了相同的方法)</span></span><br><span class="line">    <span class="comment">// 但是做了不同的事情 这就是多态(polymorphism)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现多态的关键步骤：</span></span><br><span class="line">    <span class="comment">// 1.方法的重写(子类在继承父类的过程中对父类已有的方法进行重写,而且不同的子类给出各自不同的实现版本)</span></span><br><span class="line">    <span class="comment">// 2.对象造型(将子类对象当成父类型来使用)</span></span><br><span class="line">    pet.play()</span><br><span class="line">    pet.shout()</span><br><span class="line">    <span class="comment">// 如果dog是属于pet中 如果dog是Dog类型就可以调用keepTheDoor这个特有的方法</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> dog = pet <span class="keyword">as</span>? <span class="type">Dog</span>&#123;</span><br><span class="line">        dog.keepTheDoor()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> cat = pet <span class="keyword">as</span>? <span class="type">Cat</span>&#123;</span><br><span class="line">        cat.catchTheMouse()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> mistress = pet <span class="keyword">as</span>? <span class="type">Mistress</span>&#123;</span><br><span class="line">        mistress.makeTrouble()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Gender</span></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Male</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">FeMale</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-AccessControl-访问控制</title>
      <link href="/2017/12/01/Swift/Swift/Grammar/AccessControl-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"/>
      <url>/2017/12/01/Swift/Swift/Grammar/AccessControl-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="AccessControl访问控制"><a href="#AccessControl访问控制" class="headerlink" title="AccessControl访问控制"></a>AccessControl访问控制</h1><blockquote><p>Swift和C++，Java一样，也有访问控制的概念。通过访问权限的控制，我们可以对外隐藏内部的代码细节，防止修改。<br>Swift的访问控制是基于模块（modules）和源文件（source file）</p></blockquote><blockquote><p>Swift的模块概念是这样的：</p><ul><li>1、一个App bundle，或者一个framework都可以看成一个独立的module。 你可以使用import来引入别的module到你的module中来。<br>当你将你的代码打包成一个framework，这个framework就是一个module。里面的所有的东西都是属于这个framework，无论你将这个framework引入到别的framework或app中。</li></ul></blockquote><ul><li>2、一个源文件里面虽然可以定义多个类，但是建议一般一个源文件建立一个类。</li></ul><blockquote><p>Swift的访问权限有：<br>open，public，internal，fileprivate，private</p></blockquote><ul><li><p>1、public    这个权限允许同一个module内部的所有源代码访问，同时允许其他引入了该module的module使用。总的来说就是全开放</p></li><li><p>2、internal  这个权限允许同一个module内部的所有源代码访问，不允许其他module使用。</p></li><li><p>3、private   这个权限仅允许同一个source file的代码访问。</p></li></ul><blockquote><p>Swift的默认访问权限是internal。</p></blockquote><blockquote><p>public是最高访问权限，而private是最低访问权限。</p></blockquote><blockquote><p>Swift的权限编程原则：</p></blockquote><ul><li>一、高权限的东西不能包含在低权限的东西里面。</li></ul><blockquote><p>举例：</p></blockquote><ul><li><p>1、说就是一个public的类型不能定义在一个声明为internal的类型里面。</p></li><li><p>2、方法的权限不能高于参数和范围值的权限。否则会导致这个方法没法使用。</p></li></ul><blockquote><p>二、单一app中</p></blockquote><ul><li>一般就用默认的internal就行了。如果你想对其他源文件隐藏，可以使用private。</li></ul><blockquote><p>三、framework中</p></blockquote><ul><li><blockquote><p>对于要提供给外边使用的属性，方法。必须使用public权限。其他的可以默认使用internal。如果相对framework里面的其他源文件隐藏，可以使用private。</p></blockquote></li></ul><p>四、单元测试中</p><ul><li>单元测试和我们编写的代码属于不同的module，所以测试模块一般只能访问到public的东西。但是在引入要测试的模块的时候可以加上@testable，这样测试模块就可以访问了。然后要允许被测试的单元可以测试</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomePublicClass</span> </span>&#123;&#125;  </span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeInternalClass</span> </span>&#123;&#125;  </span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SomePrivateClass</span> </span>&#123;&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> somePublicVariable = <span class="number">0</span>  </span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">let</span> someInternalConstant = <span class="number">0</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">somePrivateFunction</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="给类型定义访问权限的时候，会影响到类型里面的成员（属性，方法，下标，构造器）"><a href="#给类型定义访问权限的时候，会影响到类型里面的成员（属性，方法，下标，构造器）" class="headerlink" title="给类型定义访问权限的时候，会影响到类型里面的成员（属性，方法，下标，构造器）"></a>给类型定义访问权限的时候，会影响到类型里面的成员（属性，方法，下标，构造器）</h1><ul><li><p>1、将一个类型定义为private后，它里面的成员都是private的。</p></li><li><p>2、将一个类型定义为public或internal后，它里面的成员还是internal的。如果要某个成员变为public，必须在该成员里面加上public。</p></li></ul><h2 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><blockquote><p>Tuple的访问权限由tuple成员里面访问权限最小那个决定。</p></blockquote><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><blockquote><p>方法的访问权限由方法的参数和返回值中最小权限的那个决定。当方法的权限是private的时候，方法的前面要加上private关键字。</p></blockquote><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><blockquote><p>枚举类型的成员变量的访问权限决定于枚举类型。例如你定义了一个public的枚举类型，那么它里面的case成员都是public的，不允许单独给每个case成员定义访问权限。<br>case成员的raw vlaue的值的权限必须大于等于枚举类的访问权限。</p></blockquote><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><blockquote><p>定义在private类型里面的内部类是private权限；定义在public或internal类型里面的内部类默认是internal类型。如果想要定义在public类型里面的内部类变为public的话，需要自己显式给内部类加上public。</p></blockquote><h2 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h2><blockquote><p>子类不能比父类具有更高的访问权限。但是可以重写父类当前能访问到的父类成员，而且可以重写成更高权限的成员</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">someMethod</span><span class="params">()</span></span> &#123;&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">A</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">someMethod</span><span class="params">()</span></span> &#123;  </span><br><span class="line">        <span class="keyword">super</span>.someMethod()  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>里再补充一点，如果父类是public类的，继承之后不加权限修饰符的话，那么这个子类是internal的<br>属性，常量，变量和下标的访问权限不能超过它所属的类型的权限</p></blockquote><h2 id="getter和setter方法"><a href="#getter和setter方法" class="headerlink" title="getter和setter方法"></a>getter和setter方法</h2><blockquote><p>这两个方法的访问权限默认和属性的是一样的。但是可以修改setter的权限，可以将setter的权限修改得比属性的权限低，但是不能比属性的权限高</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">internal</span>(<span class="keyword">set</span>) <span class="keyword">var</span> age: <span class="type">Int</span> = <span class="number">0</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><blockquote><p>构造器的权限不能大于它所属类型的权限。除了标志有require的构造器之外，这种构造器的权限必须和它所属的类的权限相同。<br>构造器参数的权限不能低于构造器。</p></blockquote><h2 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h2><blockquote><p>默认构造器的默认权限和类型权限一样。但是如果类型是public，那么默认构造器还是internal的，想要public的无参构造器必须自己实现。<br>对于结构体的memberwise构造器，想要public的，也要自己实现。</p></blockquote><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><blockquote><p>协议的需求的权限和协议权限是一样的，协议是public的，那么需求也是public的。<br>继承的协议的权限最多只能有父类的权限。例如：不能继承一个internal的协议为一个public协议。</p></blockquote><h2 id="协议的一致性"><a href="#协议的一致性" class="headerlink" title="协议的一致性"></a>协议的一致性</h2><blockquote><p>类型可以实现比自己访问权限低的协议。比如，可以定义一个public的类，它可以实现一个internal的类，并且只能在定义了该协议的模块中使用。<br>实现了协议的类访问权限是它本身和采用协议中的最低访问权限。也就是说如果一个类是public的级别，实现的是internal的协议，那么采用这个协议之后，该类的访问权限也是internal的。<br>如果你采用了协议，那么实现协议方法之后，该方法的访问权限遵循协议的访问级别。例如：一个public的类，采用了internal的协议之后，那么该类的实现协议的方法至少也是internal的。</p></blockquote><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><blockquote><p>扩展的默认访问权限由所扩展类型的访问权限决定。</p></blockquote><blockquote><p>如果你扩展了一个public的类型，那么扩展的成员的默认访问权限就是internal。如果扩展一个private类型，那么扩展的默认访问权限就是private。<br>当然可以自己给扩展自定义访问权限。但是权限不能超过所扩展的类型。另外可以自己给扩展成员再自定义权限。<br>如果你是用扩展来实现协议，那么这个扩展不允许自定义权限，它的权限由协议的权限决定。</p></blockquote><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><blockquote><p>泛型分为泛型类型和泛型方法<br>泛型类型的权限是 泛型类型和泛型参数 之间最小的那个权限。<br>泛型方法的权限是 泛型方法和泛型参数 之间最小的那个权限。</p></blockquote><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><blockquote><p>每个类型别名都可以看做是对类型的访问权限的定义。<br>但是类型别名的权限必须小于或等于要别名的类型。比如一个private的类型别名可以为private，public，internal的类型进行别名；但是一个public的类型别名不能为internal和private的类型进行别名。</p></blockquote>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
          <category> AccessControl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Grammar </tag>
            
            <tag> AccessControl </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-Generics-泛型</title>
      <link href="/2017/12/01/Swift/Swift/Grammar/Generics-%E6%B3%9B%E5%9E%8B/"/>
      <url>/2017/12/01/Swift/Swift/Grammar/Generics-%E6%B3%9B%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ul><li>接受其它函数作为参数的函数有时被称为高阶函数<h1 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h1><blockquote><p>写一个函数的时，一般都会指明参数的类型<br>一般默认在函数中定义的参数都是常量参数，也就是这个参数你只可以查询使用，不能改变它的值<br>如果想要声明一个变量参数，可以在前面加上var，这样就可以改变这个参数的值</p></blockquote></li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此时这个id值可以在函数中改变</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span>  <span class="title">getName</span><span class="params">(<span class="keyword">var</span> id:String)</span></span>.........</span><br></pre></td></tr></table></figure><blockquote><p>一般默认的参数传递都是传值调用的，而不是传引用。<strong>所以传入的参数在函数内改变，并不影响原来的那个参数</strong>。传入的只是这个参数的副本<br>下面两个实现交换变量的函数</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">( a:<span class="keyword">inout</span> Int, b:<span class="keyword">inout</span> Int)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> t = a   <span class="comment">//  0</span></span><br><span class="line">    a = b       <span class="comment">// 100</span></span><br><span class="line">    b = t       <span class="comment">//  0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>,y = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"x = <span class="subst">\(x)</span> ;y = <span class="subst">\(y)</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line">x = <span class="number">0</span> ;y = <span class="number">100</span></span><br><span class="line"><span class="comment">//交换变量的函数</span></span><br><span class="line">swapTwoInts(a: &amp;x, b: &amp;y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"x = <span class="subst">\(x)</span> ;y = <span class="subst">\(y)</span>"</span>)</span><br><span class="line">x = <span class="number">100</span> ;y = <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的只是限于交换整形。但是如果我们相对Double或Float类型，甚至是任何类型的数据实现交换的功能，我们都要分别写一个函数。这是无比麻烦的</p></blockquote><blockquote><p>所以有了泛型这个概念，泛型就是<strong>模糊的类型</strong><br>函数的功能实现和具体类型没关系的时候，就可以使用泛型(感觉类似OC的 id 类型)<br>将上面实现两个变量交换的功能用一个方法完成，这个方法可以用于不同的数据类型<br>swapTwoInts <t> 理解为一个函数族,类型参数 T 的每个选择都会确定一个新函数,该函数接受一个T型数组和一个 T -&gt; T类型的函数作为参数,并返回一个[T]类型的数组</t></p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoInts</span>&lt;T&gt;<span class="params">( a: <span class="keyword">inout</span> T, <span class="number">_</span> b: <span class="keyword">inout</span> T)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> t = a</span><br><span class="line">    a = b</span><br><span class="line">    b = t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">8.12</span>,y = <span class="number">100.1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"x = <span class="subst">\(x)</span> ;y = <span class="subst">\(y)</span>"</span>)   <span class="comment">//x = 8.12 ;y = 100.1</span></span><br><span class="line">swapTwoInts( a: &amp;x,  &amp;y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"x = <span class="subst">\(x)</span> ;y = <span class="subst">\(y)</span>"</span>)   <span class="comment">//x = 100.1 ;y = 8.12</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题：x = <span class="number">8</span>  y = <span class="number">100.1</span> 发生错误，整数和浮点型数如何写交换方法？？？</span><br></pre></td></tr></table></figure><blockquote><p>主要的语法就是上面的<t>，这个T就是代表某个类型，但是没有指明具体是哪种类型。而且这个T，可以换成你希望的标示符，只要不是关键字。并且一般要求单词的首字母要大写，比如Element、Value等。而且能指定多个类型，见下面的类型约束</t></p></blockquote><blockquote><p>泛型的函数调用方法和普通函数是一样的<br>下面创建了两个Animal实例，然后使用刚刚定义的函数交换数据。</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> life = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cat = <span class="type">Animal</span>()</span><br><span class="line">cat.life = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> dog = <span class="type">Animal</span>()</span><br><span class="line">dog.life = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">swapTwoInts(cat.life, dog.life)  <span class="comment">//报错！！ 方面交换方法不能交换。。醉了</span></span><br><span class="line"><span class="built_in">print</span>(cat.life)  </span><br><span class="line"><span class="built_in">print</span>(dog.life)</span><br></pre></td></tr></table></figure><blockquote><p>泛型举例分析</p></blockquote><p><a href="http://lib.csdn.net/article/swift/48384?knId=10" target="_blank" rel="noopener">参考</a></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//  map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;Element,T&gt;<span class="params">(xs:[Element],transfom:<span class="params">(Element)</span></span></span> -&gt;<span class="type">T</span>)-&gt;[<span class="type">T</span>]&#123;</span><br><span class="line">    <span class="keyword">var</span> result :[<span class="type">T</span>] = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> xs&#123;</span><br><span class="line">        result.append(transfom(x))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genericComputeArray</span>&lt;T&gt;<span class="params">(xs: [Int], transfom: <span class="params">(Int)</span></span></span> -&gt; <span class="type">T</span>) -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>(xs: xs, transfom: transfom)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这块 不是很理解</span><br></pre></td></tr></table></figure><blockquote><p>顶层函数和扩展<br>写一个函数,它接受一个给定的整型数组,通过计算得到并返回一个新数组。要求：新数组各项为原数组中对应的整型数据加一。for 循环能实现</p></blockquote><h1 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h1><blockquote><p>定义一个类型，但是它可以对不同类型的数据进行操作<br>比如Array和Dictionary这两个集合结构体，他们可以装不同类型的数据，这就是泛型类型</p></blockquote><h2 id="官方文档展示一个泛型类型的栈，使用Array来实现"><a href="#官方文档展示一个泛型类型的栈，使用Array来实现" class="headerlink" title="官方文档展示一个泛型类型的栈，使用Array来实现"></a>官方文档展示一个泛型类型的栈，使用Array来实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Stack&lt;Element&gt; &#123;  </span><br><span class="line">    var items = [Element]()  </span><br><span class="line">    mutating func push(item: Element) &#123;  </span><br><span class="line">        items.append(item)  </span><br><span class="line">    &#125;  </span><br><span class="line">    mutating func pop() -&gt; Element &#123;  </span><br><span class="line">        return items.removeLast()  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后在创建这种泛型类型实例的时候，我们必须指定所属的类型</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stackOfStrings = <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;()  </span><br><span class="line">stackOfStrings.push(<span class="string">"uno"</span>)</span><br></pre></td></tr></table></figure><h1 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h1><blockquote><p>我们可以对泛型进行约束，让他们必须遵守某些协议，官方文档语法如下</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span>&lt;T: SomeClass, U: SomeProtocol&gt;<span class="params">(someT: T, someU: U)</span></span> &#123;  </span><br><span class="line">    <span class="comment">// function body goes here  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同时还可以添加where约束符再对泛型进行限制</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span>&lt;T: SomeClass, U: SomeProtocol where T.someItem == U, U.someItem: SomeClass2&gt;<span class="params">(someT: T, someU: U)</span></span> &#123;  </span><br><span class="line">    <span class="comment">// function body goes here  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h1><blockquote><p>在定义协议的时候，我们可能需要定义一个或多个类型作为我们协议的一部分。而这些类型是不确定的，只有到具体的类实现协议的时候才能确定，这个时候我们可以使用关联类型来实现。所谓的关联类型就是一个占位符，等到具体实现协议的时候才知道它具体是什么类型。官方例子如下</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">protocol</span> <span class="title">Container</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ItemType</span>  </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(item: ItemType)</span></span>  </span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;  </span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">ItemType</span> &#123; <span class="keyword">get</span> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后在实现协议的时候，我们可以指定ItemType具体是什么类型</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntStack</span>: <span class="title">Container</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// original IntStack implementation  </span></span><br><span class="line">    <span class="keyword">var</span> items = [<span class="type">Int</span>]()  </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(item: Int)</span></span> &#123;  </span><br><span class="line">        items.append(item)  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> items.removeLast()  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// conformance to the Container protocol  </span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ItemType</span> = <span class="type">Int</span>  </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(item: Int)</span></span> &#123;  </span><br><span class="line">        <span class="keyword">self</span>.push(item)  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> items.<span class="built_in">count</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> items[i]  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote></blockquote><p>同时又因为有Swift的类型判断机制，所以我们在实现了协议的其他方法之后，编译器会自动判断关联类型是什么，不需要我们显式地指定。所以上面代码指定关联类型为Int的那行可以删去。</p><blockquote><p>泛型OC是不支持的，但是java支持。使用泛型能给编程带来很大的便利</p></blockquote>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-Extension扩展</title>
      <link href="/2017/12/01/Swift/Swift/Grammar/Extension%E6%89%A9%E5%B1%95/"/>
      <url>/2017/12/01/Swift/Swift/Grammar/Extension%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h1 id="Extension扩展"><a href="#Extension扩展" class="headerlink" title="Extension扩展"></a>Extension扩展</h1><blockquote><p>Swift中的扩展就是OC中的分类。但是这里的扩展可以对类、结构体、枚举类进行添加。使用扩展，我们可以在不接触源代码的前提下，对已有的代码进行功能上的添加。</p></blockquote><blockquote><p>Swift中的扩展提供的一些功能：</p></blockquote><ul><li>1、添加计算属性或类计算属性，但是不能添加存储属性。</li><li>2、添加实例方法或类别方法。但是不能覆盖已经存在的方法。</li><li>3、定义新的构造器。</li><li>4、定义和使用新的嵌套类。</li><li>5、令已经存在的类型遵守协议。</li></ul><blockquote><p>假设我们已经有了一个Animal类，但是不能得到它的源代码</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> life: <span class="type">Int</span> = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">var</span> height: <span class="type">Double</span> = <span class="number">0</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们利用扩展，对Animal添加一个计算属性和方法、构造器还有嵌套类。 当然也可以添加下标，但这里不演示了</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">extension</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//扩展计算属性  </span></span><br><span class="line">    <span class="keyword">var</span> lifeYear : <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="type">Double</span>(<span class="keyword">self</span>.life) / <span class="number">365</span> &#125;  </span><br><span class="line">    <span class="comment">//扩展构造器  </span></span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(life: <span class="type">Int</span>, height: <span class="type">Double</span>) &#123;  </span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>()  </span><br><span class="line">        <span class="keyword">self</span>.life = life  </span><br><span class="line">        <span class="keyword">self</span>.height = height  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//扩展方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeSound</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"I can live <span class="subst">\(lifeYear)</span> years"</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 扩展嵌套类  </span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Size</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">case</span> <span class="type">Big</span>, <span class="type">Small</span>, <span class="type">SuperSmall</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 扩展一个使用嵌套类的计算属性  </span></span><br><span class="line">    <span class="keyword">var</span> size: <span class="type">Size</span> &#123;  </span><br><span class="line">        <span class="keyword">switch</span> height &#123;  </span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> h <span class="keyword">where</span> h &gt; <span class="number">10</span>:  </span><br><span class="line">            <span class="keyword">return</span> .<span class="type">Big</span>  </span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> h <span class="keyword">where</span> h &gt; <span class="number">0.1</span>:  </span><br><span class="line">            <span class="keyword">return</span> .<span class="type">Small</span>  </span><br><span class="line">        <span class="keyword">default</span>:  </span><br><span class="line">            <span class="keyword">return</span> .<span class="type">SuperSmall</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> a = <span class="type">Animal</span>(life: <span class="number">3365</span> * <span class="number">7</span>, height: <span class="number">0.001</span>)  </span><br><span class="line"><span class="built_in">print</span>(a.size)   <span class="comment">// SuperSmall  </span></span><br><span class="line"><span class="built_in">print</span>(a.lifeYear)   <span class="comment">// 7.0  </span></span><br><span class="line"><span class="built_in">print</span>(a.makeSound())   <span class="comment">// I can live 7.0 years</span></span><br></pre></td></tr></table></figure><blockquote><p>面代码需要注意的是扩展构造器的时候，在构造器的时候讲过，在扩展中添加构造器是不会影响默认构造器的产生。不能添加原来已有的构造器。<br>另外在类扩展里面，是不给添加指定构造器或析构器，只能添加便利构造器。在便利构造器中，要先调用原来的构造器来初始化类后，才能对类进行访问。</p></blockquote><blockquote><p>扩展还有一个作用就是让类遵守协议。这部分留到协议里面讲<br>下面将以前将过的麻烦的String类型做一个扩展，使得方便截串和获取长度</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//获取字符串长度  </span></span><br><span class="line">    <span class="keyword">var</span> length: <span class="type">Int</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.characters.<span class="built_in">count</span> &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//获取部分字符串，如果不在范围内，返回nil。如果end大于字符串长度，那么截取到最后  </span></span><br><span class="line">    <span class="keyword">subscript</span> (start: <span class="type">Int</span>, end: <span class="type">Int</span>) -&gt; <span class="type">String</span>? &#123;  </span><br><span class="line">        <span class="keyword">if</span> start &gt; <span class="keyword">self</span>.length || start &lt; <span class="number">0</span> || start &gt; end &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">let</span> begin = <span class="keyword">self</span>.startIndex.advancedBy(start)  </span><br><span class="line">        <span class="keyword">var</span> terminal: <span class="type">Index</span>  </span><br><span class="line">        <span class="keyword">if</span> end &gt;= length &#123;  </span><br><span class="line">            terminal = <span class="keyword">self</span>.startIndex.advancedBy(length)  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            terminal = <span class="keyword">self</span>.startIndex.advancedBy(end + <span class="number">1</span>)  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">let</span> range = <span class="type">Range</span>(start: begin, end: terminal)  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.substringWithRange(range)  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//获取某个字符，如果不在范围内，返回nil  </span></span><br><span class="line">    <span class="keyword">subscript</span> (index: <span class="type">Int</span>) -&gt; <span class="type">Character</span>? &#123;  </span><br><span class="line">        <span class="keyword">if</span> index &gt; <span class="keyword">self</span>.length - <span class="number">1</span> || index &lt; <span class="number">0</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>[<span class="keyword">self</span>.startIndex.advancedBy(index)]  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后就可以这样截串</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> s = <span class="string">"哈0123456789"</span>  </span><br><span class="line"><span class="built_in">print</span>(s.length) <span class="comment">// 11  </span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>,<span class="number">2</span>])    <span class="comment">// Optional("哈01")  </span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">9</span>])     <span class="comment">// Optional("8")</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-Error-Handling错误处理</title>
      <link href="/2017/12/01/Swift/Swift/Grammar/Error-Handling-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
      <url>/2017/12/01/Swift/Swift/Grammar/Error-Handling-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="Swift-错误"><a href="#Swift-错误" class="headerlink" title="Swift-错误"></a>Swift-错误</h1><blockquote><p>Swift提供了一套完整的错误抛出-捕获-处理机制<br>Swift采用Error协议来表示错误类型，通过do-try-catch的方式来处理可能会抛出异常的代码</p></blockquote><h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><blockquote><p>可选值表示一个值要么有值，要么是nil。在Swift中，Optional是用enum写的，</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Optional</span>&lt;<span class="title">Wrapped</span>&gt; : <span class="title">ExpressibleByNilLiteral</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">case</span> some(<span class="type">Wrapped</span>)</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当发生错误的时候，返回一个可选值是常见的处理方式。但是，这种方式的有一个很明显的缺点</p></blockquote><ul><li>调用者不清楚为什么失败</li><li>不好进行相关的处理</li></ul><h1 id="Error协议与throws"><a href="#Error协议与throws" class="headerlink" title="Error协议与throws"></a>Error协议与throws</h1><ul><li>Error是一个空的协议，用来表示错误类型</li><li>NSError和CFError都遵循了这个协议</li></ul><blockquote><p>在Swfit中，枚举是一个特别适合用来处理Error的数据类型。<br>首先定义一个类Person表示人</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Sex</span></span>&#123;</span><br><span class="line"><span class="keyword">case</span> male</span><br><span class="line"><span class="keyword">case</span> female</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">let</span> sex:<span class="type">Sex</span></span><br><span class="line"><span class="keyword">var</span> money:<span class="type">CGFloat</span></span><br><span class="line"><span class="keyword">init</span>(sex:<span class="type">Sex</span> ,money:<span class="type">CGFloat</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.sex = sex</span><br><span class="line">    <span class="keyword">self</span>.money = money</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Person可以结婚，结婚的时候会发生一些错误，比如钱不够，比如性别不对，用枚举来表示</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">MarryError</span> : <span class="title">Error</span></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> lackMoney</span><br><span class="line">    <span class="keyword">case</span> wrongSex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>方法的实现如下</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">extension</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">marry</span><span class="params">(with another: Person)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>&#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">self</span>.sex != another.sex <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">MarryError</span>.wrongSex</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">self</span>.money + another.money &gt; <span class="number">100000</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">MarryError</span>.lackMoney</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一个带有throws关键字的函数，调用的时候有两种方式选择</p></blockquote><blockquote><p>①❶使用 do-try-catch 代码块</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> tom = <span class="type">Person</span>(sex: .male, money: <span class="number">100000</span>)</span><br><span class="line"><span class="keyword">let</span> jack = <span class="type">Person</span>(sex: .male, money: <span class="number">100000</span>)</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> tom.marry(with: jack)</span><br><span class="line">&#125;<span class="keyword">catch</span> <span class="type">MarryError</span>.wrongSex &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Two Person have same sex"</span>)</span><br><span class="line">&#125;<span class="keyword">catch</span> <span class="type">MarryError</span>.lackMoney&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Oh, they do not have enough moeny"</span>)</span><br><span class="line">&#125;<span class="keyword">catch</span> <span class="keyword">let</span> error&#123;</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>❷不需要区分每一个Error，也可以这么调用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> tom.marry(with: jack)</span><br><span class="line">&#125;<span class="keyword">catch</span> <span class="keyword">let</span> error&#123;</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>②使用 try?，对于有返回值的throws函数，使用try?会把结果转换为可选值</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> tom = <span class="type">Person</span>(sex: .male, money: <span class="number">100000</span>)</span><br><span class="line"><span class="keyword">let</span> jack = <span class="type">Person</span>(sex: .male, money: <span class="number">100000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> result = <span class="keyword">try</span>? tom.marry(with: jack)&#123;<span class="comment">//成功</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Error happen"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="defer关键字"><a href="#defer关键字" class="headerlink" title="defer关键字"></a>defer关键字</h1><blockquote><p>defer关键字用来处理类似Ojective C中@try-@catch-@finally中，@finally的作用<br>比如，打开文件，如果抛出错误的话，我们总希望关闭这个文件句柄</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">contents</span><span class="params">(of filePath:String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> file = <span class="keyword">open</span>(filePath,<span class="type">O_RDWR</span>)</span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        close(file)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span>代码块的内容在退出作用域之前会被执行</span><br></pre></td></tr></table></figure><blockquote><p>关于defer的注意</p></blockquote><ul><li>多个defer会按照逆序的方式执行。</li><li>当你的程序遇到严重错误，比如fatalError,或者强制解析nil，或者segfaults的时候，defer的代码块并不会执行。</li></ul><h1 id="rethrow"><a href="#rethrow" class="headerlink" title="rethrow"></a>rethrow</h1><blockquote><p>rethrow关键字在高阶函数中比较常见，所谓高阶函数，就是一个函数的参数或者返回值是函数类型<br>最常见的比如，Sequence协议map方法<br>比如：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> result = array.<span class="built_in">map</span>&#123;$<span class="number">0</span> * <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于map函数传入的是一个闭包，这个闭包可能会抛出错误<br>由参数抛出的错误最后会向上传递给map函数</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">MapError</span> : <span class="title">Error</span></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> invalid</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">customMapper</span><span class="params">(input:Int)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> input &lt; <span class="number">10</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">MapError</span>.invalid</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> input + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> result = array.<span class="built_in">map</span>(customMapper)</span><br></pre></td></tr></table></figure><blockquote><p>这样是编译不通过的<br>调用的时候需要：按照上文提到的throws关键字的路子来</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line">   <span class="keyword">let</span> result = <span class="keyword">try</span> array.<span class="built_in">map</span>(customMapper)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> error&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这就是rethrows关键字的精髓所在<br>rethrows 关键字表示当参数闭包标记为throws的时候，函数本身为throws。如果参数闭包不会抛出错误，则函数也不会<br>通过这个关键字，你不必每次都进行try-catch</p></blockquote><h1 id="Result类型"><a href="#Result类型" class="headerlink" title="Result类型"></a>Result类型</h1><blockquote><p>一个函数执行要么成功，要么失败。成功的时候我们希望返回数据，失败的时候我们希望得到错误信息，这就是Result类型，一个典型的Result类型如下：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> success(<span class="type">T</span>)</span><br><span class="line">    <span class="keyword">case</span> failure(error:<span class="type">Error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过Result类型，不再需要可选值或者do-try-catch来包裹你的代码<br>用Result类型对上述marry函数进行重写</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">extension</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">marry</span><span class="params">(with another: Person)</span></span>  -&gt; <span class="type">Result</span>&lt;<span class="type">Bool</span>&gt;&#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">self</span>.sex != another.sex <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> .failure(error: <span class="type">MarryError</span>.wrongSex)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">self</span>.money + another.money &gt; <span class="number">100000</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> .failure(error: <span class="type">MarryError</span>.lackMoney)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> .success(<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后，这么调用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> tom = <span class="type">Person</span>(sex: .male, money: <span class="number">100000</span>)</span><br><span class="line"> <span class="keyword">let</span> jack = <span class="type">Person</span>(sex: .male, money: <span class="number">100000</span>)</span><br><span class="line"> <span class="keyword">let</span> result = tom.marry(with: jack)</span><br><span class="line">  <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .success(value):</span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .failure(error):</span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Result链"><a href="#Result链" class="headerlink" title="Result链"></a>Result链</h1><blockquote><p>Swift中有可选链，来处理多个可选值的连续调用。同样的，我们也可以为Result类型来添加链式调用：</p></blockquote><ul><li>如果上一个调用结果是.success, 则继续调用下一个</li><li>如果上一个调用结果是.failure, 则传递failure给下一个<blockquote><p>用extension来实现</p></blockquote></li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">extension</span> <span class="title">Result</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;V&gt;<span class="params">(transform:<span class="params">(T)</span></span></span> <span class="keyword">throws</span> -&gt; (<span class="type">V</span>)) <span class="keyword">rethrows</span> -&gt; <span class="type">Result</span>&lt;<span class="type">V</span>&gt;&#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> .failure(error):</span><br><span class="line">            <span class="keyword">return</span> .failure(error: error)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> .success(data):</span><br><span class="line">            <span class="keyword">return</span> .success(<span class="keyword">try</span> transform(data))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>于是，可以这么调用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">resut.flatMap(&#123;<span class="comment">//转换1&#125;).flatMap(//转换2)...</span></span><br></pre></td></tr></table></figure><blockquote><p>一旦失败，中间有一次flatMap转换失败，则之后的转换逻辑都不会执行<br>进阶：Result类型在Swift版本的Promise中大行其道，可以参见PromiseKit的源码，promise让异步处理变得优雅</p></blockquote><h1 id="assert-precondition"><a href="#assert-precondition" class="headerlink" title="assert/precondition"></a>assert/precondition</h1><blockquote><p>Swift也有断言支持<br>在Swfit中，断言是一个函数<br>断言仅在Debug模式下进行检查，帮助开发者发现代码中的问题</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assert</span><span class="params">(<span class="number">_</span> condition: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">Bool</span>, </span><br><span class="line">             <span class="number">_</span> message: <span class="meta">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>, </span><br><span class="line">                  file: <span class="type">StaticString</span> = #file, </span><br><span class="line">                  line: <span class="type">UInt</span> = #line)</span><br></pre></td></tr></table></figure><blockquote><p>如果需要在Relase模式下也进行检查，则使用precondition</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">precondition</span><span class="params">(<span class="number">_</span> condition: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">Bool</span>, </span><br><span class="line">             <span class="number">_</span> message: <span class="meta">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>, </span><br><span class="line">                  file: <span class="type">StaticString</span> = #file, </span><br><span class="line">                  line: <span class="type">UInt</span> = #line)</span><br></pre></td></tr></table></figure><h1 id="桥接到Objective-C"><a href="#桥接到Objective-C" class="headerlink" title="桥接到Objective C"></a>桥接到Objective C</h1><blockquote><p>使用NSError来处理错误的的Objective 方法</p></blockquote><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//NSFileManager</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)removeItemAtURL:(<span class="built_in">NSURL</span> *)URL error:(<span class="built_in">NSError</span> * _Nullable *)error;</span><br></pre></td></tr></table></figure><blockquote><p>在Swift中会被自动的转换成</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeItem</span><span class="params">(at URL: URL)</span></span> <span class="keyword">throws</span></span><br></pre></td></tr></table></figure><blockquote><p>但是，纯Swfit的Error桥接的Objective C的时候，会有一些问题<br>因为NSError需要 domain和code等详细信息<br>可以让Swift的Error实现CustomNSError协议，来提供这些需要的信息</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">MarryError</span> : <span class="title">Error</span></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> lackMoney</span><br><span class="line">    <span class="keyword">case</span> wrongSex</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MarryError</span> : <span class="title">CustomNSError</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> errorDomain = <span class="string">"com.person.marryError"</span></span><br><span class="line">    <span class="keyword">var</span> erroCode:<span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .lackMoney:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">100001</span></span><br><span class="line">        <span class="keyword">case</span> .wrongSex:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">100002</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> errorUserInfo:[<span class="type">String</span>:<span class="type">Any</span>]&#123;</span><br><span class="line">        <span class="keyword">return</span> [:]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>相关的，还有两个协议LocalizedError和RecoverableError</p></blockquote><h1 id="Swift的错误处理是用来处理运行时错误的"><a href="#Swift的错误处理是用来处理运行时错误的" class="headerlink" title="Swift的错误处理是用来处理运行时错误的"></a>Swift的错误处理是用来处理运行时错误的</h1><blockquote><p>当错误发生时，你可以选择抓错误，或者继续往上抛出错误。当一个运行时错误最终没办法处理的时候，程序就会崩溃。</p></blockquote><blockquote><p>Swift中有一个空的协议用来给用户自定义错误。一般使用枚举类实现这个协议来自定义错误。如下</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">ComputerError</span>: <span class="title">ErrorType</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">NoGameError</span>  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">MemoryError</span>  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">HardDiskError</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里定义了三种error。当你要抛出一个error的时候，使用throw关键字。如下</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="type">ComputerError</span>.<span class="type">NoGameError</span></span><br></pre></td></tr></table></figure><blockquote><p>可以抛出错误的函数的定义</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">canThrowErrors</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">String</span>  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cannotThrowErrors</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure><blockquote><p>利用上面的语法，我们定义一个Computer类，这个类有一个playGame方法，它会在某些情况下抛出错误</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> memory = <span class="number">1024</span>  </span><br><span class="line">    <span class="keyword">var</span> hardDisk = <span class="number">4000</span>  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">var</span> games = [  </span><br><span class="line">        <span class="string">"War3"</span>: <span class="type">Requirement</span>(memory: <span class="number">512</span>, <span class="type">HardDisk</span>: <span class="number">1500</span>),  </span><br><span class="line">        <span class="string">"LOL"</span>: <span class="type">Requirement</span>(memory: <span class="number">1500</span>, <span class="type">HardDisk</span>: <span class="number">3000</span>),  </span><br><span class="line">        <span class="string">"My World"</span>: <span class="type">Requirement</span>(memory: <span class="number">256</span>, <span class="type">HardDisk</span>: <span class="number">500</span>)]  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">playGame</span><span class="params">(gameName: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>&#123;  </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> game = <span class="keyword">self</span>.games[gameName] <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="type">ComputerError</span>.<span class="type">NoGameError</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">guard</span> game.<span class="type">HardDisk</span> &lt; <span class="keyword">self</span>.hardDisk <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="type">ComputerError</span>.<span class="type">HardDiskError</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">guard</span> game.memory &lt; <span class="keyword">self</span>.memory <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="type">ComputerError</span>.<span class="type">MemoryError</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意一点的是，如果你要调用能抛出错误的函数的时候，必须使用try、try?或者try!关键字在前面，如下</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> myPC.playGame(<span class="string">"War4"</span>)   <span class="comment">//这句会因为没有War4这个游戏而抛出NoGameError错误</span></span><br></pre></td></tr></table></figure><blockquote><p>下面是处理错误的部分。<br>当调用一个可以抛出错误的方法的时候，一般有三种处理方法。<br>第一种是调用者继续向上抛出这个错误。这种情况下，这个调用者也必须是一个可以抛出错误的函数。如果最后没处理这个错误，那么程序崩溃。<br>第二种是使用do…catch语句对错误进行处理。<br>第三种是使用try?或try!调用会抛出错误的函数</p></blockquote><blockquote><p>第一种方法举例，再定义一个Person类，它的play方法里面调用了Computer的playGame方法，然后继续抛出这个错误</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> pc = <span class="type">Computer</span>()  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">play</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">self</span>.pc.playGame(<span class="string">"SC2"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第二种方法举例，使用do…catch语句处理。在do范围里面，我们可以调用会产生错误的方法。接着的catch语句可以接上要处理的错误类型</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> pc = <span class="type">Computer</span>()  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">play</span><span class="params">()</span></span> &#123;  </span><br><span class="line">        <span class="keyword">do</span> &#123;  </span><br><span class="line">            <span class="keyword">try</span> <span class="keyword">self</span>.pc.playGame(<span class="string">"LOL"</span>)  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"have fun"</span>)  </span><br><span class="line">        &#125; <span class="keyword">catch</span> <span class="type">ComputerError</span>.<span class="type">NoGameError</span> &#123;  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"NoGameError"</span>)  </span><br><span class="line">        &#125; <span class="keyword">catch</span> <span class="type">ComputerError</span>.<span class="type">MemoryError</span> &#123;  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"MemoryError"</span>)  </span><br><span class="line">        &#125; <span class="keyword">catch</span> <span class="type">ComputerError</span>.<span class="type">HardDiskError</span> &#123;  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"HardDiskError"</span>)  </span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"other error"</span>,error)  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>值得注意的是最后一个catch。这里并没有加上要处理的错误。这的catch会捕捉所有类型的错误。<br>另外还有一个问题，如果不加上这个捕捉所有类型的catch语句。调用playGame的那句会报错说catch没有穷尽会抛出的错误。但是我只有三个错误，照理来讲应该是已经穷尽的了。不知道是Swift的问题，还是我代码哪里有问题。但如果把这个调用放到main.swift中去，也是只使用3个catch，就不会报错。搞不懂。<br>我现在的处理方式是把这个play方法继续写成一个可以抛出错误的方法。只处理自定义的三种错误。其他错误往上抛</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> pc = <span class="type">Computer</span>()  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">play</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;  </span><br><span class="line">        <span class="keyword">do</span> &#123;  </span><br><span class="line">            <span class="keyword">try</span> <span class="keyword">self</span>.pc.playGame(<span class="string">"LOL"</span>)  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"have fun"</span>)  </span><br><span class="line">        &#125; <span class="keyword">catch</span> <span class="type">ComputerError</span>.<span class="type">NoGameError</span> &#123;  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"NoGameError"</span>)  </span><br><span class="line">        &#125; <span class="keyword">catch</span> <span class="type">ComputerError</span>.<span class="type">MemoryError</span>&#123;  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"MemoryError"</span>)  </span><br><span class="line">        &#125; <span class="keyword">catch</span> <span class="type">ComputerError</span>.<span class="type">HardDiskError</span> &#123;  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"HardDiskError"</span>)  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第三种是使用try?或try!调用会抛出错误的函数。<br>在官方文档里面，它原意是使用try?去处理一个会抛出错误的方法的返回值，如果这个方法抛出错误，那么会得到nil。如果没有错误，那么将函数返回值包装成可选类型后返回</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myPC = <span class="type">Computer</span>()  </span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">try</span>? myPC.playGame(<span class="string">"War3"</span>)   <span class="comment">//这里playGame没有抛出错误，所以返回了Bool可选类型，值为true</span></span><br></pre></td></tr></table></figure><p>ry!的区别是它默认调用方法是不会报错的，如果调用的方法报错，那么会得到运行时错误。即使你将这个try!写到了一个会抛出错误的方法里面，它也不会向上抛出这个错误。而是直接崩溃。</p><p>try? 、try!   和try 三者的区别：</p><p>try在一个会抛出错误的方法里面，它会把产生的错误交由catch处理或者向上抛出。</p><p>try?是出错的时候返回一个nil，屏蔽错误。没错的话，将结果包装成一个可选类型返回。</p><p>try!是在没错的情况下返回函数返回值。出错的情况下直接崩溃。错误不会再交给catch处理或者向上抛出。</p><p>所以如果在do catch里面将try改为try?或者try!，那么会有一个警告说catch永远不会执行。</p><h1 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h1><blockquote><p>熟悉java的朋友应该知道finally语句。这个是在try..catch里面无论是否有错误，在退出try..catch范围的时候，最后都会执行finally范围内的代码。一般是用来做一些诸如关闭文件的工作。因为无论出不出错，最后都必须关闭打开的文件。<br>Swift也弄了一个defer语句，同样也是想在最后做这样的一些事情。但是这个defer远远没有finally那么好用。<br>先来开开defer的语法。学过java的朋友知道finally只能用在try..catch里面。但是defer可以不用在do..catch里面。并且defer里面不能用return、break或者抛出错误的语句。</p></blockquote><blockquote><p>下面是一个没有用在do..catch中的例子</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">defer</span> &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Close file"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Open file"</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Deal with file"</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">readFile()  </span><br><span class="line"><span class="comment">//打印  </span></span><br><span class="line"><span class="comment">//Open file  </span></span><br><span class="line"><span class="comment">//Deal with file  </span></span><br><span class="line"><span class="comment">//Close file</span></span><br></pre></td></tr></table></figure><blockquote><p>留意上面的打印顺序，可以看出defer中的语句是在最后才执行的。单从这里看，和设计初衷一致：在最后面才执行。<br>但是一旦将这个defer用到do..catch里面，你就会觉得很恶心。<br>我们先来看一个和我们想象中一致的代码，首先改写上面用到的Person类。我们的原意是这样的：Person的play方法调用了Computer的会产生错误的playGame方法。我们定义了一个result的可选变量，用于接收playGame方法的返回值。在退出do..catch的时候，会调用defer语句。我们在里面判断result是否为nil。然后输出心情。</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> pc = <span class="type">Computer</span>()  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">play</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;  </span><br><span class="line">        <span class="keyword">do</span> &#123;  </span><br><span class="line">            <span class="keyword">var</span> result: <span class="type">Bool</span>?  </span><br><span class="line">            <span class="keyword">defer</span> &#123;  </span><br><span class="line">                <span class="keyword">if</span> result != <span class="literal">nil</span> &#123;  </span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">"have fun"</span>)  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">"sad"</span>)  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            result = <span class="keyword">try</span> <span class="keyword">self</span>.pc.playGame(<span class="string">"LOL"</span>)  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"playGame"</span>)  </span><br><span class="line">        &#125; <span class="keyword">catch</span> <span class="type">ComputerError</span>.<span class="type">NoGameError</span> &#123;  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"NoGameError"</span>)  </span><br><span class="line">        &#125; <span class="keyword">catch</span> <span class="type">ComputerError</span>.<span class="type">MemoryError</span>&#123;  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"MemoryError"</span>)  </span><br><span class="line">        &#125; <span class="keyword">catch</span> <span class="type">ComputerError</span>.<span class="type">HardDiskError</span> &#123;  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"HardDiskError"</span>)  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后我们执行下面代码，因为默认的Computer类的hardDisk不足。所以会报MemoryError错误</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="type">Person</span>()  </span><br><span class="line"><span class="keyword">try</span> p.play()  </span><br><span class="line"><span class="comment">//打印  </span></span><br><span class="line"><span class="comment">//sad  </span></span><br><span class="line"><span class="comment">//MemoryError</span></span><br></pre></td></tr></table></figure><blockquote><p>注意打印顺序，可以看出defer是先与catch执行的。这个和java的finally是不一样的。finally是在catch执行完后执行。其次是playGame没有打印，说明报错之后的语句不会执行。<br>如果playGame的参数是“War3”，那么程序不会报错。输出是</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> playGame  </span><br><span class="line">have fun</span><br></pre></td></tr></table></figure><blockquote><p>从以上来看，似乎还是符合我们的原意。<br>但是当你把defer的位置改改，变为下面这样</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> pc = <span class="type">Computer</span>()  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">play</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;  </span><br><span class="line">        <span class="keyword">do</span> &#123;  </span><br><span class="line">            <span class="keyword">var</span> result: <span class="type">Bool</span>?  </span><br><span class="line">            result = <span class="keyword">try</span> <span class="keyword">self</span>.pc.playGame(<span class="string">"LOL"</span>)  </span><br><span class="line">            <span class="keyword">defer</span> &#123;  </span><br><span class="line">                <span class="keyword">if</span> result != <span class="literal">nil</span> &#123;  </span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">"have fun"</span>)  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">"sad"</span>)  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"playGame"</span>)  </span><br><span class="line">        &#125; <span class="keyword">catch</span> <span class="type">ComputerError</span>.<span class="type">NoGameError</span> &#123;  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"NoGameError"</span>)  </span><br><span class="line">        &#125; <span class="keyword">catch</span> <span class="type">ComputerError</span>.<span class="type">MemoryError</span>&#123;  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"MemoryError"</span>)  </span><br><span class="line">        &#125; <span class="keyword">catch</span> <span class="type">ComputerError</span>.<span class="type">HardDiskError</span> &#123;  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"HardDiskError"</span>)  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>你会发现输出只有一个MemoryError。也就是说当定义defer前面的语句报错之后，defer得不到执行。这样就要求这个defer必须写在一个合理的位置才行。</p></blockquote><h2 id="另外如果我们再改改上面的代码，使用try"><a href="#另外如果我们再改改上面的代码，使用try" class="headerlink" title="另外如果我们再改改上面的代码，使用try!"></a>另外如果我们再改改上面的代码，使用try!</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">你会发现输出只有一个<span class="type">MemoryError</span>。也就是说当定义<span class="keyword">defer</span>前面的语句报错之后，<span class="keyword">defer</span>得不到执行。这样就要求这个<span class="keyword">defer</span>必须写在一个合理的位置才行。</span><br><span class="line"></span><br><span class="line">另外如果我们再改改上面的代码，使用<span class="keyword">try</span>!</span><br></pre></td></tr></table></figure><blockquote><p>这时候什么都没有打印，程序直接崩溃掉了。这个defer的初衷完全不同。<br>Swift的错误处理也是近几个版本才出现的。估计以后会继续改进</p></blockquote>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
          <category> Error </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-Optional Chaining-可选链</title>
      <link href="/2017/12/01/Swift/Swift/Grammar/%E5%8F%AF%E9%80%89%E9%93%BE/"/>
      <url>/2017/12/01/Swift/Swift/Grammar/%E5%8F%AF%E9%80%89%E9%93%BE/</url>
      <content type="html"><![CDATA[<h1 id="可选链（Optional-Chaining"><a href="#可选链（Optional-Chaining" class="headerlink" title="可选链（Optional Chaining"></a>可选链（Optional Chaining</h1><blockquote><p>回顾一下可选类型，当你要使用可选类型的时候，首先必须要对其进行解包。<br>但是存在一个问题就是，如果对一个为nil的可选类型进行强制解包的话，那么会产生运行时错误。第一种解决办法就是使用if语句先判断这个可选类型是否为nil，然后在访问其属性或方法。但是十分繁琐。考虑一下这个可选类型里面访问的属性还是可选类型的情况吧，多几层的时候，if的层数惨不忍睹。<br>一个很好的解决办法就是利用可选链（Optional Chaining）<br>语法很简单，把中间需要解包的可选类型的强制解包符号!替换成？</p></blockquote><blockquote><p>伪代码例子  </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> 可选链返回值的解包 = 可选类型<span class="number">1</span>?.可选类型<span class="number">2</span>?.返回可选类型的方法<span class="number">1</span>?.可选类型<span class="number">3</span> &#123;  </span><br><span class="line">   <span class="comment">//&lt;span style="font-family: Arial, Helvetica, sans-serif;"&gt;可选链返回值&lt;/span&gt;不为nil  </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">   <span class="comment">//&lt;span style="font-family: Arial, Helvetica, sans-serif;"&gt;可选链返回值&lt;/span&gt;为nil  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解释：</p><ul><li>首先检测可选类型1是否为nil，如果不会nil，那么解包。</li><li>然后检查可选类型1的属性——可选类型2是否为nil，不为nil，解包。</li><li>然后调用可选类型2的一个方法。这个方法会返回一个可选类型.成这个可选类型为可选类型A吧。</li><li>然后再对这个可选类型A进行判断，如果不为nil，解包。</li><li>最后利用if语句对可选类型A的属性——可选类型3进行判断处理</li></ul></blockquote><blockquote><p>意点：</p><ul><li>1、如果前面的每一次判断有一个为nil了。那么这个可选链直接返回nil，不会再对后面的可选链进行处理。</li><li>2、可选链返回的类型是可选链中最后一个类型对应的可选类型。假设上面伪代码中最后一个可选类型3改为一个非可选类型3（比如Int），那么这个链返回的是其对应的可选类型Int?</li><li>3、可选链最后不能再用?进行解包，必须用!。但是用!就会产生当可选类型为nil时报错的情况。所以为了判断是否为nil，只能用if</li></ul></blockquote><blockquote><p>上面的伪代码是访问可选类型的例子。对于给可选链赋值的例子的伪代码如下</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  可选类型<span class="number">1</span>?.可选类型<span class="number">2</span>?.返回可选类型的方法<span class="number">1</span>?.类型<span class="number">3</span> = 赋值    <span class="comment">//这句中的类型3可以是可选类型也可以是非可选类型。赋值成功与否都不会报错。  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//借助if语句判断是否赋值成功  </span></span><br><span class="line"><span class="keyword">if</span> (可选类型<span class="number">1</span>?.可选类型<span class="number">2</span>?.返回可选类型的方法<span class="number">1</span>?.可选类型<span class="number">3</span> = 赋值 ) != <span class="literal">nil</span> &#123;  <span class="comment">//&lt;span style="color:#ff0000;"&gt;注意if中赋值语句的返回值是Void?&lt;/span&gt;  </span></span><br><span class="line">    <span class="comment">//赋值成功  </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="comment">//赋值失败  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>例子 </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPU</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getClockSpeed</span><span class="params">()</span></span> -&gt; <span class="type">Double</span>? &#123;  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.name != <span class="literal">nil</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.2</span>  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> cpu: <span class="type">CPU</span>?  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> <span class="built_in">c</span> = <span class="type">Computer</span>()  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">c</span>.cpu?.name = <span class="string">"fef"</span>)  <span class="comment">//这句可选链的类型是Void?，打印 nil  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">c</span>.cpu?.name)   <span class="comment">//这句可选链的类型是String?，打印 nil  </span></span><br><span class="line"><span class="built_in">c</span>.cpu = <span class="type">CPU</span>()  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">c</span>.cpu?.getClockSpeed()?.isZero)  <span class="comment">//这句可选链的类型是Bool? ,打印 nil  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">c</span>.cpu?.name = <span class="string">"Intel"</span>)    <span class="comment">//这句可选链的类型是Void?，打印 Optional(())  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">c</span>.cpu?.name)          <span class="comment">//这句可选链类型是String?，打印 Optional("Intel")  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">c</span>.cpu?.getClockSpeed()?.isZero)    <span class="comment">//这句可选链的类型是Bool? ,打印 Optional(false)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-ARC-自动引用计数</title>
      <link href="/2017/12/01/Swift/Swift/Grammar/ARC-%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
      <url>/2017/12/01/Swift/Swift/Grammar/ARC-%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="ARC-自动引用计数"><a href="#ARC-自动引用计数" class="headerlink" title="ARC 自动引用计数"></a>ARC 自动引用计数</h1><h2 id="Swift引入ARC"><a href="#Swift引入ARC" class="headerlink" title="Swift引入ARC"></a>Swift引入ARC</h2><blockquote><p>对于类实例，它可能存在被多个变量引用的情况<br>如果在还有变量引用的情况下释放了改实例的话，那么其他变量再尝试访问这个实例的方法或属性的时候，程序就会崩溃。所以必须确保在以后都没有变量使用这个实例的情况下，才能去释放这个实例<br>对于值类型（结构体等），因为不存在多个变量对应一个实例的情况，所以不会有上述问题<br>为了解决这个问题，Swift使用自动引用计数(ARC)来管理内存。它只对引用类型起作用，对于值类型不起作用</p></blockquote><h2 id="引用计数的概念"><a href="#引用计数的概念" class="headerlink" title="引用计数的概念"></a>引用计数的概念</h2><blockquote><p>当你给一个创建一个类实例，并且把这个类实例赋值给某个变量或常量的时候，那么这个变量或常量就“拥有”这个实例，我们称为有了一个“强引用”。<br>所谓的引用计数，就是这个实例被多少个常量或变量强引用了</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">deinit</span>&#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"deinit"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> a:<span class="type">Apple</span>! = <span class="type">Apple</span>()</span><br></pre></td></tr></table></figure><blockquote><p>上面这最后一句代码就是变量a对一个Apple类的实例有了一个强引用。这时候这个实例的引用计数为1。<br>因为类实例是引用类型，所以你可以把这个引用传递给其他的常量或变量</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = a  </span><br><span class="line"><span class="keyword">let</span> v = a</span><br></pre></td></tr></table></figure><blockquote><p>这时候这个实例就被三个变量或常量所引用，这个时候它的引用计数为3.<br>当你把其中的b设为nil的时候，引用计数就会变为2.<br>当该实例的引用计数变为0的时候，这个实例就会被销毁，销毁的时候就会调用它的deinit方法。注：因为上面用了常量，所以不能手动把常量设为nil，只能等这个常量离开作用域后被系统自动销毁。(如果你是在main.swift的全局中定义这些变量或常量的话，因为在main执行完之后才会释放这些变量或常量，所以不会打印deinit。但是你可以把他们放到一个函数里面，然后在main.swift里面调用这个函数。当这个函数执行完之后，这些变量或常量就会被释放。)</p></blockquote><blockquote><p>自动引用计数的规：</p></blockquote><ul><li><p>1、赋值给不加修饰符的常量和变量的时候，实例的引用计数加1。</p></li><li><p>2、当一个变量设为nil，或者变量(常量)离开作用域的时候，这个常量或变量所引用实例的引用计数减1。</p></li><li><p>3、当一个实例的引用计数为0的时候，它就会被销毁。</p></li></ul><p>但是上面看似简单的规则也会有很多问题。比如下面的循环引用问题。</p><p>先定义两个类，一个Telephone类和一个Person类。Telephone类有一个Person类的属性，Person类里面有一个Telephone类的属性</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Telephone</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> person: <span class="type">Person</span>?  </span><br><span class="line">    <span class="keyword">deinit</span>&#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Telephone deinit"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> telephone: <span class="type">Telephone</span>?  </span><br><span class="line">    <span class="keyword">deinit</span>&#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Person deinit"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>定义一个Person类的实例和一个Telephone类的实例。并对他们赋值</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="type">Person</span>()  </span><br><span class="line"><span class="keyword">var</span> telephone = <span class="type">Telephone</span>()  </span><br><span class="line">person.telephone = telephone  </span><br><span class="line">telephone.person = person</span><br></pre></td></tr></table></figure><blockquote><p>下面分析一下Person实例和Telephone实例的引用计数。</p></blockquote><blockquote><p>在定义Person实例的时候，赋值给了变量person，所以第一句代码后，Person实例的引用计数为1。同样第二句代码后，Telephone实例的引用计数也为1。</p></blockquote><blockquote><p>然后第三句代码把telephone赋值给了person.telephone。也就是person.telephone也对这个Telephone实例有了强引用，这时候Telephone实例的引用计数为2。</p></blockquote><blockquote><p>同样，第四局过后，Person实例的引用计数也为2。</p></blockquote><blockquote><p>现在的状态是一个Person实例强引用了一个Telephone实例，这个Telephone实例又强引用了这个Person实例。你强引用我，我强引用你。这样就成了一个循环引用。</p></blockquote><blockquote><p>接着执行下面代码，person变量和telephone变量释放对实例的强引用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> person = <span class="literal">nil</span>  </span><br><span class="line">telephone = <span class="literal">nil</span></span><br></pre></td></tr></table></figure><blockquote><p>但是Person实例中的telephone属性仍然强引用着Telephone实例。同样的Telephone实例的person属性也引用着Person实例。所以Person实例和Telephone实例的引用计数都为1。但此时我们已经没办法再访问Person和Telephone的实例了。同时又因为他们的引用计数都为1，系统也不会释放他们。这样就造成了内存泄露。</p></blockquote><blockquote><p>为了解决这种循环引用的问题，办法就是截断这个循环。<br>第一种笨笨的解决方法就是在你把person或telephone变量设为nil之前，把person.telephone或telephone.person设为nil。这样就手动切断了循环引用。<br>而通用的解决方法就是引用一个新概念——弱引用（Weak Reference）<br>弱引用和强引用最大区别就是：当你把一个实例赋值给一个弱引用变量的时候，这个变量的引用计数不会加1。<br>为了实现这一点，在定义变量的时候在最前面加上weak关键字。下面我们重新定义Person类和Telephone类</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Telephone</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> person: <span class="type">Person</span>?   <span class="comment">//把这个变量定义为了一个弱引用变量  </span></span><br><span class="line">    <span class="keyword">deinit</span>&#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Telephone deinit"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> telephone: <span class="type">Telephone</span>?  </span><br><span class="line">    <span class="keyword">deinit</span>&#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Person deinit"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后我们再次调用下面的代码</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> person: <span class="type">Person</span>? = <span class="type">Person</span>()  </span><br><span class="line"><span class="keyword">var</span> telephone: <span class="type">Telephone</span>? = <span class="type">Telephone</span>()  </span><br><span class="line">person!.telephone = telephone  </span><br><span class="line">telephone!.person = person     <span class="comment">//第4句  </span></span><br><span class="line">person = <span class="literal">nil</span>                 <span class="comment">// 执行完这句后打印  Person deinit  </span></span><br><span class="line">telephone = <span class="literal">nil</span>              <span class="comment">// 执行完这句后打印  Telephone deinit</span></span><br></pre></td></tr></table></figure><p>因为Telephone类里面的person属性是弱引用的，所以执行完了第4句之后，Telephone实例被telephone变量和person.telephone实例所引用，引用计数为2。而Person实例只被person变量所引用，引用计数为1.</p><p>当执行完person = nil 之后，person的引用计数就变为了0， 这个时候系统就会释放Person实例，这个过程中，person.telephone也会被释放，所以会导致Telephone实例的引用计数减1，变为1。</p><p>当执行完telephone = nil 之后，Telephone实例的引用计数变为0。系统释放Telephone实例。</p><p>关于这个弱引用再补充几点</p><p>第一、当一个弱引用变量所引用的实例被释放的时候，这个弱引用变量会被自动置为nil。</p><p>第二、因为第一条的内容，所以弱引用只能对变量使用，并且必须是可选类型。</p><p>第三、如果你在创建实例的时候就把它复制给一个弱引用变量，因为弱引用变量不会增加这个实例的引用计数，所以这个实例创建后立马就会被销毁。</p><p>第四、如果你将一个已经赋值的弱引用变量赋值给一个强引用变量(常量)，那么这个实例的引用计数会加1。</p><p>Unowned Reference</p><p>Unowned Reference和弱引用一样，不会对实例产生强引用。区别在于Unowned Reference假设它所指向的实例总是有值的。所以Unowned Reference一般不会设置为可选类型。但缺点就是当Unowned Reference所指向的实例被释放的时候，Unowned Reference变量不会自动置为nil。</p><p>语法就是将weak关键字替换为unowned。但一个变量永远不会为nil的时候，建议使用unowned修饰。</p><p>循环引用第二种情况——闭包循环引用</p><pre><code>在闭包的时候我们说过，闭包是引用类型，且会捕获值。设想，你把一个闭包声明为一个类的属性的时候，这个类的实例拥有了对这个闭包的强引用。此时如果你在这个闭包里面访问了这个类的其他属性(self.someProperty)或者方法(self.someMethod)的话。那么这个闭包就会捕获所访问的属性或方法，统称&quot;捕获了self&quot;。在访问实例的属性或方法的时候，必须使用self.的方式。Swift此意在提醒你可能会产生循环引用。</code></pre><p>那么这时候又是一个循环引用了，self引用闭包，闭包引用self。导致这个实例永远不会被释放。</p><p>下面定义一个有闭包的Person类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> class Person &#123;  </span><br><span class="line">    var name: String?  </span><br><span class="line">    lazy var printName: Void-&gt;Void = &#123;  </span><br><span class="line">        print(self.name)  </span><br><span class="line">    &#125;  </span><br><span class="line">    init(name: String)&#123;  </span><br><span class="line">        self.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    deinit&#123;  </span><br><span class="line">        print(&quot;Person deinit&quot;)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个闭包我们声明为了lazy类型，因为如果你想要在闭包里面访问到self的话，必须是在类初始化之后才行。而一般的属性是在类初始化的最开头阶段初始化的，所以不加lazy的闭包不能访问self关键字。上面的代码很明显闭包和类实例已经可能会产生循环引用了。为什么说可能呢？因为如果你一直没用到闭包的话，那么这个闭包就不会被初始化，所以也不会产生闭包对self的强引用，也就谈不上循环引用了。</p></blockquote><p>所以如果仅仅执行下面代码</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p: <span class="type">Person</span>? = <span class="type">Person</span>(name: <span class="string">"Kate"</span>)  </span><br><span class="line">p = <span class="literal">nil</span>  </span><br><span class="line"><span class="comment">//打印出 Person deinit</span></span><br></pre></td></tr></table></figure><blockquote><p>但是如果执行下面代码 </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var p: Person? = Person(name: &quot;Kate&quot;)  </span><br><span class="line">p?.printName()  </span><br><span class="line">p = nil  </span><br><span class="line">//打印出 Optional(&quot;Kate&quot;)</span><br></pre></td></tr></table></figure><blockquote><p>这时候因为循环引用导致Person实例不会被释放。<br>解决这个循环引用同样有两种方式。</p></blockquote><ul><li><p>第一种是在不需要这个实例的时候，将这个可能会引起循环引用的闭包设为nil。</p></li><li><p>第二种是利用闭包的捕获列表。下面是第二种方法的介绍</p></li></ul><blockquote><p>下面是语法定义例子，分别是有参数和没参数的闭包。在这种情况下，闭包对捕获的self不会产生强引用。（题外话，在OC中是通过定义另外一个对self的弱引用变量，然后将这个弱引用变量传递给block来实现的。）</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//有参数的情况  </span></span><br><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> printName: ((<span class="type">String</span>)-&gt;<span class="type">Void</span>)? = &#123;  </span><br><span class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>] (say: <span class="type">String</span>) -&gt; <span class="type">Void</span> <span class="keyword">in</span>  </span><br><span class="line">    <span class="built_in">print</span>(say,<span class="keyword">self</span>.name)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//没参数的情况  </span></span><br><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> printName2: (<span class="type">Void</span>-&gt;<span class="type">Void</span>)? = &#123;  </span><br><span class="line">    [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">self</span>!.name)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里就是用两个关键字weak和unowned将self修饰。weak和unowned的区别和之前所讲的是一样的。</p></blockquote>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-Initialization初始化&amp;Deinitialization析构</title>
      <link href="/2017/12/01/Swift/Swift/Grammar/Initialization%E5%88%9D%E5%A7%8B%E5%8C%96-%E6%9E%90%E6%9E%84/"/>
      <url>/2017/12/01/Swift/Swift/Grammar/Initialization%E5%88%9D%E5%A7%8B%E5%8C%96-%E6%9E%90%E6%9E%84/</url>
      <content type="html"><![CDATA[<h1 id="Initialization-初始化"><a href="#Initialization-初始化" class="headerlink" title="Initialization 初始化"></a>Initialization 初始化</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><blockquote><p>初始化，是当创建一个类、结构体、枚举类的时，完成存储属性的值的初始化，和其他一些初始化工作。准备好这个实例以供使用<br>反过来，当一个实例不再使用的时候，由析构过程释放这个实例所占用资源<br>完成初始化工作的一个方法一般称为初始化方法、构造器(Initializer)、构造方法等等<br>Swift中的构造器不需返回值，只是完成初始化工作。</p></blockquote><h2 id="类或结构体在创建的时候必须保证存储属性有初始化值"><a href="#类或结构体在创建的时候必须保证存储属性有初始化值" class="headerlink" title="类或结构体在创建的时候必须保证存储属性有初始化值"></a>类或结构体在创建的时候必须保证存储属性有初始化值</h2><blockquote><p>目的的实现可以通过在定义属性的时候给存储属性添加上默认值，也可以在构造器中赋值。并且在这两种情况中都不会触发属性的观察器。<br>官方文档建议我们在一个存储属性通常具有同一个初始值的时候，使用属性定义的方式添加初始值。</p></blockquote><blockquote><p>下面是这两种方法的代码<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> life: <span class="type">Int</span> = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">var</span> height: <span class="type">Double</span>  </span><br><span class="line">    <span class="keyword">init</span>()&#123;  </span><br><span class="line">        height = <span class="number">0</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>这里的init()方法就是构造器。注意它是不带func关键字的。而且也没有返回值。<br>以前创建一个实例的时候，都是使用“类名()”的形式，这其实就是调用了这个构造器。但是当时我们并没有写这个构造器，这是因为当一个类没有其他构造器的时候，编译器会自动生成这个默认的构造器。但是一旦有了其他的构造器，那么系统就不会再默认生成这个构造器。你也就再不能用“类名()”这种创建方法了。当然，当有其他构造器的时候，你也可以手动添加这个默认的构造器。</p></blockquote><h2 id="自定义构造器"><a href="#自定义构造器" class="headerlink" title="自定义构造器"></a>自定义构造器</h2><blockquote><p>可以定义构造器，可以传入自定义的参数列表来初始化类。自定义的构造器的外部参数名规则和方法不太一样，构造器的每一个参数都会生成和局部参数名一样的外部参数名。如果不想要外部参数名，还是可以用下划线取消</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> life: <span class="type">Int</span> = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">var</span> height: <span class="type">Double</span>  </span><br><span class="line">    <span class="keyword">init</span>()&#123;    <span class="comment">//注意，当有其他构造器的时候，系统不会再生成这个构造器，必须手动写出来  </span></span><br><span class="line">        height = <span class="number">0</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">init</span>(life: <span class="type">Int</span>, height: <span class="type">Double</span>) &#123;  </span><br><span class="line">        <span class="keyword">self</span>.life = life  </span><br><span class="line">        <span class="keyword">self</span>.height = height  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//可以这样使用自定义的构造器  </span></span><br><span class="line"><span class="keyword">var</span> a = <span class="type">Animal</span>(life: <span class="number">29</span>, height: <span class="number">1.2</span>)</span><br></pre></td></tr></table></figure><blockquote><p>再次提醒，当有类定义里面有自定义构造器的时候，不会再自动生成默认构造器。并且对于结构体也再不会自动生成遍历属性的构造器。<br>但是你可以将你自己的构造器写在扩展里面，这样就不会影响默认构造器的自动生成</p></blockquote><h2 id="构造器委托（Initializer-Delegation）"><a href="#构造器委托（Initializer-Delegation）" class="headerlink" title="构造器委托（Initializer Delegation）"></a>构造器委托（Initializer Delegation）</h2><blockquote><p>构造器委托，就是在一个构造器里面调用另外一个构造器，这样可以减少多余的代码。在构造器里面使用self.init语法来调用另外一个构造器，且这个语法只能在构造器里面使用。<br>构造器委托在值类型（结构体和枚举类）和类直接是不太一样的。因为类需要考虑到继承问题。<br>先来看值类型的构造器委托。这个很简单，调用另外一个构造器就行了。下面的例子虽然有点脱裤子放屁的感觉，但。。就是举个例子而已</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Apple</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> totalPrice: <span class="type">Double</span>  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">init</span>(totalPrice: <span class="type">Double</span>) &#123;  </span><br><span class="line">        <span class="keyword">self</span>.totalPrice = totalPrice  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">init</span>(kg: <span class="type">Double</span>, pricePerKg: <span class="type">Double</span>) &#123;  </span><br><span class="line">        <span class="keyword">let</span> totalPrice = kg * pricePerKg  </span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(totalPrice: totalPrice)   <span class="comment">//调用另外一个构造器  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类的继承和初始化"><a href="#类的继承和初始化" class="headerlink" title="类的继承和初始化"></a>类的继承和初始化</h1><blockquote><p>因为类可以继承，所以它的初始化规则就变得比结构体要复杂多了。<br>首先，类的构造器分为指定构造器（Designated Initializer） 和  便利构造器 （Convenience Initializer）<br>一个类通常具有很少数量（一般只有1个）的指定构造器。但是必须最少具有一个。<br>便利构造器是用来调用指定构造器完成初始化工作的。一个类可以不具有遍历构造器。<br>两种构造器的语法</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//指定构造器  </span></span><br><span class="line"><span class="keyword">init</span>(parameters) &#123;  </span><br><span class="line">    statements  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//便利构造器  </span></span><br><span class="line"><span class="keyword">convenience</span> <span class="keyword">init</span>(parameters) &#123;  </span><br><span class="line">    statements  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的构造器委托规则："><a href="#类的构造器委托规则：" class="headerlink" title="类的构造器委托规则："></a>类的构造器委托规则：</h2><ul><li><p>1、一个指定构造器必须调用它的直接父类的指定构造器</p></li><li><p>2、一个便利构造器必须调用同一个类的另外的构造器</p></li><li><p>3、一个便利构造器必须最终以调用指定构造器结束。</p></li></ul><blockquote><p>规则2和3连起来就是说，一个便利构造器可能会调用了另外一个便利构造器，然后这个构造器又调用了另外一个便利构造器….但是这个链的最后的一个便利构造器必须是调用指定构造器。<br>下面附上官方的图片。在图片上可以看到，三条规则总结起来就是：指定构造器往上调用，便利构造器平行调用且终结在指定构造器。</p></blockquote><p><img src="http://ozr735s7e.bkt.clouddn.com/Swift-Grammar-Initialization%E5%88%9D%E5%A7%8B%E5%8C%96&amp;Deinitialization%E6%9E%90%E6%9E%84-001.png" alt="001"></p><h2 id="类的初始化分为两阶段"><a href="#类的初始化分为两阶段" class="headerlink" title="类的初始化分为两阶段"></a>类的初始化分为两阶段</h2><h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><ul><li>1、一个指定构造器或便利构造器被调用</li><li>2、分配类实例所需的内存，但是内存没有初始化</li><li>3、这个类的指定构造器确保该类引入的新的存储属性都初始化。（因为便利构造器最终会到指定构造器）。</li><li>4、然后这个构造器调用父类的指定构造器完成和第三步同样的工作。</li><li>5、直到继承链的最顶部分。</li><li>6、这时候有的存储属性都有初始值了。</li></ul><h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><ul><li>1、从继承链的最顶部分出发。每个指定构造器具有了修改实例的权利。并且可以调用实例方法。</li><li>2、最后，这个初始化链条里面的便利构造器都具有了修改实例的权利。</li></ul><blockquote><p>遵循上面两个阶段的步骤，避免了当在初始化链后面的构造器修改了属性之后，又被前面的构造器修改属性的可能性。避免了使用没有经过初始化的属性的可能性。</p></blockquote><blockquote><p>为了确保两个阶段步骤的实施。编译器有4条检测规则，这四条规则决定了你在构造器里面某些代码的顺序。</p></blockquote><ul><li><p>1、在调用父类构造器之前，必须确保子类引入的新属性已经得到初始化。</p></li><li><p>2、子类必须在调用了父类的构造器之后，才能访问继承的属性。</p></li><li><p>3、便利构造器必须在调用了其他构造器之后，才能访问属性或调用实例方法。</p></li><li><p>4、在完成第一阶段之前（其实就是完成初始化本类定义的新属性，调用父类构造器），构造器不能调用实例方法，不能访问属性的值，不能把self当做值访问。但是可以用self.属性名的方式给属性赋值。</p></li></ul><blockquote><p>下面可以看看分别违反每个规则的例子</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> life: <span class="type">Int</span>  </span><br><span class="line">    <span class="keyword">var</span> height: <span class="type">Double</span>  </span><br><span class="line">    <span class="keyword">init</span>(getLife: <span class="type">Int</span>, getHeight: <span class="type">Double</span>) &#123;  </span><br><span class="line">        <span class="keyword">self</span>.life = getLife  </span><br><span class="line">        <span class="keyword">self</span>.height = getHeight  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>: <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>  </span><br><span class="line">    <span class="keyword">init</span>()&#123;  </span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(getLife: <span class="number">2</span>, getHeight: <span class="number">2.0</span>)  <span class="comment">//这句报错，违反第一条，必须先将本类引入的属性初始化才能调用父类构造器  </span></span><br><span class="line">        <span class="keyword">self</span>.name = <span class="string">"Larry"</span>                     <span class="comment">//所以这一句必须写在前面才没错  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, getLife: <span class="type">Int</span>, getHeight: <span class="type">Double</span>)&#123;  </span><br><span class="line">        <span class="keyword">self</span>.name = name  </span><br><span class="line">        <span class="keyword">self</span>.life = <span class="number">1</span>                            <span class="comment">//这句报错，违反第二条，必须调用了父类构造器之后才能访问继承的属性。  </span></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(getLife: getLife, getHeight: getHeight)    <span class="comment">//这句必须放在第二句之前才没错  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(getLife: <span class="type">Int</span>) &#123;  </span><br><span class="line">        <span class="keyword">self</span>.name = <span class="string">"Larry"</span>         <span class="comment">//这句报错，违反第三条，便利构造器里面必须调用了其他构造器之后才能访问属性  </span></span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>()                 <span class="comment">//这句应该放在前面  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">init</span>(getName: <span class="type">String</span>) &#123;  </span><br><span class="line">        <span class="keyword">self</span>.name = getName  </span><br><span class="line">        <span class="type">Dog</span>.sayHello()  </span><br><span class="line">        <span class="keyword">self</span>.printName()          <span class="comment">//这句报错，违反第四条，必须完成了阶段1才能调用实例方法或访问属性  </span></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(getLife: <span class="number">21</span>, getHeight: <span class="number">2.3</span>)   <span class="comment">//这句应该放在前面  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printName</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="keyword">self</span>.name)  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"hello"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h1><blockquote><p>以前说过，属性观察器在构造器里面给属性赋值的时候是不会被调用的。但是这个只针对于本类定义的属性。对于继承而来的属性，当已经经过父类的构造器完成初始化后，如果在子类里面修改了继承属性的值，那么就会触发父类观察器，如果你在子类里面也覆盖了这个观察器，那么子类和父类的观察器都会被调用</p></blockquote><blockquote><p>另外再看</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> life: <span class="type">Int</span> = <span class="number">0</span> &#123;  </span><br><span class="line">        <span class="keyword">willSet</span>&#123;  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"animial life newValue <span class="subst">\(newValue)</span>"</span>)  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">init</span>(getlife: <span class="type">Int</span>)&#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"animal life init <span class="subst">\(<span class="keyword">self</span>.life)</span>"</span>)  </span><br><span class="line">        <span class="keyword">self</span>.life = <span class="number">1</span>  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"animal life after assign <span class="subst">\(<span class="keyword">self</span>.life)</span>"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果我们调用下面的语句</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> a = <span class="type">Animal</span>(getlife: <span class="number">3</span>)  </span><br><span class="line"><span class="comment">//打印  </span></span><br><span class="line"><span class="comment">//animal life init 0  </span></span><br><span class="line"><span class="comment">//animal life after assign 1</span></span><br></pre></td></tr></table></figure><blockquote><p>注意一点，我们在init里面第一句已经用到了self。根据编译器规则第四条，不允许在属性没有初始化的前进行访问。从上面代码通过编译来看，这里编译器已经将属性初始化为定义时候的值了。如果你将定义时候的默认值删去，那么第一句就会报错<br>Swift默认是不继承父类的构造器的。<br>如果你想要和父类一样的构造器，那么必须自己写。如果你写的构造器（不管是指定还是便利）和父类的指定构造器一样，那么这个构造器前必须加上override关键字。如果你写的构造器和父类的便利构造器一样，那么不用加override，因为子类永远不能直接调用父类的便利构造器。<br>但是在某些情况下，子类可以自动继承父类构造器。<br>前提条件：子类新引入的属性都必须具有默认值</p></blockquote><ul><li>规则1：如果子类没有定义任何的指定构造器。那么子类自动继承父类所有的指定构造器。</li><li>规则2：如果子类实现了父类所有的指定构造器（可以通过规则1继承而来，也可以通过重写而来），那么子类自动继承父类所有的便利构造器。</li></ul><blockquote><p>例子</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> life: <span class="type">Int</span>  </span><br><span class="line">    <span class="keyword">var</span> height: <span class="type">Double</span>  </span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(getLife: <span class="type">Int</span>)&#123;  </span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(getLife: getLife, getHeight: <span class="number">0.0</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">init</span>(getLife: <span class="type">Int</span>, getHeight: <span class="type">Double</span>) &#123;  </span><br><span class="line">        <span class="keyword">self</span>.life = getLife  </span><br><span class="line">        <span class="keyword">self</span>.height = getHeight  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>: <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">"Larry"</span>  </span><br><span class="line">    <span class="comment">//    override init(getLife: Int, getHeight: Double)&#123;  </span></span><br><span class="line">    <span class="comment">//        super.init(getLife: getLife, getHeight:getHeight)  </span></span><br><span class="line">    <span class="comment">//    &#125;  </span></span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>无论上面Dog类里面注释的代码是否打开，Dog都继承了Animal的所有构造器</p></blockquote><h1 id="Failable-Initializers可失败的构造器"><a href="#Failable-Initializers可失败的构造器" class="headerlink" title="Failable Initializers可失败的构造器"></a>Failable Initializers可失败的构造器</h1><blockquote><p>Swift中有个概念，就是创建实例的时候如果条件不符合，可以返回一个nil对象。这类可以返回nil的构造器叫做可失败的构造器。语法是在init的前面加上一个？。当条件不满足的时候，你可以用 return nil结束构造方法。那么这时候得到的实例其实是一个nil，这里也说明了，可失败构造器返回的是可选类型。其实之前也说过，Swift的构造器是不需要返回值的。所以你成功的时候不需要写return什么东东。</p></blockquote><h2 id="值类型的可失败构造器"><a href="#值类型的可失败构造器" class="headerlink" title="值类型的可失败构造器"></a>值类型的可失败构造器</h2><blockquote><p>下面是structure的</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Apple</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> pricePerKg: <span class="type">Double</span>  </span><br><span class="line">    <span class="keyword">init</span>?(pricePerKg: <span class="type">Double</span>)&#123;  </span><br><span class="line">        <span class="keyword">if</span> pricePerKg &lt; <span class="number">0</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">self</span>.pricePerKg = pricePerKg  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">print</span>(<span class="type">Apple</span>(pricePerKg: <span class="number">2</span>))  </span><br><span class="line"><span class="built_in">print</span>(<span class="type">Apple</span>(pricePerKg: -<span class="number">2</span>))  </span><br><span class="line"><span class="comment">//打印  </span></span><br><span class="line"><span class="comment">//Optional(SwiftTest.Apple(pricePerKg: 2.0))  </span></span><br><span class="line"><span class="comment">//nil</span></span><br></pre></td></tr></table></figure><blockquote><p>接下来是枚举类的</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum FruitSet &#123;  </span><br><span class="line">    case apple, orange, banana  </span><br><span class="line">    init?(symbol: Character)&#123;  </span><br><span class="line">        switch symbol &#123;  </span><br><span class="line">        case &quot;a&quot;,&quot;A&quot; :  </span><br><span class="line">            self = .apple  </span><br><span class="line">        case &quot;o&quot;,&quot;O&quot; :  </span><br><span class="line">            self = .orange  </span><br><span class="line">        case &quot;b&quot;,&quot;B&quot; :  </span><br><span class="line">            self = .banana  </span><br><span class="line">        default :  </span><br><span class="line">            return nil  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">print(FruitSet(symbol: &quot;a&quot;))  </span><br><span class="line">print(FruitSet(symbol: &quot;e&quot;))  </span><br><span class="line">//打印  </span><br><span class="line">//Optional(SwiftTest.FruitSet.apple)  </span><br><span class="line">//nil</span><br></pre></td></tr></table></figure><blockquote><p>对应有默认值的枚举类，会自动生成一个init?(rawValue:)的构造器。如下</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">FruitSet</span> : <span class="title">Character</span></span>&#123;  </span><br><span class="line">    <span class="keyword">case</span> apple = <span class="string">"a"</span>, orange = <span class="string">"o"</span>, banana = <span class="string">"b"</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="type">FruitSet</span>(rawValue: <span class="string">"a"</span>))  </span><br><span class="line"><span class="built_in">print</span>(<span class="type">FruitSet</span>(rawValue: <span class="string">"e"</span>))</span><br></pre></td></tr></table></figure><h2 id="类的可失败构造器"><a href="#类的可失败构造器" class="headerlink" title="类的可失败构造器"></a>类的可失败构造器</h2><blockquote><p>有一个规则，就是必须在本类所有的属性（包括继承的）都赋值之后才可以返回nil</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> pricePerKg: <span class="type">Double</span>  </span><br><span class="line">    <span class="keyword">init</span>?(pricePerKg: <span class="type">Double</span>)&#123;  </span><br><span class="line">        <span class="keyword">if</span> pricePerKg &lt; <span class="number">0</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>              <span class="comment">//这句报错，所以你必须先初始化其他属性值  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">self</span>.pricePerKg = pricePerKg  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可失败初始化的传递过程"><a href="#可失败初始化的传递过程" class="headerlink" title="可失败初始化的传递过程"></a>可失败初始化的传递过程</h2><blockquote><p>一个可失败的构造器可以调用其他的构造器，无论是可失败的还是不会失败的。</p></blockquote><p>但是一个不可失败的构造器不能去调用一个可失败的构造器。如果去调用父类的可失败构造器，虽然用解包可以解决，但是一旦父类的可失败构造器返回了nil，那么程序直接崩溃</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>  </span><br><span class="line">    <span class="keyword">init</span>?(name: <span class="type">String</span>)&#123;  </span><br><span class="line">        <span class="keyword">self</span>.name = name  </span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span>: <span class="title">Fruit</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> pricePerKg: <span class="type">Double</span>  </span><br><span class="line">    <span class="keyword">init</span>(pricePerKg: <span class="type">Double</span>)&#123;  </span><br><span class="line">        <span class="keyword">self</span>.pricePerKg = pricePerKg  </span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">""</span>)!   <span class="comment">//利用解包调用了父类的可失败构造器，但是因为这样父类会返回一个nil，所以程序在这行会崩溃  </span></span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>?()&#123;  </span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(pricePerKg: <span class="number">3</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> i = <span class="type">Apple</span>(pricePerKg: <span class="number">3</span>)</span><br></pre></td></tr></table></figure><blockquote><p>同样的，可失败的构造器也可以被重写，你可以重写为不可失败的构造器。<br>但是不可失败的构造器不能覆盖为可失败的构造器。<br>你可以用!代替?来实现可失败构造器，那么这样得到的实例会自动解包。当然，存在nil报错的问题。记得处理。</p></blockquote><h1 id="必须构造器（Required-Initializers）"><a href="#必须构造器（Required-Initializers）" class="headerlink" title="必须构造器（Required Initializers）"></a>必须构造器（Required Initializers）</h1><blockquote><p>在构造器前面加上required关键字就行了。这样的构造器要求子类必须重写。子类重写这个构造器的时候，也必须加上required关键字。要求子类的子类也要重写这个构造器。<br>写了required后不用写override关键字。写了会有警告。</p></blockquote><blockquote><p>给属性默认值时使用闭包或函数</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">getprice</span><span class="params">()</span></span>-&gt;<span class="type">Double</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> pricePerKg: <span class="type">Double</span> = getprice()  </span><br><span class="line">    <span class="keyword">var</span> name = &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"apple"</span>  </span><br><span class="line">    &#125;()     <span class="comment">//留意这对小括号，没有的话那就是给属性赋值一个闭包了。  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> a = <span class="type">Apple</span>()  </span><br><span class="line"><span class="built_in">print</span>(a.pricePerKg,a.name)</span><br></pre></td></tr></table></figure><h1 id="析构器"><a href="#析构器" class="headerlink" title="析构器"></a>析构器</h1><blockquote><p>析构器，就是在一个实例再也不用到时候调用的方法。析构器里面完成一些清理工作或保存数据等等。析构器是系统自动调用的，不允许自行调用。</p></blockquote><blockquote><p>语法</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">deinit</span> &#123;  </span><br><span class="line">    <span class="comment">// perform the deinitialization  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-Inheritance-类继承基本用法</title>
      <link href="/2017/12/01/Swift/Swift/Grammar/Inheritance-%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/2017/12/01/Swift/Swift/Grammar/Inheritance-%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h1><p>.&gt;继承是类独有的，结构体和枚举类都不具有这个功能。<br>继承就好像子承父业一样，一个继承的类（称为子类subClass）可以获得被继承的类（称为父类superClass）的属性，方法和其他特性。</p><blockquote><p>子类可以重写父类的方法，也可以添加自己的属性，还可以为继承而来的属性添加观察器（对继承而来的存储和计算属性都可以）</p></blockquote><h1 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h1><blockquote><p>一个不继承自任何类的类称为基类。<br>在Swift中，是没有共同的终极父类的。oc和java都是有终级父类的</p></blockquote><blockquote><p>定义一个Animal基类</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">var</span> life : <span class="type">Int</span> = <span class="number">0</span>  </span><br><span class="line">     <span class="keyword">var</span> description: <span class="type">String</span>&#123;  </span><br><span class="line">         <span class="keyword">return</span> <span class="string">"An animal with a life of <span class="subst">\(life)</span>"</span>  </span><br><span class="line">     &#125;  </span><br><span class="line">       </span><br><span class="line">     <span class="function"><span class="keyword">func</span> <span class="title">makeSounds</span><span class="params">()</span></span> &#123;  </span><br><span class="line">       </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>继承语法</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  &lt;span style=<span class="string">"color:#ff0000;"</span>&gt;<span class="class"><span class="keyword">class</span> <span class="title">Dog</span>: <span class="title">Animal</span>&lt;/<span class="title">span</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name : <span class="type">String</span> = <span class="string">"larry"</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的Dog类继承自Animal类，并且添加了自己的name属性。我们可以修改一下dog继承的属性，然后打印一下 </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dog = <span class="type">Dog</span>()  </span><br><span class="line">dog.life = <span class="number">10</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"dog's life is"</span>,dog.life)  <span class="comment">//dog's life is 10</span></span><br></pre></td></tr></table></figure><h1 id="覆盖（override）父类属性"><a href="#覆盖（override）父类属性" class="headerlink" title="覆盖（override）父类属性"></a>覆盖（override）父类属性</h1><blockquote><p>对于继承而来的存储属性或者计算属性，我们可以通过重写这个属性的getter和setter方法来实现覆盖。下面是几条规则：</p></blockquote><ul><li><p>1、当你重写了setter方法的时候，一定要重写getter方法。但是可以只重写getter方法。</p></li><li><p>2、覆盖属性的时候，属性名和类型都必须和继承的属性一致才算覆盖。并且前面要加上override关键字。</p></li><li><p>3、你可以将继承的只读属性重写为读写属性，但是不能将继承的读写属性重写为只读属性。</p></li></ul><blockquote><p>下面重写Animal的description属性</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>: <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name : <span class="type">String</span> = <span class="string">"larry"</span>  </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;  </span><br><span class="line">        <span class="keyword">get</span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"It's a dog with the name of <span class="subst">\(name)</span>"</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="覆盖属性观察器"><a href="#覆盖属性观察器" class="headerlink" title="覆盖属性观察器"></a>覆盖属性观察器</h1><blockquote><p>规则：</p></blockquote><ul><li><p>1、不能对继承的常量，或者只读属性添加属性观察器</p></li><li><p>2、不能同时对一个继承属性同时添加属性观察器和setter方法。因为setter方法已经可以提供属性观察器的功能。</p></li><li><p>3、即使覆盖了之后，如果父类的该属性有观察器，那么当值修改的时候，父类的观察器也会被调用</p></li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Dog</span>: <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name : <span class="type">String</span> = <span class="string">"larry"</span>  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> life: <span class="type">Int</span> &#123;  </span><br><span class="line">        <span class="keyword">didSet</span>&#123;  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"The dog's life is <span class="subst">\(life)</span>"</span>)  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;  </span><br><span class="line">        <span class="keyword">get</span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"It's a dog with the name of <span class="subst">\(name)</span>"</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="覆盖父类方法"><a href="#覆盖父类方法" class="headerlink" title="覆盖父类方法"></a>覆盖父类方法</h1><blockquote><p>同样的，加上override后，重写父类方法就可以</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">makeSounds</span><span class="params">()</span></span> &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"wang! wang!"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="防止覆盖"><a href="#防止覆盖" class="headerlink" title="防止覆盖"></a>防止覆盖</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">用<span class="keyword">final</span>关键字去修饰就可以了。比如<span class="keyword">final</span> <span class="keyword">var</span>，<span class="keyword">final</span> <span class="function"><span class="keyword">func</span>， <span class="title">final</span> <span class="title">class</span> <span class="title">func</span>， <span class="title">final</span> <span class="title">subscript</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
          <category> Inheritance </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-Subscripts-下标</title>
      <link href="/2017/12/01/Swift/Swift/Grammar/Subscripts-%E4%B8%8B%E6%A0%87/"/>
      <url>/2017/12/01/Swift/Swift/Grammar/Subscripts-%E4%B8%8B%E6%A0%87/</url>
      <content type="html"><![CDATA[<h1 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h1><blockquote><p>所谓的下标，就是[]<br>在Array和Dictionary的时候就已经接触过了。它其实算一种特殊的方法，利用下标，我们可以将属性的getter和setter写在一起。而且还可以提供另外的一些功能。<br>String截串的时候无比麻烦,利用下标和扩展（Extension）封装后变得很简单。这个在讲到扩展的时候在写出来吧。<br>下标语法</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;  </span><br><span class="line">    <span class="keyword">get</span> &#123;  </span><br><span class="line">        <span class="comment">// return an appropriate subscript value here  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">set</span>(newValue) &#123;  </span><br><span class="line">        <span class="comment">// perform a suitable setting action here  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当然可以和计算属性一样将setter删去，变为只读。<br>下面举一个使用例子。假设在买橙子。下标表示你要买多少斤，下标能返回总共价格。 当对下标赋值的时候，表示买那么多斤的时候总共花了多少钱。然后修改了橙子的单价.<br>下标不止一个变量，还可以有多个变量。变量也可以是不同的类型</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Orange</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> pricePerKg: <span class="type">Double</span> = <span class="number">3</span>  </span><br><span class="line">    <span class="keyword">subscript</span>(kg: <span class="type">Double</span>, str: <span class="type">String</span>) -&gt; <span class="type">Double</span> &#123;  </span><br><span class="line">        <span class="keyword">get</span>&#123;  </span><br><span class="line">            <span class="built_in">print</span>(str)  </span><br><span class="line">            <span class="keyword">return</span> kg * pricePerKg  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">set</span>&#123;  </span><br><span class="line">            <span class="built_in">print</span>(str)  </span><br><span class="line">            <span class="keyword">self</span>.pricePerKg = newValue / kg  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> o = <span class="type">Orange</span>()  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"price of 10kg orange "</span>,o[<span class="number">10</span>,<span class="string">"buy 10 kg orange"</span>])  </span><br><span class="line">o[<span class="number">100</span>,<span class="string">"buy 100kg orange"</span>] =  <span class="number">250</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"price per kg when buying 100kg orange "</span>,o.pricePerKg)  </span><br><span class="line"><span class="comment">//打印  </span></span><br><span class="line"><span class="comment">//buy 10 kg orange  </span></span><br><span class="line"><span class="comment">//price of 10kg orange  30.0  </span></span><br><span class="line"><span class="comment">//buy 100kg orange  </span></span><br><span class="line"><span class="comment">//price per kg when buying 100kg orange  2.5</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-Method-方法</title>
      <link href="/2017/12/01/Swift/Swift/Grammar/Method-%E6%96%B9%E6%B3%95/"/>
      <url>/2017/12/01/Swift/Swift/Grammar/Method-%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h1><blockquote><p><strong>方法</strong> 其实就是函数，只不过方法是属于某个类、结构体、枚举类的函数<br>方法的定义和函数一样。调用通过点语法实现。注意，方法和属性不能同名。但是类型方法可以和实例方法重名</p></blockquote><h2 id="Instance-Methods实例方法"><a href="#Instance-Methods实例方法" class="headerlink" title="Instance Methods实例方法"></a>Instance Methods实例方法</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Video</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">play</span><span class="params">(videoName: String)</span></span> &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Now play"</span>,videoName)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> v = <span class="type">Video</span>()  </span><br><span class="line">v.play(<span class="string">"\"monkey king\""</span>)   <span class="comment">//打印 Now play "monkey king"</span></span><br></pre></td></tr></table></figure><blockquote><p>在实例方法里面具有 self 属性，该属性就是指这个实例本身。学习过java或OC的应该很熟悉。就是用来当参数名和属性名一样的时候，用来区分究竟是哪个变量。</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Video</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> videoName: <span class="type">String</span>?  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">play</span><span class="params">(videoName: String)</span></span> &#123;  </span><br><span class="line">        <span class="keyword">self</span>.videoName = videoName  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Now play"</span>,videoName)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> v = <span class="type">Video</span>()  </span><br><span class="line">v.play(<span class="string">"\"monkey king\""</span>)  </span><br><span class="line"><span class="built_in">print</span>(v.videoName!)  </span><br><span class="line"><span class="comment">//打印  </span></span><br><span class="line"><span class="comment">//Now play "monkey king"  </span></span><br><span class="line"><span class="comment">//"monkey king"</span></span><br></pre></td></tr></table></figure><blockquote><p>如果是对于结构体，因为它是值传递，所以一般方法里面如果和上面一样尝试修改存储属性的值的话，是不允许的。直接报错。<br>如果需要修改，那么可以在方法前面加上mutating关键字<br>changeVideo方法将整个self都赋值了一个新实例。<br>因为枚举类是不存在存储属性的，所以没有上面修改属性的情况。但是self关键字还是有的</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Video</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> videoName: <span class="type">String</span>?  </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">play</span><span class="params">(videoName: String)</span></span> &#123;  </span><br><span class="line">        <span class="keyword">self</span>.videoName = videoName  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Now play"</span>,videoName)  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">changeVideo</span><span class="params">(newVideo: String)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">self</span> = <span class="type">Video</span>(videoName: newVideo)  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> v = <span class="type">Video</span>()  </span><br><span class="line">v.play(<span class="string">"\"monkey king\""</span>)  </span><br><span class="line">v.changeVideo(<span class="string">"misson impossible"</span>)  </span><br><span class="line"><span class="built_in">print</span>(v.videoName!)  </span><br><span class="line"><span class="comment">//打印  </span></span><br><span class="line"><span class="comment">//Now play "monkey king"  </span></span><br><span class="line"><span class="comment">//misson impossible</span></span><br></pre></td></tr></table></figure><h2 id="Type-Methods类型方法"><a href="#Type-Methods类型方法" class="headerlink" title="Type Methods类型方法"></a>Type Methods类型方法</h2><blockquote><p>这个和类型属性一样，加上static或class就行了。class允许子类覆盖父类方法</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Video</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> videoName: <span class="type">String</span>?  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> playTime: <span class="type">Int</span> = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">play</span><span class="params">(videoName: String)</span></span> &#123;  </span><br><span class="line">        <span class="keyword">self</span>.videoName = videoName    <span class="comment">//这里是self指的是Video的实例  </span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Now play"</span>,videoName)  </span><br><span class="line">        <span class="type">Video</span>.playTime++  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">changeVideo</span><span class="params">(newVideo: String)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">self</span> = <span class="type">Video</span>(videoName: newVideo)  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">showPlayTime</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="keyword">self</span>.playTime)   <span class="comment">//注意这里的self是指Video这个结构体，而不是实例  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> v = <span class="type">Video</span>()  </span><br><span class="line"><span class="type">Video</span>.showPlayTime()  </span><br><span class="line">v.play(<span class="string">"\"monkey king\""</span>)  </span><br><span class="line"><span class="type">Video</span>.showPlayTime()  </span><br><span class="line"><span class="comment">//打印  </span></span><br><span class="line"><span class="comment">//0  </span></span><br><span class="line"><span class="comment">//Now play "monkey king"  </span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure><ul><li><p>注意，调用类型方法只能通过类名的点语法来实现，不能通过实例的点语法。这点和类型属性是一样的。</p></li><li><p>关于这个类型方法，需要注意里面的self和实例方法里面的self指向的不是用一个东西，前者是指类型本身，后者是指类型的实例。</p></li><li><p>所以在类型方法和实例方法里面访问类型变量和实例变量也有不同。在实例方法里面访问类型变量，需要加上类型前缀。 在类型方法里面访问类型变量，可以加上类型前缀，用self，或者不加前缀。在类型方法里面是不能访问实例变量的</p></li></ul>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-Properties-属性</title>
      <link href="/2017/12/01/Swift/Swift/Grammar/Properties-%E5%B1%9E%E6%80%A7/"/>
      <url>/2017/12/01/Swift/Swift/Grammar/Properties-%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<h1 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h1><blockquote><p>Swift中，属性大致分为两种，存储属性+计算属性</p></blockquote><h2 id="Stored-Properties存储属性"><a href="#Stored-Properties存储属性" class="headerlink" title="Stored Properties存储属性"></a>Stored Properties存储属性</h2><blockquote><p>存储属性:能保存数据的属性。枚举类、结构体、类都具有存储属性<br>存储属性可以设为var 或let。分别对应常量和变量</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CPU</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> clockSpeed = <span class="number">1.0</span>   <span class="comment">//变量  </span></span><br><span class="line">    <span class="keyword">let</span> coreNum = <span class="number">2</span>        <span class="comment">//常量  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>计算属性就是它本身不保存数据，而是通过处理其他的数据得到返回值。 结构体和类才具有计算属性<br>然后我们初始化一个CPU实例，但是这个实例我们设置为常量。这样会导致一个后果：对应值传递的结构体，当实例是常量的时候，即使存储属性是变量，也不能修改里面属性的值</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> cpu = <span class="type">CPU</span>(clockSpeed: <span class="number">3.2</span>)   <span class="comment">//注意到这个初始化方法只有一个参数，因为我们设置了coreNum为常量，并且给了初始值，所以构造方法会发生变化  </span></span><br><span class="line">cpu.clockSpeed = <span class="number">3.3</span>      <span class="comment">//这句会报错</span></span><br></pre></td></tr></table></figure><blockquote><p>然而对于引用传递的类来讲，即使实例是常量，里面设置为变量的存储属性还是可以更改值的</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Telephone</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> cpu = <span class="type">CPU</span>()  </span><br><span class="line">    <span class="keyword">var</span> screenSize: <span class="type">Int</span>?  </span><br><span class="line">    <span class="keyword">var</span> price: <span class="type">Int</span>?  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">let</span> myTelephont = <span class="type">Telephone</span>()  </span><br><span class="line">myTelephont.screenSize = <span class="number">4</span></span><br></pre></td></tr></table></figure><blockquote><p>懒加载存储属性<br>Swift需要保证一个类或结构体或枚举类在初始化之后，所以的存储属性都必须有初始值（除开可选类型）。所以当实例初始化完成以后，所以的存储属性都初始化了。但是有些时候某些存储属性不一定会用到，所以我们可以把这些存储属性设置为lazy存储属性。那么它在要用到的时候才会进行初始化。lazy存储属性只能是变量。而且在多线程调用的时候，如果lazy属性没有初始化，那么不能保证只会初始化一次</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">CPU</span> </span>&#123;  </span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> clockSpeed = <span class="number">1.0</span>  </span><br><span class="line">    <span class="keyword">let</span> coreNum = <span class="number">2</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> cpu = <span class="type">CPU</span>()  <span class="comment">//这时候clockSpeed还是为nil</span></span><br></pre></td></tr></table></figure><h2 id="Computed-Properties-计算属性"><a href="#Computed-Properties-计算属性" class="headerlink" title="Computed Properties 计算属性"></a>Computed Properties 计算属性</h2><blockquote><p>故名思议，它本身不保存数据，只是用其他数据得到返回值，或者当设置它的时候修改其他数据。下面的例子利用存储属性得到apple的总价。或者修改总价的时候修改重量</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Apple</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">let</span> pricePerKg = <span class="number">6.0</span>  </span><br><span class="line">    <span class="keyword">var</span> weight: <span class="type">Double</span>  </span><br><span class="line">    <span class="keyword">var</span> totalPrice: <span class="type">Double</span> &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> pricePerKg * weight  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">set</span>(newTotalPrice) &#123;  </span><br><span class="line">            weight = newTotalPrice / pricePerKg  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> apple = <span class="type">Apple</span>(weight: <span class="number">2.0</span>)  </span><br><span class="line"><span class="built_in">print</span>(apple.totalPrice)    <span class="comment">//12.0  </span></span><br><span class="line">apple.totalPrice = <span class="number">6.0</span>  </span><br><span class="line"><span class="built_in">print</span>(apple.weight)       <span class="comment">//1.0</span></span><br></pre></td></tr></table></figure><blockquote><p>算属性的setter方法新值自带一个默认名 newValue，所以上面的定义可以改为 </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Apple</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">let</span> pricePerKg = <span class="number">6.0</span>  </span><br><span class="line">    <span class="keyword">var</span> weight: <span class="type">Double</span>  </span><br><span class="line">    <span class="keyword">var</span> totalPrice: <span class="type">Double</span> &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> pricePerKg * weight  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">set</span> &#123;  </span><br><span class="line">            weight = newValue / pricePerKg  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以将计算属性的setter去掉，那么这个计算数据就变成了只读的。这时候还可以省去get关键字 </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Apple</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">let</span> pricePerKg = <span class="number">6.0</span>  </span><br><span class="line">    <span class="keyword">var</span> weight: <span class="type">Double</span>  </span><br><span class="line">    <span class="keyword">var</span> totalPrice: <span class="type">Double</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> pricePerKg * weight  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不要在计算属性的setter和getter里面获取该计算属性，这样会导致循环调用</li></ul><h2 id="Property-Observers属性观察器"><a href="#Property-Observers属性观察器" class="headerlink" title="Property Observers属性观察器"></a>Property Observers属性观察器</h2><blockquote><p>有了属性观察器，我们可以在属性被修改的时候做一些事情。注意的是对于非继承而来的计算属性，没有必要设置属性观察器，因为直接可以在计算属性的setter定义中完成这项功能。</p></blockquote><blockquote><p>属性观察器有两个方法<br>willSet 在属性将要赋值的时候调用，这时候属性的值还没改变<br>didSet在属性值被赋值完的时候就会调用。（即使是赋值和原来值一样的值）这时候属性的值已经改变。<br>willSet方法里面会传递新值过来，你可以自己定义这个新值的名称，如果不定义，会具有默认值newValue<br>didSet方法里面会传递属性的旧值过来，你可以自己定义这个旧值的名称，如果不定义，会具有默认值oldValue。如果你在didSet方法里面又对这个存储属性赋值，那么这个值会覆盖掉刚刚赋值的值。且不会导致循环调用。比如下面例子里面，当pricePerKg小于3的时候，会把它改为3</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Apple</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> pricePerKg = <span class="number">6.0</span> &#123;  </span><br><span class="line">        <span class="keyword">willSet</span>(priceNewValue)&#123;  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"In willSet, priceNewValue="</span>,priceNewValue)  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"In willSet, pricePerKg="</span>,pricePerKg)  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">didSet</span>&#123;  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"In didSet, oldValue="</span>,oldValue)  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"In didSet, pricePerKg="</span>,pricePerKg)  </span><br><span class="line">            <span class="keyword">if</span> pricePerKg &lt; <span class="number">3</span> &#123;  </span><br><span class="line">                pricePerKg = <span class="number">3</span>  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">var</span> weight: <span class="type">Double</span>  </span><br><span class="line">    <span class="keyword">var</span> totalPrice: <span class="type">Double</span> &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> pricePerKg * weight  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">set</span> &#123;  </span><br><span class="line">            weight = newValue / pricePerKg  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> apple = <span class="type">Apple</span>(pricePerKg: <span class="number">6.0</span>, weight: <span class="number">1.0</span>)  </span><br><span class="line">apple.pricePerKg = <span class="number">2.0</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"apple.pricePerKg="</span>,apple.pricePerKg)  </span><br><span class="line"><span class="comment">/* 输出 </span></span><br><span class="line"><span class="comment">In willSet, priceNewValue= 2.0 </span></span><br><span class="line"><span class="comment">In willSet, pricePerKg= 6.0 </span></span><br><span class="line"><span class="comment">In didSet, oldValue= 6.0 </span></span><br><span class="line"><span class="comment">In didSet, pricePerKg= 2.0 </span></span><br><span class="line"><span class="comment">apple.pricePerKg= 3.0 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Global-and-Local-Variables全局变量和局部变量"><a href="#Global-and-Local-Variables全局变量和局部变量" class="headerlink" title="Global and Local Variables全局变量和局部变量"></a>Global and Local Variables全局变量和局部变量</h2><blockquote><p>所谓的局部变量，就是定义在函数、方法、闭包、类型上下文里面的变量。<br>全局变量就是定义在函数、方法、闭包、类型上下文之外的变量。<br>局部变量和全局变量都称为存储变量。<br>在全局和局部范围内，都可以定义计算变量，或者为存储变量定义观察器</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> apple = <span class="type">Apple</span>(pricePerKg: <span class="number">6.0</span>, weight: <span class="number">1.0</span>) &#123;  <span class="comment">//为apple变量定义观察器  </span></span><br><span class="line"><span class="keyword">willSet</span> &#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"newApple"</span>,newValue)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">didSet</span>&#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"oldApple"</span>,oldValue)  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">apple = <span class="type">Apple</span>(pricePerKg: <span class="number">6.0</span>, weight: <span class="number">2.0</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> <span class="built_in">c</span>: <span class="type">Double</span> &#123;  <span class="comment">//定义一个计算变量  </span></span><br><span class="line"><span class="keyword">get</span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">9</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">set</span> &#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"In setter,"</span>,newValue)  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">c</span> = <span class="number">2</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">c</span>)  </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">newApple Apple(pricePerKg: 6.0, weight: 2.0) </span></span><br><span class="line"><span class="comment">oldApple Apple(pricePerKg: 6.0, weight: 1.0) </span></span><br><span class="line"><span class="comment">In setter, 2.0 </span></span><br><span class="line"><span class="comment">9.0 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>官方文档说全局变量常量都是懒加载，局部变量常量都不是懒加载</li></ul><h2 id="Type-Properties类型属性"><a href="#Type-Properties类型属性" class="headerlink" title="Type Properties类型属性"></a>Type Properties类型属性</h2><blockquote><p>所谓的类型属性，就是这个属性是属于这个类型的，即使这个类型由多个实例，也只会有一个类型变量。</p></blockquote><p>类型属性是懒加载的，而且必须在定义的时候给初始值。</p><p>一般是用static来定义类型属性。特别的，对应类的计算类型属性，还可以用class关键字定义，这样可以使得子类可以覆盖它。</p><p>注意类型属性访问的时候用的是类名，不能使用实例来访问</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">"Some value."</span>  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SomeEnumeration</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">"Some value."</span>  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">"Some value."</span>  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">27</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">overrideableComputedTypeProperty</span>: <span class="title">Int</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">107</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="type">SomeStructure</span>.storedTypeProperty)  </span><br><span class="line"><span class="comment">// prints "Some value."  </span></span><br><span class="line"><span class="type">SomeStructure</span>.storedTypeProperty = <span class="string">"Another value."</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="type">SomeStructure</span>.storedTypeProperty)  </span><br><span class="line"><span class="comment">// prints "Another value."  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">SomeEnumeration</span>.computedTypeProperty)  </span><br><span class="line"><span class="comment">// prints "6"  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">SomeClass</span>.computedTypeProperty)  </span><br><span class="line"><span class="comment">// prints "27"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-Classes/Structures类和结构体</title>
      <link href="/2017/11/29/Swift/Swift/Grammar/Classes-Structures%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2017/11/29/Swift/Swift/Grammar/Classes-Structures%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      <content type="html"><![CDATA[<h1 id="类和结构体简叙述"><a href="#类和结构体简叙述" class="headerlink" title="类和结构体简叙述"></a>类和结构体简叙述</h1><blockquote><p>Swift中，类和结构体是很相近的。所有下面类和结构体的实例都统称为实例。不再单独为类的实例称为对象。<br>和C或OC，不同，swift的类只写在一个文件里面。这点和java一样。</p></blockquote><h2 id="类和结构体的共同点："><a href="#类和结构体的共同点：" class="headerlink" title="类和结构体的共同点："></a>类和结构体的共同点：</h2><ul><li>1、能定义属性用来存储值</li><li>2、能定义方法实现功能</li><li>3、能定义下标来得到值</li><li>4、具有初始化构造器初始化实例</li><li>5、能被扩展</li><li>6、能实现协议</li></ul><h2 id="类比结构体多出来的特点："><a href="#类比结构体多出来的特点：" class="headerlink" title="类比结构体多出来的特点："></a>类比结构体多出来的特点：</h2><ul><li><p>1、能被继承</p></li><li><p>2、能在运行时使用类型转换判断一个实例是否为某个类</p></li><li><p>3、具有析构器</p></li><li><p>4、引用计数可以大于1，使得可以有多个引用指向同一个类的实例（注明：结构体是值传递，所有没有引用计数）</p></li></ul><blockquote><p>下面定义一个类和结构体，这里先提一下，类的每个属性都给了默认值，除了可选类型之外。这个是swift要求的，以后文章会详细讲到。</p></blockquote><p>struct CPU {<br>       var clockSpeed = 1.0 var coreNum = 4<br>        }<br> class Telephone {<br> var cpu = CPU()<br> // CPU()是CPU结构体的默认构造器。它生成一个CPU实例，以后构造器的文章详细讲这方面内容 var screenSize = 5.0 var price: Int? }<br>然后定义他们的实例</p><p>var myTelephone = Telephone() var newCPU = CPU()<br>注意结构体是值传递，而类是引用传递。下面的代码清楚说明了这个特点。</p><p>var myTelephone = Telephone()<br>var newCPU = CPU()<br> print(myTelephone.cpu.clockSpeed) //1.0 swift使用点语法来获得属性 newCPU.clockSpeed = 2.0 myTelephone.cpu = newCPU //给myTelephone一个新的CPU print(myTelephone.cpu.clockSpeed) //2.0 newCPU.clockSpeed = 2.2 print(myTelephone.cpu.clockSpeed) //2.0 赋值后修改newCPU并不影响myTelephone里面的CPU var cpu = myTelephone.cpu //取出一份CPU，但是是值传递 cpu.clockSpeed = 3.0 print(myTelephone.cpu.clockSpeed) //2.0 所以修改取出的cpu不影响myTelephone里面的 var yourTelephone = myTelephone // 定义一个yourTelephone，它指向myTelephone的同一个实例 yourTelephone.screenSize = 6.0 print(myTelephone.screenSize) //6.0 修改yourTelephone会影响myTelephone<br>Array，String，Dictionary都是值传递。这个和OC是不一样的。值得注意。</p><p>结构体自带一个遍历所有属性的构造器，但是类没有。</p><p>var cpu2 = CPU(clockSpeed: 3.3, coreNum: 8)</p><p>操作符  === 和 !==<br>===用来判断两个变量是否指向同一个类的实例。如果是返回true。</p><p>!==反之。指向不同实例，返回true。</p><p>而 == 是判断两个实例是否“相等”，这个相等的条件可以有类的定义者自己决定。</p>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-Garmmar-Enumerations枚举类</title>
      <link href="/2017/11/29/520/"/>
      <url>/2017/11/29/520/</url>
      <content type="html"><![CDATA[<h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><blockquote><p>Swift中的枚举和C中的枚举不一样,枚举类而不是枚举类型,它是值传递<br>在C中，枚举类型中的每一项都整形<br>然而在Swift中，你不必为每一项赋值。定义的时候所用的名字就是用来枚举的。当然也可以为枚举成员赋值，这个赋值不单单是整形，可以是Charater，String，浮点数。</p></blockquote><blockquote><p>定义一个枚举类型<br>注意首字母已经大写<br>分行或<br>一行，用逗号分隔</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Nameset</span></span>&#123;</span><br><span class="line"><span class="keyword">case</span>  <span class="type">LuGaygay</span></span><br><span class="line"><span class="keyword">case</span>  <span class="type">Liaoliao</span></span><br><span class="line"><span class="type">Case</span>  <span class="type">Ykk</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或 </span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Nameset</span></span>&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">LuGaygay</span>, <span class="type">Liaoliao</span>,<span class="type">Ykk</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="定义一个枚举变量"><a href="#定义一个枚举变量" class="headerlink" title="定义一个枚举变量"></a>定义一个枚举变量</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myName = <span class="type">Nameset</span>.<span class="type">Ykk</span></span><br><span class="line">或</span><br><span class="line">myName  = .<span class="type">Ykk</span></span><br></pre></td></tr></table></figure><h1 id="Associated-Value"><a href="#Associated-Value" class="headerlink" title="Associated Value"></a>Associated Value</h1><blockquote><p>用来给每一个枚举成员再定义一个补充值</p></blockquote><blockquote><p>品的条形码和二维码。条形码是由一串数字组成的，这个数字分为了4个部分。而二维码其实是用一串很长的字符来编码的。如果要把二位码和条形码封装成为一个枚举类型，为了更好地区别二者，我们可以加上associated value，定义如下</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Barcode</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">UPCA</span>(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>) <span class="comment">//条形码  </span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">QRCode</span>(<span class="type">String</span>)           <span class="comment">//二维码  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>定义Barcode变量，同是添加上associated value</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">var</span> productBarcode = <span class="type">Barcode</span>.<span class="type">UPCA</span>(<span class="number">8</span>, <span class="number">85909</span>, <span class="number">51226</span>, <span class="number">3</span>)  </span><br><span class="line">productBarcode = .<span class="type">QRCode</span>(<span class="string">"ABCDEFGHIJKLMNOP"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注意的一点是，如果你定义了associated value，那么在定义变量的时候就和前面的NameSet不太一样了。看下面的两句代码<br>b1是Barcode类型<br>b2是(String) -&gt; Barcode类型，一个函数类型</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> b1 = <span class="type">Barcode</span>.<span class="type">UPCA</span>(<span class="number">8</span>, <span class="number">85909</span>, <span class="number">51226</span>, <span class="number">3</span>)  </span><br><span class="line">  <span class="keyword">var</span> b2 = <span class="type">Barcode</span>.<span class="type">QRCode</span> </span><br><span class="line">``` </span><br><span class="line">&gt;以下戴拿  错误 不能将 <span class="type">Barcode</span>类型是值赋给 (<span class="type">String</span>)-&gt;<span class="type">Barcode</span>.</span><br><span class="line"></span><br><span class="line">这里就可以看出了，其实<span class="type">Barcode</span>.<span class="type">QRCode</span>(<span class="type">String</span>:)是一个构造函数，这里再次验证了swift中的枚举是一个类</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line"> b2 = <span class="type">Barcode</span>.<span class="type">QRCode</span>(<span class="string">"fef"</span>)  <span class="comment">//error</span></span><br></pre></td></tr></table></figure><blockquote><p>NameSet里面可以直接用.Tom之类来赋值,估计是定义associated value的时候，相当于把该枚举成员从一个值变为了构造方法。</p></blockquote><h1 id="switch语句来处理枚举类"><a href="#switch语句来处理枚举类" class="headerlink" title="switch语句来处理枚举类"></a>switch语句来处理枚举类</h1><blockquote><p>用swift强大的switch语句来处理枚举类，除了一般的枚举成员之外，对于带associated value 的成员，我们还可以得到associated value</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">NameSet</span> </span>&#123;  <span class="comment">//重新定义一个简单的枚举类  </span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Lucy</span>  </span><br><span class="line">    <span class="keyword">case</span> otherName(<span class="type">String</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> myName = <span class="type">NameSet</span>.<span class="type">Lucy</span>  </span><br><span class="line">myName = .otherName(<span class="string">"Alexs"</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">switch</span> myName &#123;  </span><br><span class="line"><span class="keyword">case</span> .<span class="type">Lucy</span>:  </span><br><span class="line">    <span class="built_in">print</span>(myName)  </span><br><span class="line"><span class="keyword">case</span> .otherName(<span class="keyword">var</span> inputName):  <span class="comment">//使用括号解包出associated value  </span></span><br><span class="line">    <span class="built_in">print</span>(inputName)     <span class="comment">//只有这句会打印出  Alexs  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>修改一下上面的switch如下<br>打印的是otherName</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">switch</span> myName &#123;  </span><br><span class="line"><span class="keyword">case</span> .<span class="type">Lucy</span>:  </span><br><span class="line">    <span class="built_in">print</span>(myName)  </span><br><span class="line"><span class="keyword">case</span> .otherName:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"otherName"</span>)  </span><br><span class="line"><span class="keyword">case</span> .otherName(<span class="keyword">var</span> inputName):  </span><br><span class="line">    <span class="built_in">print</span>(inputName)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//打印的是otherName</span></span><br></pre></td></tr></table></figure><blockquote><p>里可以看出，switch里面的.otherName和声明枚举变量时候的不同，这里已经是值NameSet的值了。而且上面的Switch也会有警告说最后一个case永远不能执行。括号只是用来解包出associated value，而不是构造方法<br>为了验证这一点，再改改上面代码</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> myName = <span class="type">NameSet</span>.<span class="type">Lucy</span>  </span><br><span class="line"><span class="keyword">switch</span> myName &#123;  </span><br><span class="line"><span class="keyword">case</span> .<span class="type">Lucy</span>(<span class="keyword">let</span> name):  </span><br><span class="line">    <span class="built_in">print</span>(name)  </span><br><span class="line"><span class="keyword">case</span> .otherName:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"otherName"</span>)  </span><br><span class="line"><span class="keyword">case</span> .otherName(<span class="keyword">var</span> inputName):  </span><br><span class="line">    <span class="built_in">print</span>(inputName)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line">你会发现这里打印了 ()，因为解包<span class="type">Lucy</span>没有得到值</span><br></pre></td></tr></table></figure><blockquote><p>switch语句，之前说过只有穷尽枚举的时候才不需要default选项。上面的例子中因为把NameSet里面所有可能都枚举了，所以不需要default选项</p></blockquote><h1 id="Raw-Value"><a href="#Raw-Value" class="headerlink" title="Raw Value"></a>Raw Value</h1><blockquote><p>这个就是对每一项枚举成员绑定一个值，好比是C里面的枚举成员都是一个整形<br>如果需要Raw Value，必须在声明枚举类的时候加上raw value 的类型</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">enum</span> <span class="title">ASCIIControlCharacter</span>: <span class="title">Character</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">Tab</span> = <span class="string">"\t"</span>  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">LineFeed</span> = <span class="string">"\n"</span>  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">CarriageReturn</span> = <span class="string">"\r"</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>和C有默认的raw value一样，swift的枚举类也有默认的raw value<br>但是不是任何类型的raw value 都有默认值<br>假如你raw value的类型是Character，那么就不存在默认raw value，每个枚举成员的默认值都必须由你自己定义<br>如果类型是Int，那么默认值第一个是0，后面的一项都前一项加1.看下面例子就明白了</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">enum</span> <span class="title">NameSet</span>: <span class="title">Int</span></span>&#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">Lucy</span>      <span class="comment">//0  </span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Tom</span> = <span class="number">3</span>   <span class="comment">//3  </span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Kate</span>      <span class="comment">//4  </span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Angle</span> = <span class="number">66</span>  <span class="comment">//66  </span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Alex</span>      <span class="comment">//67  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果类型是String，那么默认值就是你的枚举成员的名字</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">NameSet</span>: <span class="title">String</span></span>&#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">Lucy</span>       <span class="comment">//Lucy  </span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Tom</span> = <span class="string">"T"</span>  <span class="comment">//T  </span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Kate</span>       <span class="comment">//Kate  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果有raw value，就可以用raw value来定义枚举变量 </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> myName = <span class="type">NameSet</span>(rawValue: <span class="string">"Lucy"</span>)   <span class="comment">//注意这里返回的是一个可选类型，因为这个构造方法是一个可失败的构造方法。具体看后面的类构造的文章。  </span></span><br><span class="line"><span class="built_in">print</span>(myName!.rawValue)      <span class="comment">//这里我就没用if做判断了，直接强制解包</span></span><br></pre></td></tr></table></figure><blockquote><p>递归enum<br>就是在enum的枚举成员的associated value声明为本枚举类,然后使用递归函数。<br>在声明associated value为自己枚举类的时候，需要加上indirect关键字。这个关键字可以加在每个case的前面，也可以加在enum的前面。后一种方法对里面所有的case都起效。但是并不要求所有case都有本枚举类作为associated value<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">indirect</span> <span class="class"><span class="keyword">enum</span> <span class="title">ArithmeticExpression</span> </span>&#123;  <span class="comment">//使用第二种indirect。定义了一个数学表达式。  </span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Number</span>(<span class="type">Int</span>)  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">Addition</span>(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">Multiplication</span>(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">evaluate</span><span class="params">(expression: ArithmeticExpression)</span></span> -&gt; <span class="type">Int</span> &#123;   <span class="comment">//这个函数运算表达式  </span></span><br><span class="line">    <span class="keyword">switch</span> expression &#123;  </span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Number</span>(<span class="keyword">let</span> value):  </span><br><span class="line">        <span class="keyword">return</span> value  </span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Addition</span>(<span class="keyword">let</span> <span class="keyword">left</span>, <span class="keyword">let</span> <span class="keyword">right</span>):  </span><br><span class="line">        <span class="keyword">return</span> evaluate(<span class="keyword">left</span>) + evaluate(<span class="keyword">right</span>)  </span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Multiplication</span>(<span class="keyword">let</span> <span class="keyword">left</span>, <span class="keyword">let</span> <span class="keyword">right</span>):  </span><br><span class="line">        <span class="keyword">return</span> evaluate(<span class="keyword">left</span>) * evaluate(<span class="keyword">right</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="comment">// evaluate (5 + 4) * 2  </span></span><br><span class="line"><span class="keyword">let</span> five = <span class="type">ArithmeticExpression</span>.<span class="type">Number</span>(<span class="number">5</span>)  </span><br><span class="line"><span class="keyword">let</span> four = <span class="type">ArithmeticExpression</span>.<span class="type">Number</span>(<span class="number">4</span>)  </span><br><span class="line"><span class="keyword">let</span> sum = <span class="type">ArithmeticExpression</span>.<span class="type">Addition</span>(five, four)  </span><br><span class="line"><span class="keyword">let</span> product = <span class="type">ArithmeticExpression</span>.<span class="type">Multiplication</span>(sum, <span class="type">ArithmeticExpression</span>.<span class="type">Number</span>(<span class="number">2</span>))  </span><br><span class="line"><span class="built_in">print</span>(evaluate(product))  </span><br><span class="line"><span class="comment">// prints "18"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-Closures闭包</title>
      <link href="/2017/11/27/Swift/Swift/Grammar/Closures%E9%97%AD%E5%8C%85/"/>
      <url>/2017/11/27/Swift/Swift/Grammar/Closures%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><blockquote><p>闭包可以看做是匿名的函数</p></blockquote><h2 id="回想一下函数作为参数的情况"><a href="#回想一下函数作为参数的情况" class="headerlink" title="回想一下函数作为参数的情况"></a>回想一下函数作为参数的情况</h2><blockquote><p>定义一个函数，它最后的参数是一个函数类型</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doMath</span><span class="params">(first: Int, second: Int, mathFunc: <span class="params">(Int, Int)</span></span></span> -&gt; <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"mathFunc ="</span>,mathFunc(first,second))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>定义一个函数，它有两个整形参数，并有一个整形返回值</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(first: Int, <span class="number">_</span> second: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first + second</span><br></pre></td></tr></table></figure><blockquote><p>调用第一个函数，将第二个函数作为参数传入</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">doMath(<span class="number">1</span>, second: <span class="number">3</span>, mathFunc: add)</span><br></pre></td></tr></table></figure><blockquote><p>打印</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mathFunc = 4</span><br></pre></td></tr></table></figure><blockquote><p>如果我们想用doMath实现两个数相减的方法，那么必须再写定义一个sub函数，然后将其作为参数传入。这样在功能多了之后会显得很麻烦，一堆函数，而所以有了闭包这个概念</p></blockquote><h2 id="闭包的语法"><a href="#闭包的语法" class="headerlink" title="闭包的语法"></a>闭包的语法</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&#123; (参数列表) -&gt; 返回类型 <span class="keyword">in</span> </span><br><span class="line"></span><br><span class="line">      <span class="comment">//闭包体</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有了闭包，我们可以将上面的代码改为</p></blockquote><blockquote><p>定义一个函数，它最后的参数是一个函数类型</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doMath</span><span class="params">(f:Int,s:Int,mathFunc:<span class="params">(Int,Int)</span></span></span>-&gt;)&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"mathFunc = "</span>,mathunc(first,second))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>调用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">doMath(<span class="number">1</span>, second: <span class="number">3</span>, mathFunc: &#123;(f: <span class="type">Int</span>, s: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> f + s</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>还是很麻烦是吧？ 别忘了 <strong>Swift有类型推断功能</strong>，所以我们可以继续简化上面的闭包部分代码 </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">doMath(<span class="number">1</span>, second: <span class="number">3</span>, mathFunc: &#123;f, s <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> f + s</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>对应只有一行代码的闭包，return关键字还可以省略</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">doMath(<span class="number">1</span>, second: <span class="number">3</span>, mathFunc: &#123;f, s <span class="keyword">in</span> f + s &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>此外，闭包对参数提供了默认名字，依次为 $0,$1,$2….所以上面的闭包仍可以简化</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">doMath(<span class="number">1</span>, second: <span class="number">3</span>, mathFunc: &#123;$<span class="number">0</span> + $<span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>对于闭包在参数列表最后一项的情况，可以将闭包写到小括号外部，并且可以省略掉外部参数名</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> doMath(<span class="number">1</span>, second: <span class="number">3</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> f = $<span class="number">0</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> f + $<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Autoclosures"><a href="#Autoclosures" class="headerlink" title="Autoclosures"></a>Autoclosures</h1><blockquote><p>姑且叫自动打包吧。用大括号括起来就好，编译器自动判断这个大括号里面的是什么返回类型。但是有时候不准确，需要自己写。下面是这个概念的解释，其实也是一种定义闭包变量的方法</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t = &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(t())</span><br></pre></td></tr></table></figure><blockquote><p>定义了一个Void-&gt;Void类型的闭包。因为没有参数，所以可以省略参数列表和in关键字。如果有参数的话，就不能省略in关键字。 </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b: <span class="type">Void</span>-&gt;<span class="type">Int</span> = &#123;  <span class="comment">//定义了一个类型为 Void-&gt;Int的闭包</span></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">    i++</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为闭包其实就是函数，调用这个闭包就和调用函数一样。但是有区别的就是闭包都是没有外部外部参数名，调用的时候不要把内部参数名但做外部参数名使用。</p></blockquote><blockquote><p>有时候函数需要传递一个闭包的时候，可以在调用的时候使用大括号将一段代码生成为闭包</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b: <span class="type">Void</span>-&gt;<span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doClosures</span><span class="params">(<span class="built_in">c</span>: Void-&gt;Void)</span></span> &#123;</span><br><span class="line">    <span class="built_in">c</span>()</span><br><span class="line">&#125;</span><br><span class="line">doClosures(&#123;b()&#125;)  <span class="comment">//虽然b是一个Void-&gt;Int的闭包，但是其调用再封装之后变为了Void-&gt;Void的闭包</span></span><br><span class="line">doClosures(&#123;    </span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">3</span></span><br><span class="line">    i++</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>此外，可以在函数参数列表里面使用@autoclosure关键字，这样就不用使用大括号封装了。但是对于多句的代码情况不行（上面的第二种），有时候自动封装也会出错，比如用上面的第一种情况，它把b()看做了Int，然后报错。需要将返回类型重新定义一下 </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b: <span class="type">Void</span>-&gt;<span class="type">Void</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">    i++</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment">//    return i</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doClosures</span><span class="params">(@autoclosure <span class="built_in">c</span>: Void-&gt;Void)</span></span> &#123;   <span class="comment">//或者不改b的类型，将这里的c的类型改为 Void-&gt;Int也可以</span></span><br><span class="line">    <span class="built_in">c</span>()</span><br><span class="line">&#125;</span><br><span class="line">doClosures(b())</span><br></pre></td></tr></table></figure><blockquote><p>如果想要自动封装的闭包可以在doClosures函数的作用域以外使用，那么加上escaping关键字。这个关键字只能用在@autoclosure后面</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b: <span class="type">Void</span>-&gt;<span class="type">Void</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">    i++</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> t: (<span class="type">Void</span>-&gt;<span class="type">Void</span>)?</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doClosures</span><span class="params">(@autoclosure<span class="params">(escaping)</span></span></span> <span class="built_in">c</span>: <span class="type">Void</span>-&gt;<span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="built_in">c</span>()</span><br><span class="line">    t = <span class="built_in">c</span>  <span class="comment">//将自动封装的c赋值给外部变量t</span></span><br><span class="line">&#125;</span><br><span class="line">doClosures(b())</span><br><span class="line">t!()</span><br></pre></td></tr></table></figure><blockquote><p>闭包的值捕获<br>在生成一个闭包的时候，闭包会将它用到的参数和变量都保存一份。提醒一下，其实闭包就是函数</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">giveMeFunc2</span><span class="params">(step: Int)</span></span> -&gt; (<span class="type">Void</span> -&gt; <span class="type">Int</span>)? &#123;</span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123; total += step; <span class="keyword">return</span> total &#125;</span><br><span class="line">    <span class="keyword">return</span> add</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的函数里面生成了嵌套函数，通过输入不同的符号，返回不同的函数。这里有两个变量需要注意，一个是total，一个是step。当生成嵌套函数的时候，嵌套函数会将这两个变量都copy一份，然后保存起来。下面是对上面代码的一个使用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">上面的函数里面生成了嵌套函数，通过输入不同的符号，返回不同的函数。这里有两个变量需要注意，一个是total，一个是step。当生成嵌套函数的时候，嵌套函数会将这两个变量都copy一份，然后保存起来。下面是对上面代码的一个使用</span><br></pre></td></tr></table></figure><blockquote><p>可以看到，f1和f2的total和step是不会相互干涉的。</p></blockquote><p>再来看看这个值捕获的时间，看下面代码。这里可以看到，值捕获是发生在返回之前。这个和OC的block是一样的</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">giveMeFunc2</span><span class="params">(step: Int)</span></span> -&gt; (<span class="type">Void</span> -&gt; <span class="type">Int</span>)? &#123;</span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123; total += step; <span class="keyword">return</span> total &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"before +100"</span>,add())  <span class="comment">// total = 0</span></span><br><span class="line">    total += <span class="number">100</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"after +100"</span>,add())  <span class="comment">// total = 100</span></span><br><span class="line">    <span class="keyword">return</span> add</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 = giveMeFunc2(<span class="number">1</span>)! <span class="comment">//得到一个函数，它会将传入的参数累加，并且每次调用都会加上一次step</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"f1="</span>,f1())  <span class="comment">// 103</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"f1="</span>,f1())  <span class="comment">// 104</span></span><br></pre></td></tr></table></figure><blockquote><p>看到这里，可能大家会以为这个值捕获和OC的block差不多，但是其实差远了。这个值捕获的时间很有区别。这里明显的一点就是我们在函数内部改变外部变量total的时候，没有加任何修饰符，OC里面必须加上__block，要么就是对全局变量进行修改。</p></blockquote><blockquote><p>我们先看一段OC代码</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">int t =<span class="number">1</span>;</span><br><span class="line">int(^b)() = ^() &#123; <span class="keyword">return</span> t; &#125;;</span><br><span class="line">t = <span class="number">3</span>;</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">"%d"</span>,b()); <span class="comment">//输出1，理由就不多说了。</span></span><br><span class="line"></span><br><span class="line">假如我们把t改为__block。那么将会输出<span class="number">3</span>。改为<span class="keyword">static</span>同样的效果。</span><br><span class="line"></span><br><span class="line">__block int t =<span class="number">1</span>;</span><br><span class="line">int(^b)() = ^() &#123;  <span class="keyword">return</span> t;   &#125;;</span><br><span class="line">t = <span class="number">3</span>;</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">"%d"</span>,b());  <span class="comment">//3</span></span><br></pre></td></tr></table></figure><blockquote><p>来看OC和swift中两段很类似的代码 </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//OC</span><br><span class="line">typedef int(^BLOCK)(void);</span><br><span class="line">BLOCK OCFunc (int step) &#123;</span><br><span class="line">    __block int total = 0;</span><br><span class="line">    BLOCK b = ^() &#123; total +=step; return total; &#125;;</span><br><span class="line">    step = 100;</span><br><span class="line">    NSLog(@&quot;before +100,%d&quot;,b());  //1</span><br><span class="line">    total +=100;</span><br><span class="line">    NSLog(@&quot;after +100,%d&quot;,b());   //102</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br><span class="line">//在main方法里面调用</span><br><span class="line">BLOCK b = OCFunc(1);</span><br><span class="line">NSLog(@&quot;%d&quot;,b());  // 103</span><br><span class="line">NSLog(@&quot;%d&quot;,b());  // 104</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swiftFunc</span><span class="params">(<span class="keyword">var</span> step: Int)</span></span> -&gt; <span class="type">Void</span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> b: <span class="type">Void</span> -&gt; <span class="type">Int</span> = &#123; <span class="type">Void</span> <span class="keyword">in</span> total += step; <span class="keyword">return</span> total &#125;</span><br><span class="line">    step = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"before +100,"</span>,b())  <span class="comment">// 100</span></span><br><span class="line">    total+=<span class="number">100</span>                 <span class="comment">// total = 200</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"after +100,"</span>,b())   <span class="comment">//300</span></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> d = swiftFunc(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"d="</span>,d())   <span class="comment">//400</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"d="</span>,d())   <span class="comment">//500</span></span><br></pre></td></tr></table></figure><blockquote><p>这里可以看到，OC中的step在block定义的时候就绑定了，后面在更改step的值也不影响block。但是在swift中，step仍然是可以改变的，直到step离开作用域后，闭包才将其捕获。</p></blockquote><p>如果要OC中产生同样的效果，只需定义一个<strong>block变量，如下。可以这么看，Swift中的变量默认都是</strong>block的</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//OC</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>(^BLOCK)(<span class="keyword">void</span>);</span><br><span class="line">BLOCK OCFunc (<span class="keyword">int</span> step) &#123;</span><br><span class="line">    __block <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    __block <span class="keyword">int</span> step2 = step;</span><br><span class="line">    BLOCK b = ^() &#123; total +=step2; <span class="keyword">return</span> total; &#125;;</span><br><span class="line">    step2 = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"before +100,%d"</span>,b());  <span class="comment">//100</span></span><br><span class="line">    total +=<span class="number">100</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"after +100,%d"</span>,b());   <span class="comment">//300</span></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在main方法里面调用</span></span><br><span class="line">BLOCK b = OCFunc(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,b());  <span class="comment">//400</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,b());  <span class="comment">//500</span></span><br></pre></td></tr></table></figure><blockquote><p>这个值捕获和OC的block一样，也会产生循环引用问题。OC里面是使用__weak来解决，这里差不多，它可以在参数列表前面加上捕获列表，并且对捕获类别的参数进行权限控制，附上一个官方例子，以后写ARC的时候详细讲</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">lazy</span> <span class="keyword">var</span> someClosure: (<span class="type">Int</span>, <span class="type">String</span>) -&gt; <span class="type">String</span> = &#123;</span><br><span class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>, <span class="keyword">weak</span> delegate = <span class="keyword">self</span>.delegate!] (index: <span class="type">Int</span>, stringToProcess: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// closure body goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-流程控制语句</title>
      <link href="/2017/11/24/Swift/Swift/Grammar/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
      <url>/2017/11/24/Swift/Swift/Grammar/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
      <content type="html"><![CDATA[<h1 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if else语句"></a>if else语句</h1><blockquote><p> if语句<br>if语句和其他语言中的使用是一样的，只是语法稍有不同<br>首先,是不用括号<br>其次,是即使是if后面只有一条语句，也必须加上大括号</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]</span><br><span class="line"><span class="keyword">if</span> array1.<span class="built_in">count</span> &gt; <span class="number">1</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"array1 is not empty"</span>)  <span class="comment">//这句会打印出来</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"array1 is empty"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>f语句可以用来检测可选类型是否为空</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str : <span class="type">String</span>?</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> s = str &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"str is not nil"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"str is nil"</span>) <span class="comment">//这句会打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h1><blockquote><p>已经移除</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">var</span> index = <span class="number">0</span>; index &lt; <span class="number">3</span>; index++ &#123; <span class="comment">//已经移除</span></span><br><span class="line">    <span class="built_in">print</span>(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="for-in-语句"><a href="#for-in-语句" class="headerlink" title="for-in 语句"></a>for-in 语句</h1><blockquote><p>尤其是用来遍历集合</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>...<span class="number">3</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的只能是每次加1，但是现在可能有需求每次增加的不是1，所以现在有了这个</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> tickMark <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">0</span>, to: <span class="number">60</span>, by: <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(tickMark)</span><br><span class="line">    <span class="comment">// 打印 (0, 5, 10, 15 ... 45, 50, 55)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="while语句和-repeat-while语句"><a href="#while语句和-repeat-while语句" class="headerlink" title="while语句和 repeat-while语句"></a>while语句和 repeat-while语句</h1><blockquote><p>把括号去掉就行了</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> index = <span class="number">3</span></span><br><span class="line"><span class="keyword">while</span> index &gt; <span class="number">0</span> &#123;</span><br><span class="line">    index--</span><br><span class="line">    <span class="built_in">print</span>(index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">index = <span class="number">3</span></span><br><span class="line"><span class="keyword">repeat</span> &#123;</span><br><span class="line">    index--</span><br><span class="line">    <span class="built_in">print</span>(index)</span><br><span class="line">&#125; <span class="keyword">while</span> index &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="Break和continue这个用法和C差不多"><a href="#Break和continue这个用法和C差不多" class="headerlink" title="Break和continue这个用法和C差不多"></a>Break和continue这个用法和C差不多</h1><h1 id="Switch语句"><a href="#Switch语句" class="headerlink" title="Switch语句"></a>Switch语句</h1><blockquote><p>Swift里面的Switch语句不仅可以判断整形，而且还可以判断各种类型。注意的是执行了一个case后是不会继续往下面执行的，也就是不用添加break语句。相反如果你想要继续往下执行，你必须在这个case最后加上Fallthrough。另外就是default，对于不是枚举类型的变量，defalut必须加上。枚举类型的变量在完全枚举的时候才可以省略default</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"a"</span></span><br><span class="line"><span class="keyword">switch</span> str &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"a"</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"a"</span>)  <span class="comment">//这句会打印</span></span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"b"</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"b"</span>)  <span class="comment">//这句会打印</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"c"</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"c"</span>)  <span class="comment">//不会打印</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"nil"</span>)  <span class="comment">//不会打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>switch里面一个case可以对应多个选项，每个选项之间用逗号分开。这个用法是用来实现c里面的某个选项里面没有执行代码的情况。Swift不允许某个选项里面没有可执行的代码</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"s"</span></span><br><span class="line"><span class="keyword">switch</span> str &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"a"</span>,<span class="string">"s"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"a"</span>)  <span class="comment">//只打印这句</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"nil"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>case里面也可以是一个范围，在每个case之间的范围有重叠的话，只会匹配第一个</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">2</span></span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>...<span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"1-10"</span>)  <span class="comment">//只打印这句</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>..&lt;<span class="number">20</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"10-20"</span>)  <span class="comment">//因为匹配了第一句，所以这句不会再匹配</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"other"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对Tuple 的匹配<br>你可以匹配Tuple的两个值，也可以只匹配一个值，还可以匹配范围</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面case的条件都是可以匹配的，把前面的case注释掉的话就会匹配下一个case。</span></span><br><span class="line"><span class="keyword">var</span> tuple = (<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span> tuple &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="number">2</span>,<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(2,1)"</span>)  <span class="comment">//因为自动添加break的机制，所以不会往下走</span></span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">let</span> x,<span class="number">1</span>): <span class="comment">//可以用变量来自由化其中一个值，只需要另外一个值匹配了，就会匹配这个。如果你不关注x的值，你也可以把x换为_</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"x = <span class="subst">\(x)</span>"</span>)</span><br><span class="line"><span class="keyword">case</span> (-<span class="number">1</span>...<span class="number">3</span>,<span class="number">0</span>...<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(-1~3,0~4)"</span>)</span><br><span class="line"><span class="keyword">default</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"other"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Where语句在switch中"><a href="#Where语句在switch中" class="headerlink" title="Where语句在switch中"></a>Where语句在switch中</h1><blockquote><p>where可以用来进一步对case添加约束</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tuple = (<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span> tuple &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">var</span> (x,y) <span class="keyword">where</span> x == y:  <span class="comment">//这里用var 和 let 区别在于能不能在case里面修改解包的x，y值。但是即使修改也不会影响原来的tuple</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"x == y"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (<span class="number">_</span>,x) <span class="keyword">where</span> x == <span class="number">4</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"x == 4"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">var</span> (x,y) <span class="keyword">where</span> x != y:  <span class="comment">//匹配了这个case</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"x != y"</span>)          <span class="comment">//打印 x != y</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(x)                <span class="comment">//打印 1</span></span><br><span class="line"><span class="keyword">default</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"other"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(tuple)  <span class="comment">//打印 （2，1）</span></span><br></pre></td></tr></table></figure><h1 id="Labeled-Statements"><a href="#Labeled-Statements" class="headerlink" title="Labeled Statements"></a>Labeled Statements</h1><blockquote><p>这个labeled statements就像goto语句，但是跳转比较有限，只能用于循环里面。虽然switch也可以加上去，但是并没有用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tuple = (<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">second:<span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>...  &#123;   </span><br><span class="line">    frist : <span class="keyword">switch</span> tuple &#123;    <span class="comment">//这个first并没有什么用</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">var</span> (x,y) <span class="keyword">where</span> x == y:  <span class="comment">//这里用var 和 let 区别在于能不能在case里面修改解包的x，y值。但是即使修改也不会影响原来的tuple</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"x == y"</span>)</span><br><span class="line">        <span class="keyword">break</span> second</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">var</span> (x,y) <span class="keyword">where</span> x != y:  <span class="comment">//匹配了这个case</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"x != y"</span>)          <span class="comment">//打印 x != y</span></span><br><span class="line">        tuple = (<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">continue</span> second</span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"other"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面的for循环依次打印了 x != y    x == y</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意下面的second，虽然前面也定义了，但是不会冲突。循环内的跳转只能针对循环</span></span><br><span class="line">second:<span class="keyword">repeat</span> &#123;      <span class="comment">//对于while也是可以用。</span></span><br><span class="line">    frist : <span class="keyword">switch</span> tuple &#123;        <span class="comment">//这个first并没有什么用</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">var</span> (x,y) <span class="keyword">where</span> x == y:  <span class="comment">//这里用var 和 let 区别在于能不能在case里面修改解包的x，y值。但是即使修改也不会影响原来的tuple</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"x == y"</span>)</span><br><span class="line">        <span class="keyword">break</span> second</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">var</span> (x,y) <span class="keyword">where</span> x != y:  <span class="comment">//匹配了这个case</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"x != y"</span>)          <span class="comment">//打印 x != y</span></span><br><span class="line">        tuple = (<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">continue</span> second</span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"other"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">//while循环只打印了  x == y，因为Tuple已经被修改为(1,1)</span></span><br></pre></td></tr></table></figure><h1 id="Assertion和Precondition"><a href="#Assertion和Precondition" class="headerlink" title="Assertion和Precondition"></a>Assertion和Precondition</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert</span>(<span class="number">_</span>:<span class="number">_</span>:file:line:)</span><br></pre></td></tr></table></figure><blockquote><p>判断一个情况是否为true，不为true直接停止程序</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assertionFailure</span>(<span class="number">_</span>:file:line:)</span><br></pre></td></tr></table></figure><blockquote><p>Swift现在多了一个Preconditions，区别文档上说的是开发时候用Assertions，生产用Preconditions。(Assertions help you find mistakes and incorrect assumptions during development, and preconditions help you detect issues in production. )</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">precondition</span>(<span class="number">_</span>:<span class="number">_</span>:file:line:) </span><br><span class="line"><span class="built_in">preconditionFailure</span>(<span class="number">_</span>:file:line:)</span><br></pre></td></tr></table></figure><blockquote><p>文档上有两段话：</p></blockquote><blockquote><p>If you compile in unchecked mode (-Ounchecked), preconditions are not checked. The compiler assumes that preconditions are always true, and it optimizes your code accordingly. However, the fatalError(<em>:file:line:) function always halts execution, regardless of optimization settings.<br>You can use the fatalError(</em>:file:line:) function during prototyping and early development to create stubs for functionality that hasn’t been implemented yet, by writing fatalError(“Unimplemented”) as the stub implementation. Because fatal errors are never optimized out, unlike assertions or preconditions, you can be sure that execution always halts if it encounters a stub implementation.<br>但是没找到这个-Ounchecked模式，到时有一个选项是disable_safty_checks。<br>这个选项的关闭和Swift_OPTIMIZATION_LEVEL的模式有关系。如果你选择的是 -Onone，那么不管disable_safty_checks的值，都会检测precondition和assert。但是如果开启了优化，那么assert就再不检测，而precondition就会根据是否关闭安全检测来执行</p></blockquote><h1 id="guard语句"><a href="#guard语句" class="headerlink" title="guard语句"></a>guard语句</h1><blockquote><p>这个和assertions差不多，都是用来做判断的，不过这个要自己加上处理。用来在条件不满足的情况下跳出方法或循环</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> i &gt; <span class="number">1</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"i &lt;= 1"</span>)</span><br><span class="line">        <span class="keyword">break</span>     <span class="comment">//else里面必须加上break或return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="available"><a href="#available" class="headerlink" title="available"></a>available</h1><blockquote><p>用来判断是否可以使用某个版本API</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> #available (iOS <span class="number">8</span>, <span class="type">OSX</span> <span class="number">10.10</span>, *) &#123;  <span class="comment">//括号里面表示的是最低的版本。这个*必须有，代表其他平台</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-集合类型</title>
      <link href="/2017/11/24/Swift/Swift/Grammar/%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/"/>
      <url>/2017/11/24/Swift/Swift/Grammar/%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h1 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h1><blockquote><p>集合类分为array、dictionary、set<br>每个集合都有一个isEmpty属性来判断这个集合是否为空</p></blockquote><h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><blockquote><p>创建array的四种方法</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]  <span class="comment">//包含 a b c 三个字符串</span></span><br><span class="line"><span class="keyword">var</span> array2 = <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;()  <span class="comment">//空array，这里一定要指明元素类型</span></span><br><span class="line"><span class="keyword">var</span> array3 = [<span class="type">String</span>]()    <span class="comment">//空array</span></span><br><span class="line"><span class="keyword">var</span> array4 = <span class="type">Array</span>(repeating:<span class="number">2.4</span>, <span class="built_in">count</span>:<span class="number">3</span>) <span class="comment">//包含3个double变量，值都为1.3</span></span><br><span class="line"><span class="keyword">var</span> array5 = [<span class="type">Double</span>](repeating:<span class="number">2.4</span>, <span class="built_in">count</span>:<span class="number">3</span>) <span class="comment">//包含3个double变量，值都为1.3</span></span><br></pre></td></tr></table></figure><blockquote><p>获取array的某个元素,直接用下标</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = array1[<span class="number">9</span>]</span><br></pre></td></tr></table></figure><blockquote><p>清空数组</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">array1.removeAll()</span><br><span class="line"></span><br><span class="line">array1 = [];</span><br></pre></td></tr></table></figure><blockquote><p>清空某个元素</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">remove(at:)</span><br></pre></td></tr></table></figure><blockquote><p>清空某个范围的元素</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array.removeSubrange(1..&lt;arr.endIndex)// 这里会移除从1开始，但是不包括end的元素，但是endIndex是指向最后一个元素的后一个元素的，所以会从index为1的元素开始，删除后面全部。</span><br><span class="line">array[1...2] = [] //这里将范围1-2的元素都清空了,注意一点，如果数组越界的话，会产生运行时错误</span><br></pre></td></tr></table></figure><blockquote><p>向array添加元素</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用append()方法</span></span><br><span class="line">array1.append(<span class="string">"A"</span>)  <span class="comment">//向array1的末尾添加一个 A，现在只有一个 A 元素</span></span><br><span class="line"><span class="comment">//使用运算符号</span></span><br><span class="line">array3 += [<span class="string">"d"</span>,<span class="string">"e"</span>]  <span class="comment">//array3从空数组变为包含 d e 两个字符串</span></span><br><span class="line"><span class="keyword">var</span> array5 = array1 + array3 + [<span class="string">"last"</span>]  <span class="comment">//array5包含 A d e last, 4个元素</span></span><br><span class="line"><span class="comment">//使用insert方法</span></span><br><span class="line">array5.insert(<span class="string">"first"</span>, at: <span class="number">0</span>)   <span class="comment">//array5包含 first A d e last, 5个元素</span></span><br></pre></td></tr></table></figure><blockquote><p>改变array元素</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">array5[<span class="number">0</span>] = <span class="string">"newBe"</span></span><br><span class="line">array5[<span class="number">1</span>...<span class="number">3</span>] = [<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>]</span><br></pre></td></tr></table></figure><blockquote><p>遍历数组<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> array5 &#123;</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (index,item) <span class="keyword">in</span> array5.enumerated() &#123;</span><br><span class="line">    <span class="built_in">print</span>(index,item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><blockquote><p>Set 创建<br>set里面的元素都必须实现hashable。因为区分set里面的元素的根本就是判断两个元素的hash值是否相等。swift基本类型都实现了hashable</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> emptySet = <span class="type">Set</span>&lt;<span class="type">Character</span>&gt;() <span class="comment">//建立一个空set，必须指明内容的类型</span></span><br><span class="line"><span class="keyword">var</span> nameSet : <span class="type">Set</span>&lt;<span class="type">String</span>&gt; = [<span class="string">"Tom"</span>,<span class="string">"Lucy"</span>,<span class="string">"Aaron"</span>]  <span class="comment">//使用初始数据建立set</span></span><br></pre></td></tr></table></figure><blockquote><p>移除Set </p></blockquote><ul><li>removeAll()，这个方法还可以传一个boolean参数，表示是否保持空间，传ture的话表示保持</li><li>移除一个元素有两种办法</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> index = nameSet.index(of:<span class="string">"Tom"</span>)</span><br><span class="line">nameSet.remove(at:index!) <span class="comment">//因为indexOf返回的是可选类型，所以这里要解包</span></span><br><span class="line"></span><br><span class="line">nameSet.remove(<span class="string">"Tom"</span>) <span class="comment">//这种和上面的是等价的</span></span><br></pre></td></tr></table></figure><blockquote><p>遍历Set</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> nameSet.sorted() &#123; <span class="comment">//这里的sorted()可以不用，这里用来排序</span></span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>包含某个元素</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Set</span>和<span class="type">Array</span>都有一个<span class="built_in">contains</span>方法来判断</span><br></pre></td></tr></table></figure><blockquote><p>Set操作<br>包括了求交集，并集，“减集”，“异或集”<br>官方代码</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oddDigits: <span class="type">Set</span> = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> evenDigits: <span class="type">Set</span> = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">let</span> singleDigitPrimeNumbers: <span class="type">Set</span> = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">oddDigits.union(evenDigits).<span class="built_in">sort</span>()</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line">oddDigits.intersection(evenDigits).<span class="built_in">sort</span>()</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line">oddDigits.subtracting(singleDigitPrimeNumbers).<span class="built_in">sort</span>()</span><br><span class="line"><span class="comment">// [1, 9]</span></span><br><span class="line">oddDigits.symmetricDifference(singleDigitPrimeNumbers).<span class="built_in">sort</span>()</span><br><span class="line"><span class="comment">// [1, 2, 9]</span></span><br></pre></td></tr></table></figure><blockquote><p>Set关系</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">isSubset(of:) 判断一个<span class="keyword">set</span>是否为另外一个<span class="keyword">set</span>的子<span class="keyword">set</span></span><br><span class="line">isSuperset(of:) 判断一个<span class="keyword">set</span>是否为另外一个<span class="keyword">set</span>的父<span class="keyword">set</span></span><br><span class="line">isStrictSubset(of:) 和 isStrictSuperset(of:) 意思和上面的一样，只是这两个方法不能存在相等的情况。</span><br><span class="line">isDisjoint(with:) 判断两个<span class="keyword">set</span>是否没有共同元素，没有的话返回<span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h1><blockquote><p>创建Dictionar</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dict1 : [<span class="type">String</span>:<span class="type">Int</span>] = [<span class="string">"a"</span>:<span class="number">1</span>,<span class="string">"b"</span>:<span class="number">2</span>,<span class="string">"c"</span>:<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> dict = [<span class="string">"a"</span>:<span class="number">1</span>,<span class="string">"b"</span>:<span class="number">2</span>,<span class="string">"c"</span>:<span class="number">3</span>, <span class="number">3</span>:<span class="string">"d"</span>] <span class="keyword">as</span> [<span class="type">AnyHashable</span> : <span class="type">Any</span>]  <span class="comment">//注意这个没声明类型的，因为key和value里面都有不同的类型，所以需要将二者都强转为AnyHashable，但是如果key（value）类型只有一种的话，那么就会转为那种类型。</span></span><br><span class="line"><span class="keyword">var</span> dict2 = [<span class="type">Int</span>:<span class="type">String</span>]()</span><br><span class="line"><span class="keyword">var</span> dict3 = <span class="type">Dictionary</span>&lt;<span class="type">String</span>,<span class="type">Int</span>&gt;()</span><br></pre></td></tr></table></figure><blockquote><p>添加/修改/删除dictionary<br>dictionary也提供了removeAll，removeAtIndex之类的方法<br>使用和Set是一样的，就不写了。下面是dictionary特有的</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dict[<span class="number">5</span>] = <span class="string">"f"</span> <span class="comment">//添加一个键值对  5: "f"</span></span><br><span class="line">dict[<span class="number">5</span>] = <span class="number">5</span>   <span class="comment">//修改key为5的值为5</span></span><br><span class="line">dict[<span class="number">5</span>] = <span class="literal">nil</span>  <span class="comment">//删除key为5的键值对</span></span><br><span class="line">dict[<span class="number">6</span>] = <span class="literal">nil</span>  <span class="comment">//对不存在的键值对赋nil不会报错</span></span><br><span class="line">dict2 = [:]  <span class="comment">//清空所有</span></span><br></pre></td></tr></table></figure><blockquote><p>新增了一个更改和删除的方法，可以获得更新和删除前的旧值(可选类型)。如果这个值以前不存在，那么返回nil</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oldValue = airports.updateValue(<span class="string">"Dublin Airport"</span>, forKey: <span class="string">"DUB"</span>) </span><br><span class="line"><span class="keyword">let</span> removedValue = airports.removeValue(forKey: <span class="string">"DUB"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>遍历dictionary </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (key,name) <span class="keyword">in</span> dict &#123;</span><br><span class="line">    <span class="built_in">print</span>(key,name,separator:<span class="string">":"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> keys = dict1.keys.<span class="built_in">sort</span>();</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> keys &#123;</span><br><span class="line">    <span class="built_in">print</span>(key,dict[key]!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-String-Character</title>
      <link href="/2017/11/24/Swift/Swift/Grammar/String-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2017/11/24/Swift/Swift/Grammar/String-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="String-的定义"><a href="#String-的定义" class="headerlink" title="String 的定义"></a>String 的定义</h2><blockquote><p><strong>字符串</strong>是有序的字符集合，或者叫文本<br>String 是字符串类型。单个字，Character是字符类型<br>2个字符串可以用 + 链接<br>通过字符插值可以合成一个长字符串</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>()     <span class="comment">// An empty `String`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串创建和空判断"><a href="#字符串创建和空判断" class="headerlink" title="字符串创建和空判断"></a>字符串创建和空判断</h2><blockquote><p>字符串字面量，包含双引号的值</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Yue ke kui"</span></span><br></pre></td></tr></table></figure><blockquote><p>创建空串</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> yue  = <span class="string">""</span></span><br><span class="line">或</span><br><span class="line"><span class="keyword">var</span> yue = <span class="type">String</span>()  <span class="comment">//结构体方式创建</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ke = <span class="string">"  "</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">yue.isEmpty    <span class="comment">// 判断字符串是否为空</span></span><br><span class="line">ke.isEmpty   <span class="comment">// 不为空。有空格</span></span><br></pre></td></tr></table></figure><blockquote><p>使用三个引号来创建一段话的string<br>开始的三个引号的第一行后面的空格都会忽略，但是第二行的空格不会</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> quotation = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">The White Rabbit put on his spectacles.  "</span><span class="type">Where</span> shall <span class="type">I</span> begin,</span><br><span class="line">please your <span class="type">Majesty</span>?<span class="string">" he asked.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span><span class="type">Begin</span> at the beginning,<span class="string">" the King said gravely, "</span>and go on</span><br><span class="line">till you come to the end; then stop.<span class="string">"</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br></pre></td></tr></table></figure><h2 id="可修改字符串"><a href="#可修改字符串" class="headerlink" title="可修改字符串"></a>可修改字符串</h2><blockquote><p>Swift 3.0 用 var 和 let 来判断字符串是否可以被修改(类似OC可变字符串)<br>let修饰 不可变字符串  不能拼接追加等<br>var修饰 可变字符串<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> variableString = <span class="string">"Hello"</span></span><br><span class="line">variableString += <span class="string">"Swift 3.0"</span>;</span><br><span class="line"><span class="built_in">print</span>(variableString);</span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="type">HelloSwift</span> <span class="number">3.0</span></span><br></pre></td></tr></table></figure></p></blockquote><h2 id="Character-字符"><a href="#Character-字符" class="headerlink" title="Character 字符"></a>Character 字符</h2><blockquote><p>创建一个Character，必须显式声明类型</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c1:<span class="type">Character</span> = <span class="string">"c"</span>  <span class="comment">//注意是 双引号</span></span><br><span class="line"><span class="keyword">var</span> c2 = <span class="string">"c"</span>           <span class="comment">//c2被认为是String类型</span></span><br><span class="line"><span class="keyword">var</span> c3 = '<span class="built_in">c</span>'           <span class="comment">//编译错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Character可以赋值为Unicode</span></span><br><span class="line"><span class="keyword">let</span> eAcute: <span class="type">Character</span> = <span class="string">"\u&#123;E9&#125;"</span>      <span class="comment">// é</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 挨个 取 字符</span></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"Swift"</span>;</span><br><span class="line"><span class="keyword">var</span> arrays = string.characters;</span><br><span class="line"><span class="keyword">for</span> charactor <span class="keyword">in</span> arrays&#123;</span><br><span class="line">    <span class="built_in">print</span>(charactor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一次打印 </span></span><br><span class="line"> <span class="type">S</span>  w  i  f t</span><br></pre></td></tr></table></figure><h2 id="字符串是值类型"><a href="#字符串是值类型" class="headerlink" title="字符串是值类型"></a>字符串是值类型</h2><blockquote><p>改变String，这个语法和java一样的，不过内存管理层面已经是不同的对象<br>字符串是值类型: 创建了一个新的字符串，那么当其进行常量、变量赋值操作，或在函数/方法中传递时，会进行值拷贝。在实际编译时，Swift 编译器会优化字符串的使用，使实际的复制只发生在绝对必要的情况下，这意味着您将字符串作为值类型的同时可以获得极高的性能</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str:<span class="type">String</span> = <span class="string">"first"</span></span><br><span class="line"><span class="keyword">var</span> c1:<span class="type">Character</span> = <span class="string">"c"</span>          <span class="comment">//注意是双引号</span></span><br><span class="line"><span class="keyword">var</span> c2 = <span class="string">"c"</span>                    <span class="comment">//c2被认为是String类型</span></span><br><span class="line">str += <span class="string">"sceond"</span>                 <span class="comment">//str变为firstsceond,此时的str和之前的str内存地址不同</span></span><br><span class="line">str += c2                      <span class="comment">//str变为firstc,此时的str和之前的str内存地址不同</span></span><br><span class="line">str.appendContentsOf(<span class="string">"second"</span>) <span class="comment">// 和使用+=是一样的</span></span><br><span class="line">str.appendContentsOf(c2)       <span class="comment">//和使用+=是一样的</span></span><br><span class="line">str.append(c1);                <span class="comment">//添加Character的方法</span></span><br></pre></td></tr></table></figure><h2 id="遍历String字符"><a href="#遍历String字符" class="headerlink" title="遍历String字符"></a>遍历String字符</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str:<span class="type">String</span> = <span class="string">"first"</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">c</span> <span class="keyword">in</span> str.characters &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">c</span>)</span><br><span class="line">&#125;</span><br><span class="line"> ------ 或</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> str.characters.<span class="built_in">indices</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(str[index])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取String长度"><a href="#获取String长度" class="headerlink" title="获取String长度"></a>获取String长度</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"dfe"</span></span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">count</span>)  <span class="comment">//3</span></span><br></pre></td></tr></table></figure><ul><li>swift里面有extended grapheme clusters(An extended grapheme cluster is a sequence of one or more Unicode scalars that (when combined) produce a single human-readable character.) 也就是几个Unicode字符组合成一个人类可以识别的字符。</li><li>当string里面添加了characters后，count不一定会增加。<br>string的count不一定和NSString的length一致。<br>(The length of an NSString is based on the number of 16-bit code units within the string’s UTF-16 representation and not the number of Unicode extended grapheme clusters within the string.)</li></ul><h2 id="运算符-其他方式，赋值"><a href="#运算符-其他方式，赋值" class="headerlink" title="运算符+其他方式，赋值"></a>运算符+其他方式，赋值</h2><p> 符附字符尾部 append</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 通过加法运算符（+）相加在一起（或称“连接”）创建一个新的字符串</span></span><br><span class="line"> <span class="keyword">let</span> string1 = <span class="string">"chen"</span>;</span><br><span class="line"> <span class="keyword">let</span> string2 = <span class="string">"jian"</span>;</span><br><span class="line"> <span class="keyword">let</span> string3 =  string1 + string2;</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">"string3 is  <span class="subst">\(string3)</span>"</span>);  <span class="comment">// chen  jian</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过加法赋值运算符 (+=) 将一个字符串添加到一个已经存在字符串变量上</span></span><br><span class="line"><span class="keyword">var</span> variablestring = <span class="string">"da shen chen jian"</span>;</span><br><span class="line">variablestring += string2;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"variablestring is <span class="subst">\(variablestring)</span>"</span>);<span class="comment">// da shen chen jianjian </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用append()方法将一个字符附加到一个字符串变量的尾部</span></span><br><span class="line">  variablestring.append(<span class="string">" !"</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"variablestring is <span class="subst">\(variablestring)</span>"</span>);</span><br><span class="line">  <span class="comment">// da shen chen jianjian !</span></span><br></pre></td></tr></table></figure><h2 id="String的Index"><a href="#String的Index" class="headerlink" title="String的Index"></a>String的Index</h2><ul><li>不像java里面的Index直接就是一个数字</li><li>String的Index是在不同的extension中定义的。 </li></ul><h2 id="获得String里面的某个字符的过程"><a href="#获得String里面的某个字符的过程" class="headerlink" title="获得String里面的某个字符的过程"></a>获得String里面的某个字符的过程</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = <span class="string">"Guten Tag!"</span></span><br><span class="line">greeting[greeting.startIndex]</span><br><span class="line"><span class="comment">// G</span></span><br><span class="line">greeting[greeting.index(before: greeting.endIndex)]</span><br><span class="line"><span class="comment">// !</span></span><br><span class="line">greeting[greeting.index(after: greeting.startIndex)]</span><br><span class="line"><span class="comment">// u</span></span><br><span class="line"><span class="keyword">let</span> index = greeting.index(greeting.startIndex, offsetBy: <span class="number">7</span>)</span><br><span class="line">greeting[index]</span><br><span class="line"><span class="comment">// a</span></span><br></pre></td></tr></table></figure><h2 id="插入和移除字符"><a href="#插入和移除字符" class="headerlink" title="插入和移除字符"></a>插入和移除字符</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> welcome = <span class="string">"hello"</span></span><br><span class="line">welcome.insert(<span class="string">"!"</span>, at: welcome.endIndex)</span><br><span class="line"><span class="comment">// welcome now equals "hello!"</span></span><br><span class="line"></span><br><span class="line">welcome.insert(contentsOf: <span class="string">" there"</span>, at: welcome.index(before: welcome.endIndex))</span><br><span class="line"><span class="comment">// welcome now equals "hello there!"</span></span><br><span class="line">welcome.remove(at: welcome.index(before: welcome.endIndex))</span><br><span class="line"><span class="comment">// welcome now equals "hello there"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> range = welcome.index(welcome.endIndex, offsetBy: -<span class="number">6</span>)..&lt;welcome.endIndex</span><br><span class="line">welcome.removeSubrange(range)</span><br><span class="line"><span class="comment">// welcome now equals "hello"</span></span><br></pre></td></tr></table></figure><h2 id="截串"><a href="#截串" class="headerlink" title="截串"></a>截串</h2><ul><li>Swift引入了一个SubString类，用来截串</li></ul> <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> greeting = <span class="string">"Hello, world!"</span></span><br><span class="line"><span class="keyword">let</span> index = greeting.index(of: <span class="string">","</span>) ?? greeting.endIndex</span><br><span class="line"><span class="keyword">let</span> beginning = greeting[..&lt;index]</span><br><span class="line"><span class="comment">// beginning is "Hello"</span></span><br><span class="line">但是注意<span class="type">SubString</span>可能会用到原来string的内存。官方建议是短时间使用，如果想要长时间保持，需要转为<span class="type">String</span></span><br><span class="line"><span class="comment">// Convert the result to a String for long-term storage.</span></span><br><span class="line"><span class="keyword">let</span> newString = <span class="type">String</span>(beginning)</span><br></pre></td></tr></table></figure><blockquote><p>将String转换为NSString，然后调用NSString的截串方法</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"123456789"</span></span><br><span class="line"><span class="keyword">var</span> ns = (str <span class="keyword">as</span> <span class="type">NSString</span>).substringWithRange(<span class="type">NSMakeRange</span>(<span class="number">1</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(ns) <span class="comment">//输出  2345</span></span><br></pre></td></tr></table></figure><h2 id="xtension来扩展String-最简单"><a href="#xtension来扩展String-最简单" class="headerlink" title="xtension来扩展String(最简单)"></a>xtension来扩展String(最简单)</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mport <span class="type">Foundation</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取部分字符串，如果不在范围内，返回nil.如果end大于字符串长度，那么截取到最后</span></span><br><span class="line">    <span class="keyword">subscript</span> (start: <span class="type">Int</span>, end: <span class="type">Int</span>) -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> start &gt; <span class="keyword">self</span>.<span class="built_in">count</span> || start &lt; <span class="number">0</span> || start &gt; end &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> begin = <span class="keyword">self</span>.index(<span class="keyword">self</span>.startIndex, offsetBy: start)</span><br><span class="line">        <span class="keyword">var</span> terminal: <span class="type">Index</span></span><br><span class="line">        <span class="keyword">if</span> end &gt;= length &#123;</span><br><span class="line">            terminal = <span class="keyword">self</span>.index(<span class="keyword">self</span>.startIndex, offsetBy: <span class="built_in">count</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            terminal = <span class="keyword">self</span>.index(<span class="keyword">self</span>.startIndex, offsetBy: end + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> range = (begin ..&lt; terminal)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.substring(with: range)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取某个字符，如果不在范围内，返回nil</span></span><br><span class="line">    <span class="keyword">subscript</span> (index: <span class="type">Int</span>) -&gt; <span class="type">Character</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> index &gt; <span class="keyword">self</span>.<span class="built_in">count</span> - <span class="number">1</span> || index &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>[<span class="keyword">self</span>.index(<span class="keyword">self</span>.startIndex, offsetBy: index)]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算字符数量"><a href="#计算字符数量" class="headerlink" title="计算字符数量"></a>计算字符数量</h2><blockquote><p>如果想要获得一个字符串中Character值的数量，可以使用字符串的characters属性的count属性</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span>  calculstring = <span class="string">"chenjian"</span>;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"calculstring has <span class="subst">\(calculstring.characters.<span class="built_in">count</span>)</span> charactor"</span>);</span><br><span class="line"><span class="comment">//输出结果 calculstring has 8 charactor</span></span><br></pre></td></tr></table></figure><h2 id="访问字符串"><a href="#访问字符串" class="headerlink" title="访问字符串"></a>访问字符串</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> visitString = <span class="string">"Hello Swift"</span>;</span><br><span class="line"><span class="comment">//获取第一个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"visitString 的第一个字符 :<span class="subst">\(visitString[visitString.startIndex])</span>"</span>);</span><br><span class="line"><span class="comment">// 这里输出 visitString 的第一个字符 :H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取最后一个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"visitString 的最后一个字符 :<span class="subst">\(visitString[visitString.index(before: visitString.endIndex)</span>])"</span>);</span><br><span class="line"><span class="comment">// 这里输出  visitString 的最后一个字符 :t</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取下第二个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"visitString 的第二个字符 : <span class="subst">\(visitString[visitString.index(after: visitString.startIndex)</span>])"</span>)</span><br><span class="line"><span class="comment">// 这里输出 visitString 的第二个字符 : e</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过偏移量获取索引 第一个字符 往后偏移 4个单位(不包括起始位置) （备注： 如果你把字符串当数组来理解，你会发现 0 就在数组的自四个位置）</span></span><br><span class="line"><span class="keyword">let</span> index = visitString.index(visitString.startIndex, offsetBy: <span class="number">4</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(visitString[index])</span>"</span>);</span><br><span class="line"><span class="comment">// 这里输出  o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 characters 属性的 indices 属性会创建一个包含全部索引的范围(Range)，用来在一个字符串中访问单个字符</span></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> visitString.characters.<span class="built_in">indices</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"通过下标得到每一个字符:<span class="subst">\(visitString[index])</span>"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过下标得到每一个字符:H</span></span><br><span class="line"><span class="comment">通过下标得到每一个字符:e</span></span><br><span class="line"><span class="comment">通过下标得到每一个字符:l</span></span><br><span class="line"><span class="comment">通过下标得到每一个字符:l</span></span><br><span class="line"><span class="comment">通过下标得到每一个字符:o</span></span><br><span class="line"><span class="comment">通过下标得到每一个字符: </span></span><br><span class="line"><span class="comment">通过下标得到每一个字符:S</span></span><br><span class="line"><span class="comment">通过下标得到每一个字符:w</span></span><br><span class="line"><span class="comment">通过下标得到每一个字符:i</span></span><br><span class="line"><span class="comment">通过下标得到每一个字符:f</span></span><br><span class="line"><span class="comment">通过下标得到每一个字符:t</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="大小写转化"><a href="#大小写转化" class="headerlink" title="大小写转化"></a>大小写转化</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> changeString = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(changeString.uppercased()</span>)"</span>)  <span class="comment">//转化成大写</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(changeString.lowercased()</span>)"</span>)  <span class="comment">// 转化成小写</span></span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><blockquote><p>调用 insert(_:at:) 方法可以在一个字符串的指定索引插入一个字符，调用 insert(contentsOf:at:) 方法可以在一个字符串的指定索引插入一个段字符串</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//插入单个字符</span></span><br><span class="line"><span class="keyword">var</span> welocome = <span class="string">"hello"</span>;</span><br><span class="line">welocome.insert(<span class="string">"!"</span>, at: welocome.endIndex);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"welocome = <span class="subst">\(welocome)</span>"</span>);</span><br><span class="line"><span class="comment">//welocome = hello!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入一段字符串到某个位置   contentsOf ： "字符串".characters 固定语法</span></span><br><span class="line">welocome.insert(contentsOf: <span class="string">"there"</span>.characters, at: welocome.index(before: welocome.endIndex));</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"welocome = <span class="subst">\(welocome)</span>"</span>);</span><br><span class="line"><span class="comment">//welocome = hello there!</span></span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><blockquote><p>调用 remove(at:) 方法可以在一个字符串的指定索引删除一个字符</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  welocome.remove(at: welocome.index(before: welocome.endIndex));</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"welocome = <span class="subst">\(welocome)</span>"</span>);</span><br><span class="line"><span class="comment">//welocome = hello there</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 removeSubrange(_:) 方法可以在一个字符串的指定索引删除一个子字符串。</span></span><br><span class="line"><span class="keyword">let</span> range = welocome.index(welocome.startIndex,offsetBy:<span class="number">6</span>)..&lt;welocome.endIndex;</span><br><span class="line">welocome.removeSubrange(range);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"welocome = <span class="subst">\(welocome)</span>"</span>);</span><br><span class="line"><span class="comment">// welocome = hello</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定位置删除</span></span><br><span class="line">welocome.remove(at: welocome.index(before: welocome.endIndex));</span><br><span class="line"><span class="built_in">print</span>(welocome);</span><br><span class="line"><span class="comment">//hello</span></span><br></pre></td></tr></table></figure><h2 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h2><blockquote><p>字符串/字符可以用等于操作符(==)和不等于操作符(!=)</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> quotation = <span class="string">"We're a lot alike, you and I."</span></span><br><span class="line"><span class="keyword">let</span> sameQuotation = <span class="string">"We're a lot alike, you and I."</span></span><br><span class="line"><span class="keyword">if</span> quotation == sameQuotation&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"相等"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前缀相等</span></span><br><span class="line"><span class="keyword">let</span> preString01 = <span class="string">"date"</span>;</span><br><span class="line"><span class="keyword">if</span> preString01.hasPrefix(<span class="string">"da"</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"preString01 前缀有da"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 后缀相等</span></span><br><span class="line"><span class="keyword">if</span> preString01.hasSuffix(<span class="string">"te"</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"preString01 后缀有te"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>不能将一个字符串或者字符添加到一个已经存在的字符变量上，因为字符变量只能包含一个字符</li></ul><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><ul><li>字符串字面量可以包含以下特殊字符：转义字符\0(空字符)、(反斜线)、\t(水平制表符)、\n(换行符)、\r(回车符)、\”(双引号)、\’(单引号)</li></ul>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
          <category> String </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-嵌套类型&amp;类型转换</title>
      <link href="/2017/11/24/Swift/Swift/Grammar/%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%9E%8B&amp;%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2017/11/24/Swift/Swift/Grammar/%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%9E%8B&amp;%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      <content type="html"><![CDATA[<h1 id="嵌套类型-Nested-Types"><a href="#嵌套类型-Nested-Types" class="headerlink" title="嵌套类型(Nested Types)"></a>嵌套类型(Nested Types)</h1><blockquote><p>这个概念就是把一个类（结构体、枚举类）的定义放到一个类类（结构体、枚举类）的里面。<br>这个嵌套可以随便嵌套。可以在结构体里面定义类，类里面定义枚举类，枚举类里面定义结构体等等。<br>随便一个没意思的例子，访问方法也给出来了。使用点语法就可以了</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">A</span> </span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">var</span> num = <span class="number">1</span>  </span><br><span class="line">          </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Q</span> </span>&#123;  </span><br><span class="line">              </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">var</span> cc = <span class="number">2</span>  </span><br><span class="line">              </span><br><span class="line">            <span class="class"><span class="keyword">enum</span> <span class="title">AA</span>  </span>&#123;  </span><br><span class="line">                <span class="keyword">case</span> d,e  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">CCC</span> </span>&#123;  </span><br><span class="line">                  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">print</span>(<span class="type">A</span>.<span class="type">B</span>.<span class="type">C</span>.<span class="type">AA</span>.d)  <span class="comment">//d  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">A</span>.<span class="type">B</span>.<span class="type">C</span>().cc)  <span class="comment">//2</span></span><br></pre></td></tr></table></figure><h1 id="类型判断符-is"><a href="#类型判断符-is" class="headerlink" title="类型判断符 is"></a>类型判断符 is</h1><blockquote><p>用is可以用来判断一个实例是否是某个类或是某个类是子类。返回一个Bool值。十分简单，看例子</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> : <span class="title">Fruit</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">eatApple</span><span class="params">()</span></span> &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"ear apple"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pear</span>: <span class="title">Fruit</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">eatPear</span><span class="params">()</span></span> &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"eat pear"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> array = [<span class="type">Fruit</span>(),<span class="type">Apple</span>(),<span class="type">Pear</span>()]  </span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> array &#123;  </span><br><span class="line">    <span class="built_in">print</span>(item <span class="keyword">is</span> <span class="type">Apple</span>)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//打印  </span></span><br><span class="line"><span class="comment">//false  </span></span><br><span class="line"><span class="comment">//true  </span></span><br><span class="line"><span class="comment">//false  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> f = <span class="type">Fruit</span>()  </span><br><span class="line"><span class="keyword">var</span> a = <span class="type">Apple</span>()  </span><br><span class="line"><span class="keyword">var</span> p = <span class="type">Pear</span>()  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> <span class="type">Apple</span>)   <span class="comment">//警告说 肯定返回 true  </span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> <span class="type">Fruit</span>)   <span class="comment">//警告说 肯定返回 true  </span></span><br><span class="line"><span class="built_in">print</span>(p <span class="keyword">is</span> <span class="type">Apple</span>)   <span class="comment">//警告说 肯定返回 false  </span></span><br><span class="line"><span class="built_in">print</span>(f <span class="keyword">is</span> <span class="type">Apple</span>)   <span class="comment">//打印false</span></span><br></pre></td></tr></table></figure><h1 id="类型下转换符as-和-as-，下转换判断符as"><a href="#类型下转换符as-和-as-，下转换判断符as" class="headerlink" title="类型下转换符as? 和 as! ，下转换判断符as"></a>类型下转换符as? 和 as! ，下转换判断符as</h1><blockquote><p>这as? as! 两个运算符可以将一个实例尝试转换为另外一个类的实例。一般是用在将一个父类变量的转换为一个子类变量。比如下面代码</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fruit: <span class="type">Fruit</span> = <span class="type">Pear</span>()</span><br></pre></td></tr></table></figure><blockquote><p>先来开开这句代码，我们把一个变量声明为了Fruit类型，但是赋值的时候给的却是Fruit的子类Pear。这个时候并不会报错。这种用一个父类类型的变量指向一个子类的做法称为多态。多态在面向对象编程里面有很重要的作用。这里不展开讲。<br>因为fruit变量声明为了Fruit类型，即使它实际引用的实例是Pear类，但是现在还是不能通过它来调用Pear类引入的属性或方法。尽管这个实例确实是拥有这些属性和方法。为了去访问这些存在的属性和方法，我们就要采用类型下转换，将这个fruit的变量转换为一个pear的变量。</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pear = fruit <span class="keyword">as</span>? <span class="type">Pear</span></span><br></pre></td></tr></table></figure><p>上面的代码使用as?，尝试将这个fruit转为一个Pear类型的变量。这里因为fruit引用的实例就是Pear，所以是可以转换成功。成功后返回了一个Pear的可选类型给变量pear。但是如果转换失败，返回的是一个nil。比如你尝试将一个Apple实例转换为一个Pear，或者将一个Fruit实例转换为它的子类都会失败。</p><p>补充一点，如果对上面的fruit变量使用is判断是否是Pear类，返回的是true。<br>as!和as?的区别就是强制解包了。学了那么多，应该可以猜到。<br>最后在介绍这个比较诡异的as之前，看看Any和AnyObject这两个类型。</p><p>Any代表任何类型的实例，包括了函数类型。</p><p>AnyObject代表任何类的实例。</p><blockquote><p>现在介绍as的用法，现在只发现as能用在switch中，用来判断变量是否是某个类型</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> -&gt; <span class="type">Int</span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> b = &#123;<span class="keyword">var</span> i=<span class="number">0</span>; i++&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> array: [<span class="type">Any</span>] = [f1,b,fruit,<span class="type">Fruit</span>(), <span class="type">Apple</span>(), <span class="type">Pear</span>(), <span class="type">Animal</span>(), (<span class="number">2</span>,<span class="number">3</span>), (<span class="number">4</span>,<span class="number">5</span>)]  </span><br><span class="line"><span class="keyword">for</span> (index, item) <span class="keyword">in</span> array.<span class="built_in">enumerate</span>() &#123;  </span><br><span class="line">    <span class="keyword">switch</span> item &#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> item2 <span class="keyword">as</span> <span class="type">Apple</span> :  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"index<span class="subst">\(index)</span> is <span class="subst">\(item2)</span>"</span>)  </span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">is</span> <span class="type">Pear</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"index<span class="subst">\(index)</span> is pear"</span>)  </span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> (<span class="number">2</span>,y) <span class="keyword">as</span> (<span class="type">Int</span>, <span class="type">Int</span>) <span class="keyword">where</span> y &gt; <span class="number">2</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"index<span class="subst">\(index)</span> is tuple  y ="</span>,y)  </span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">is</span> (<span class="type">Int</span>,<span class="type">Int</span>):  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"index<span class="subst">\(index)</span> is (Int,Int) "</span>,item)  </span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> f <span class="keyword">as</span> <span class="type">Void</span>-&gt;<span class="type">Void</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"index<span class="subst">\(index)</span> is Void-&gt;Void "</span>,item)  </span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"index<span class="subst">\(index)</span> is default"</span>,item)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//打印  </span></span><br><span class="line"><span class="comment">//index0 is default (Function)  </span></span><br><span class="line"><span class="comment">//index1 is Void-&gt;Void  (Function)  </span></span><br><span class="line"><span class="comment">//index2 is pear  </span></span><br><span class="line"><span class="comment">//index3 is default SwiftTest.Fruit  </span></span><br><span class="line"><span class="comment">//index4 is SwiftTest.Apple  </span></span><br><span class="line"><span class="comment">//index5 is pear  </span></span><br><span class="line"><span class="comment">//index6 is default SwiftTest.Animal  </span></span><br><span class="line"><span class="comment">//index7 is tuple  y = 3  </span></span><br><span class="line"><span class="comment">//index8 is (Int,Int)  (4, 5)</span></span><br></pre></td></tr></table></figure><blockquote><p>你会发现其实，is 和 as 的效果是一样的。as比is多的就是将一个tuple可以再次解包出元素，并且再次匹配元素，同时还可以加上where做判断。比如上面的第三个case语句。会判断这个item是否是(Int,Inte)类型，然后解包tuple，判断第一个元素是否为2，如果是2，还会判断第二个元素是否大于2.只有这三个条件都符合才会匹配这个case</p></blockquote>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-Protocol协议</title>
      <link href="/2017/11/24/Swift/Swift/Grammar/Protocol%E5%8D%8F%E8%AE%AE/"/>
      <url>/2017/11/24/Swift/Swift/Grammar/Protocol%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<h1 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h1><h2 id="POP-面向协议的编程"><a href="#POP-面向协议的编程" class="headerlink" title="POP 面向协议的编程"></a>POP 面向协议的编程</h2><blockquote><p>面向协议的编程的核心是抽象（Abstraction）和简化（Simplicity）<br>协议的高级使用是协议的延展<br>协议(protocol) + 结构体(struct) &gt; 类(class)</p></blockquote><h2 id="面向对象与面向协议比较"><a href="#面向对象与面向协议比较" class="headerlink" title="面向对象与面向协议比较"></a>面向对象与面向协议比较</h2><ul><li>面向对象是一个很古老的软件开发模式，通过类来实现</li><li>面向协议是苹果在 swift 中主推的，通过协议和结构体，可以代替类</li><li>Swift 中的很多对象都改成了结构体和协议</li><li>并不是所有的类都可以被协议+结构体替代，但大多数是可以被替换的</li><li>面向协议使代码更加灵活，类似于组件化开发，符合工厂方法模式<h3 id="实例比较：给一个类添加额外的方法"><a href="#实例比较：给一个类添加额外的方法" class="headerlink" title="实例比较：给一个类添加额外的方法"></a>实例比较：给一个类添加额外的方法</h3><blockquote><p>通过继承 </p></blockquote></li></ul><ul><li>创建一个继承类的子类，在子类中添加方法，以后使用子类即可获取这个方法通过协议</li><li><p>为这个方法定义一个协议，哪个类需要实现这个方法，协议即可</p><blockquote><p>使用继承的缺点</p></blockquote></li><li><p>通过继承添加的方法，不一定每个子类都会使用，使代码冗余</p></li><li>拥有太多的子类，使类冗余</li><li>对于父类的方法太过依赖，当父类的方法更改后，影响子类的重载方法</li></ul><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><blockquote><p><strong><em>协议</em></strong> 规定了用来实现某一特定功能所必须的 <strong>方法</strong>和 <strong>属性</strong>。<br>用于统一方法和属性的名称，而不实现任何功能<br>任意能够满足协议要求的类型被称为遵循(conform)这个协议。<br><strong>类</strong>，<strong>结构体</strong>、<strong>枚举类型</strong>(协议的遵守者) 都可以遵循协议，并提供具体实现来完成协议定义的方法和功能</p></blockquote><h3 id="协议的语法格式"><a href="#协议的语法格式" class="headerlink" title="协议的语法格式"></a>协议的语法格式</h3><ul><li>协议的高级使用是协议的延展以及和结构体配合</li></ul><blockquote><p>为议添加属性, 属性为可读或可写</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 协议内容</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> age:  <span class="type">Int</span> &#123; <span class="keyword">set</span> <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>定义一个接受协议的结构体</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeModel</span>: <span class="title">SomeProtocol</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> name:<span class="type">String</span> = <span class="string">""</span></span><br><span class="line">   <span class="keyword">var</span> age: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">   <span class="keyword">var</span> isYue: <span class="type">Bool</span> =  <span class="literal">false</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">init</span>(with dict:[<span class="type">String</span>:<span class="type">Any</span>])&#123;</span><br><span class="line">   <span class="keyword">self</span>.name = (dict[<span class="string">"name"</span>]<span class="keyword">as</span>?<span class="type">String</span>)??<span class="string">""</span></span><br><span class="line">   <span class="keyword">self</span>.age = (dict[<span class="string">"age"</span>]<span class="keyword">as</span>?<span class="type">Int</span>)??<span class="number">0</span></span><br><span class="line">   <span class="keyword">self</span>.isYue = (dict[<span class="string">"isYue"</span>]<span class="keyword">as</span>?<span class="type">Bool</span>)??<span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>对协议进行延展</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SomeProtocol</span></span>&#123;</span><br><span class="line"> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">test</span> <span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">self</span>.name = <span class="string">"Hello Jianjian !"</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>协议的协议</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">protocol</span> <span class="title">oneProtocol</span>: <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> date: <span class="type">Date</span> &#123; <span class="keyword">set</span> <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遵循某-多-个协议"><a href="#遵循某-多-个协议" class="headerlink" title="遵循某(多)个协议"></a>遵循某(多)个协议</h3><blockquote><p>要使类遵循某个协议，需要在类型名称后加上协议名称，中间以冒号:分隔，作为类型定义的一部分<br>遵循多个协议时，各协议之间用逗号,分隔</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct SomeStructure: FirstProtocol, AnotherProtocol &#123;</span><br><span class="line">    // 结构体内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果类在遵循协议的同时拥有父类，应该将 <strong>父类名</strong> 放在 <strong>协议名</strong> 之前，以<strong>逗号</strong>分隔</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class OneClass: OneSuperClass, OneProtocol, TwoProtocol &#123;</span><br><span class="line">    // 类的内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对属性的规定"><a href="#对属性的规定" class="headerlink" title="对属性的规定"></a>对属性的规定</h2><blockquote><p><strong>协议</strong> 用于指定特定的实例属性或类属性 协议能够要求其遵守者必须含有一些特定名称和类型的实例属性(instance property)或类属性 (type property)，<br>也能够要求属性的(设置权限)settable 和(访问权限)gettable，还必须指明是只读的还是可读可写的<br>但它不要求属性是存储型属性(stored property)还是计算型属性(calculate property)<br>协议中的通常用<strong>var</strong>来声明变量属性，在类型声明后加上{ set get }来表示属性是可读可写的，只读属性则用{ get }来表示。</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> age : <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"><span class="keyword">var</span> money: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>用类来实现协议时，使用class关键字来表示该属性为类成员<br>用结构体或枚举实现协议时，则使用static关键字来表示</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">someTypeProperty</span>: <span class="title">Int</span> </span>&#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SomeProtocol协议含有fullName属性。因此其遵循者必须含有一个名为oneName，类型为String的可读属性<br>Person结构体含有一个名为oneName的存储型属性，完整的遵循了协议。(若协议未被完整遵循，编译时则会报错)</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> oneName: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Person</span>: <span class="title">SomeProtocol</span></span>&#123;</span><br><span class="line">      <span class="keyword">var</span> oneName: <span class="type">String</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">let</span> john = <span class="type">Person</span>(oneName: “<span class="type">Chen</span> jianjian”)</span><br><span class="line">   <span class="comment">//john. oneName 为 “Chen jianjian”</span></span><br></pre></td></tr></table></figure><blockquote><p>Startship类遵循了SomeProtocol协议<br>Starship类将oneName实现为可读的计算型属性<br>它的每一个实例都有一个名为name的必备属性和一个名为prefix的可选属性<br>当prefix存在时，将prefix插入到name之前来为Starship构建oneName<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Starship</span>: <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">prefix</span>: <span class="type">String</span>?</span><br><span class="line"><span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"><span class="keyword">init</span>(name: <span class="type">String</span>, <span class="keyword">prefix</span>: <span class="type">String</span>? = <span class="literal">nil</span> ) &#123;</span><br><span class="line"><span class="keyword">self</span>.anme = name</span><br><span class="line"><span class="keyword">self</span>.<span class="keyword">prefix</span> = <span class="keyword">prefix</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> oneName: <span class="type">String</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> (<span class="keyword">prefix</span> ? <span class="keyword">prefix</span> ! + ” ” : ” “) + name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ncc1701 = <span class="type">Starship</span>(name: “<span class="type">Enterprise</span>”, <span class="keyword">prefix</span>: “<span class="type">USS</span>”)</span><br><span class="line"><span class="comment">// ncc1701. oneName == “USS Enterprise”</span></span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">classa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> marks: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> result: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">attendance</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">markssecured</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">classb</span>: <span class="title">classa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> present: <span class="type">Bool</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> subject: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> stname: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classc</span>: <span class="title">classb</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> marks = <span class="number">96</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> present = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> subject = <span class="string">"Swift 协议"</span></span><br><span class="line">    <span class="keyword">var</span> stname = <span class="string">"Protocols"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">attendance</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"The <span class="subst">\(stname)</span> has secured 99% attendance"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">markssecured</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"<span class="subst">\(stname)</span> has scored <span class="subst">\(marks)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> studdet = classc()</span><br><span class="line">studdet.stname = <span class="string">"Swift"</span></span><br><span class="line">studdet.marks = <span class="number">98</span></span><br><span class="line">studdet.markssecured()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(studdet.marks)</span><br><span class="line"><span class="built_in">print</span>(studdet.result)</span><br><span class="line"><span class="built_in">print</span>(studdet.present)</span><br><span class="line"><span class="built_in">print</span>(studdet.subject)</span><br><span class="line"><span class="built_in">print</span>(studdet.stname)</span><br><span class="line"></span><br><span class="line">以上程序执行输出结果为</span><br><span class="line"><span class="number">98</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="type">Swift</span> 协议</span><br><span class="line"><span class="type">Swift</span></span><br></pre></td></tr></table></figure><h1 id="对-Mutating-方法的规定"><a href="#对-Mutating-方法的规定" class="headerlink" title="对 Mutating 方法的规定"></a>对 Mutating 方法的规定</h1><blockquote><p>有时需要在方法中改变它的实例。<br>例如：值类型（结构体，枚举）的实例方法中，将mutating关键字作为函数的前缀，写在func之前，表示可以在该方法中修改它所属的实例及其实例属性的值</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">daysofaweek</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">days</span>: <span class="title">daysofaweek</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> sun, mon, tue, wed, thurs, fri, sat</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .sun:</span><br><span class="line">            <span class="keyword">self</span> = .sun</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Sunday"</span>)</span><br><span class="line">        <span class="keyword">case</span> .mon:</span><br><span class="line">            <span class="keyword">self</span> = .mon</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Monday"</span>)</span><br><span class="line">        <span class="keyword">case</span> .tue:</span><br><span class="line">            <span class="keyword">self</span> = .tue</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Tuesday"</span>)</span><br><span class="line">        <span class="keyword">case</span> .wed:</span><br><span class="line">            <span class="keyword">self</span> = .wed</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Wednesday"</span>)</span><br><span class="line">        <span class="keyword">case</span> .thurs:</span><br><span class="line">            <span class="keyword">self</span> = .thurs</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Wednesday"</span>)</span><br><span class="line">        <span class="keyword">case</span> .fri:</span><br><span class="line">            <span class="keyword">self</span> = .fri</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Wednesday"</span>)</span><br><span class="line">        <span class="keyword">case</span> .sat:</span><br><span class="line">            <span class="keyword">self</span> = .sat</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Saturday"</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"NO Such Day"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = days.wed</span><br><span class="line">res.show()</span><br><span class="line"></span><br><span class="line">程序执行输出结果为：<span class="type">Wednesday</span></span><br></pre></td></tr></table></figure><h1 id="对构造器的规定"><a href="#对构造器的规定" class="headerlink" title="对构造器的规定"></a>对构造器的规定</h1><blockquote><p>协议可以要求它的遵循者实现指定的构造器。<br>像书写普通的构造器那样，在协议的定义里写下构造器的声明，但不需要写花括号和构造器的实体，语法如下：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">   <span class="keyword">init</span>(someParameter: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实例</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">tcpprotocol</span> </span>&#123;</span><br><span class="line">   <span class="keyword">init</span>(aprot: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="协议构造器规定在类中的实现"><a href="#协议构造器规定在类中的实现" class="headerlink" title="协议构造器规定在类中的实现"></a>协议构造器规定在类中的实现</h1><blockquote><p>你可以在遵循该协议的类中实现构造器，并指定其为类的指定构造器或者便利构造器。在这两种情况下，你都必须给构造器实现标上”required”修饰符：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>: <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">   <span class="keyword">required</span> <span class="keyword">init</span>(someParameter: <span class="type">Int</span>) &#123;</span><br><span class="line">      <span class="comment">// 构造器实现</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">tcpprotocol</span> </span>&#123;</span><br><span class="line">   <span class="keyword">init</span>(aprot: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tcpClass</span>: <span class="title">tcpprotocol</span> </span>&#123;</span><br><span class="line">   <span class="keyword">required</span> <span class="keyword">init</span>(aprot: <span class="type">Int</span>) &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>施用required修饰符可以保证：所有的遵循该协议的子类，同样能为构造器规定提供一个显式的实现或继承实现。<br>如果一个子类重写了父类的指定构造器，并且该构造器遵循了某个协议的规定，那么该构造器的实现需要被同时标示required和override修饰符：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">tcpprotocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(no1: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mainClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> no1: <span class="type">Int</span> <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">init</span>(no1: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.no1 = no1 <span class="comment">// 初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">subClass</span>: <span class="title">mainClass</span>, <span class="title">tcpprotocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> no2: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(no1: <span class="type">Int</span>, no2 : <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.no2 = no2</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(no1:no1)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为遵循协议，需要加上"required"; 因为继承自父类，需要加上"override"</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">override</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(no1: <span class="type">Int</span>)  &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(no1:no1, no2:<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> res = mainClass(no1: <span class="number">20</span>)</span><br><span class="line"><span class="keyword">let</span> show = subClass(no1: <span class="number">30</span>, no2: <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"res is: <span class="subst">\(res.no1)</span>"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"res is: <span class="subst">\(show.no1)</span>"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"res is: <span class="subst">\(show.no2)</span>"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以上程序执行输出结果为：</span><br><span class="line"></span><br><span class="line">res <span class="keyword">is</span>: <span class="number">20</span></span><br><span class="line">res <span class="keyword">is</span>: <span class="number">30</span></span><br><span class="line">res <span class="keyword">is</span>: <span class="number">50</span></span><br></pre></td></tr></table></figure><h1 id="协议类型"><a href="#协议类型" class="headerlink" title="协议类型"></a>协议类型</h1><blockquote><p>尽管协议本身并不实现任何功能，但是协议可以被当做类型来使用<br>协议可以像其他普通类型一样使用，使用场景:</p></blockquote><ul><li>作为函数、方法或构造器中的参数类型或返回值类型</li><li>作为常量、变量或属性的类型</li><li>作为数组、字典或其他容器中的元素类型</li></ul><blockquote><p>实例</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Generator</span> </span>&#123;</span><br><span class="line">    associatedtype members</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; members?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> items = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>].makeIterator()</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> x = items.next() &#123;</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> lists <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="built_in">map</span>( &#123;i <span class="keyword">in</span> i*<span class="number">5</span>&#125;) &#123;</span><br><span class="line">    <span class="built_in">print</span>(lists)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>([<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>])</span><br><span class="line"><span class="built_in">print</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="built_in">map</span>(&#123;i <span class="keyword">in</span> i*<span class="number">10</span>&#125;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以上程序执行输出结果为：</span><br><span class="line"></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line">[<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br></pre></td></tr></table></figure><h1 id="在扩展中添加协议成员"><a href="#在扩展中添加协议成员" class="headerlink" title="在扩展中添加协议成员"></a>在扩展中添加协议成员</h1><blockquote><p>可以通过扩展来扩充已存在类型( 类，结构体，枚举等)。<br>扩展可以为已存在的类型添加属性，方法，下标脚本，协议等成员。</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AgeClasificationProtocol</span> </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> age: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">agetype</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> firstname: <span class="type">String</span></span><br><span class="line">   <span class="keyword">let</span> lastname: <span class="type">String</span></span><br><span class="line">   <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">   <span class="keyword">init</span>(firstname: <span class="type">String</span>, lastname: <span class="type">String</span>) &#123;</span><br><span class="line">      <span class="keyword">self</span>.firstname = firstname</span><br><span class="line">      <span class="keyword">self</span>.lastname = lastname</span><br><span class="line">      <span class="keyword">self</span>.age = <span class="number">10</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Person</span> : <span class="title">AgeClasificationProtocol</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">fullname</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> <span class="built_in">c</span>: <span class="type">String</span></span><br><span class="line">      <span class="built_in">c</span> = firstname + <span class="string">" "</span> + lastname</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">c</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">agetype</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> age &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>...<span class="number">2</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"Baby"</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>...<span class="number">12</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"Child"</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">13</span>...<span class="number">19</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"Teenager"</span></span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x &gt; <span class="number">65</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"Elderly"</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"Normal"</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="协议的继承"><a href="#协议的继承" class="headerlink" title="协议的继承"></a>协议的继承</h1><p>协议能够继承一个或多个其他协议，可以在继承的协议基础上增加新的内容要求。<br>协议的继承语法与类的继承相似，多个被继承的协议间用逗号分隔：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">InheritingProtocol</span>: <span class="title">SomeProtocol</span>, <span class="title">AnotherProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 协议定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实例</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Classa</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> no1: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(sum: Int)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(target: Classa)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student2</span>: <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(target: Classa)</span></span> &#123;</span><br><span class="line">        target.calc(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classb</span>: <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(target: Classa)</span></span> &#123;</span><br><span class="line">        target.calc(<span class="number">5</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">Classa</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> no1: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(sum: Int)</span></span> &#123;</span><br><span class="line">        no1 -= sum</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"学生尝试 <span class="subst">\(sum)</span> 次通过"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> no1 &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"学生缺席考试"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stmark: <span class="type">Result</span>!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(stmark: <span class="type">Result</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.stmark = stmark</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(target: Classa)</span></span> &#123;</span><br><span class="line">        stmark.<span class="built_in">print</span>(target)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> marks = <span class="type">Player</span>(stmark: <span class="type">Student2</span>())</span><br><span class="line"><span class="keyword">var</span> marksec = <span class="type">Student</span>()</span><br><span class="line"></span><br><span class="line">marks.<span class="built_in">print</span>(marksec)</span><br><span class="line">marks.<span class="built_in">print</span>(marksec)</span><br><span class="line">marks.<span class="built_in">print</span>(marksec)</span><br><span class="line">marks.stmark = <span class="type">Classb</span>()</span><br><span class="line">marks.<span class="built_in">print</span>(marksec)</span><br><span class="line">marks.<span class="built_in">print</span>(marksec)</span><br><span class="line">marks.<span class="built_in">print</span>(marksec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以上程序执行输出结果为：</span><br><span class="line"></span><br><span class="line">学生尝试 <span class="number">1</span> 次通过</span><br><span class="line">学生尝试 <span class="number">1</span> 次通过</span><br><span class="line">学生尝试 <span class="number">1</span> 次通过</span><br><span class="line">学生尝试 <span class="number">5</span> 次通过</span><br><span class="line">学生尝试 <span class="number">5</span> 次通过</span><br><span class="line">学生缺席考试</span><br><span class="line">学生尝试 <span class="number">5</span> 次通过</span><br><span class="line">学生缺席考试</span><br></pre></td></tr></table></figure><h1 id="类专属协议"><a href="#类专属协议" class="headerlink" title="类专属协议"></a>类专属协议</h1><p>你可以在协议的继承列表中,通过添加class关键字,限制协议只能适配到类（class）类型。<br>该class关键字必须是第一个出现在协议的继承列表中，其后，才是其他继承协议。格式如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeClassOnlyProtocol</span>: <span class="title">class</span>, <span class="title">SomeInheritedProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 协议定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实例</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TcpProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(no1: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> no1: <span class="type">Int</span> <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">init</span>(no1: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.no1 = no1 <span class="comment">// 初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span>: <span class="title">MainClass</span>, <span class="title">TcpProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> no2: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(no1: <span class="type">Int</span>, no2 : <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.no2 = no2</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(no1:no1)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为遵循协议，需要加上"required"; 因为继承自父类，需要加上"override"</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">override</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(no1: <span class="type">Int</span>)  &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(no1:no1, no2:<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = <span class="type">MainClass</span>(no1: <span class="number">20</span>)</span><br><span class="line"><span class="keyword">let</span> show = <span class="type">SubClass</span>(no1: <span class="number">30</span>, no2: <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"res is: <span class="subst">\(res.no1)</span>"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"res is: <span class="subst">\(show.no1)</span>"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"res is: <span class="subst">\(show.no2)</span>"</span>)</span><br><span class="line"></span><br><span class="line">以上程序执行输出结果为：</span><br><span class="line"></span><br><span class="line">res <span class="keyword">is</span>: <span class="number">20</span></span><br><span class="line">res <span class="keyword">is</span>: <span class="number">30</span></span><br><span class="line">res <span class="keyword">is</span>: <span class="number">50</span></span><br></pre></td></tr></table></figure><h1 id="九、协议合成"><a href="#九、协议合成" class="headerlink" title="九、协议合成"></a>九、协议合成</h1><p>Swift 支持合成多个协议，这在我们需要同时遵循多个协议时非常有用。<br>语法格式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protocol Stname &#123;</span><br><span class="line">    var name: String &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol Stage &#123;</span><br><span class="line">    var age: Int &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Person: Stname, Stage &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func show(celebrator: Stname &amp; Stage) &#123;</span><br><span class="line">    print(&quot;\(celebrator.name) is \(celebrator.age) years old&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let studname = Person(name: &quot;Priya&quot;, age: 21)</span><br><span class="line">print(studname)</span><br><span class="line"></span><br><span class="line">let stud = Person(name: &quot;Rehan&quot;, age: 29)</span><br><span class="line">print(stud)</span><br><span class="line"></span><br><span class="line">let student = Person(name: &quot;Roshan&quot;, age: 19)</span><br><span class="line">print(student)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以上程序执行输出结果为：</span><br><span class="line"></span><br><span class="line">Person(name: &quot;Priya&quot;, age: 21)</span><br><span class="line">Person(name: &quot;Rehan&quot;, age: 29)</span><br><span class="line">Person(name: &quot;Roshan&quot;, age: 19)</span><br></pre></td></tr></table></figure><h1 id="检验协议的一致性"><a href="#检验协议的一致性" class="headerlink" title="检验协议的一致性"></a>检验协议的一致性</h1><blockquote><p>使用is和as操作符来检查是否遵循某一协议或强制转化为某一类型。</p></blockquote><ul><li>is操作符用来检查实例是否遵循了某个协议。</li><li>as?返回一个可选值，当实例遵循协议时，返回该协议类型;否则返回nil。</li><li>as用以强制向下转型，如果强转失败，会引起运行时错误。</li></ul><blockquote><p>实例</p></blockquote><p>下面的例子定义了一个 HasArea 的协议，要求有一个Double类型可读的 area：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">HasArea</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了Circle类，都遵循了HasArea协议</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>: <span class="title">HasArea</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pi = <span class="number">3.1415927</span></span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123; <span class="keyword">return</span> pi * radius * radius &#125;</span><br><span class="line">    <span class="keyword">init</span>(radius: <span class="type">Double</span>) &#123; <span class="keyword">self</span>.radius = radius &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了Country类，都遵循了HasArea协议</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span>: <span class="title">HasArea</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(area: <span class="type">Double</span>) &#123; <span class="keyword">self</span>.area = area &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Animal是一个没有实现HasArea协议的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> legs: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(legs: <span class="type">Int</span>) &#123; <span class="keyword">self</span>.legs = legs &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objects: [<span class="type">AnyObject</span>] = [</span><br><span class="line">    <span class="type">Circle</span>(radius: <span class="number">2.0</span>),</span><br><span class="line">    <span class="type">Country</span>(area: <span class="number">243_610</span>),</span><br><span class="line">    <span class="type">Animal</span>(legs: <span class="number">4</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> object <span class="keyword">in</span> objects &#123;</span><br><span class="line">    <span class="comment">// 对迭代出的每一个元素进行检查，看它是否遵循了HasArea协议</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> objectWithArea = object <span class="keyword">as</span>? <span class="type">HasArea</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"面积为 <span class="subst">\(objectWithArea.area)</span>"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"没有面积"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以上程序执行输出结果为：</span><br><span class="line"></span><br><span class="line">面积为 <span class="number">12.5663708</span></span><br><span class="line">面积为 <span class="number">243610.0</span></span><br><span class="line">没有面积</span><br></pre></td></tr></table></figure><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-Document-Develpe文档</title>
      <link href="/2017/11/23/1/"/>
      <url>/2017/11/23/1/</url>
      <content type="html"><![CDATA[<p><a href="https://developer.apple.com/swift/" target="_blank" rel="noopener">swift4苹果开发者中心</a></p><p><a href="http://lib.csdn.net/swift/node/5?page=11#md" target="_blank" rel="noopener">swift 语法</a><br><a href="http://blog.csdn.net/a709314090/article/details/48752289" target="_blank" rel="noopener">基础</a></p><p><a href="http://swift.gg/" target="_blank" rel="noopener">Swift学习</a></p><p><a href="http://www.51ios.net/category/swiftblog" target="_blank" rel="noopener">Swift部分资料</a></p><p><a href="http://blog.csdn.net/u012647272/article/details/49660523" target="_blank" rel="noopener">第三方</a></p><p><a href="http://blog.csdn.net/qq_15024937/article/details/54865273" target="_blank" rel="noopener">第三方02</a></p><p><a href="http://blog.csdn.net/qq350116542" target="_blank" rel="noopener">这个人博客整理的很好</a></p><p><a href="http://blog.csdn.net/Xoxo_x/article/details/53023035#%E5%AF%BC%E8%88%AA%E6%A0%8F" target="_blank" rel="noopener">swift框架大全</a></p><p><a href="http://www.hangge.com/blog/cache/category_72_2.html" target="_blank" rel="noopener">swift开发博客很好滴</a></p><p><a href="http://blog.csdn.net/pj386960300/article/details/54015218" target="_blank" rel="noopener">lib</a></p><p><a href="http://blog.csdn.net/qq_15024937/article/details/54865273" target="_blank" rel="noopener">GitHub上Swift开源项目</a></p><p><a href="https://www.darkhandz.com/2017/02/06/%E5%AD%A6%E4%B9%A0RxSwift%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/" target="_blank" rel="noopener">RxSwift一篇不错的文章</a></p><p><a href="http://t.swift.gg/t/rxswift-course" target="_blank" rel="noopener">swif.gg里 小青那个牛逼货的一些学习RxSwift资料 </a></p>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Document </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-Function函数</title>
      <link href="/2017/02/05/Swift/Swift/Grammar/Function%E5%87%BD%E6%95%B0/"/>
      <url>/2017/02/05/Swift/Swift/Grammar/Function%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="①-函数定义-amp-amp-形式"><a href="#①-函数定义-amp-amp-形式" class="headerlink" title="① 函数定义&amp;&amp;形式"></a>① 函数定义&amp;&amp;形式</h1><blockquote><p>Swift的函数和C的函数定义方式有区别，<br>Swift将返回类型写在函数的最后</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span>函数名 <span class="params">(参数列表)</span></span> -&gt; 返回值 &#123;</span><br><span class="line">       <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>函数输入一个字符串，然后打印出这个字符串，并且返回一个字符串</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printYourName</span> <span class="params">(name: String)</span></span>-&gt;<span class="type">String</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello, "</span> + name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = printYourName(name: <span class="string">"Tom"</span>)   <span class="comment">//函数调用</span></span><br><span class="line"><span class="built_in">print</span>(s)    <span class="comment">//打印 Hello, Tom</span></span><br></pre></td></tr></table></figure><blockquote><p>函数返回值：函数返回值用-&gt;后跟类型说明符号<br>函数的多返回值。可以用元组返回复合多值。当然也可以没有返回值<br>复制代码<br>一个函数没有返回值，那么从 -&gt; 返回值 这个部分可以省略</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printYourName</span> <span class="params">(name: String)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有多个参数</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printTwoString</span><span class="params">(firstString: String, secondString: String)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(firstString,secondString)</span><br><span class="line">&#125;</span><br><span class="line">printTwoString(firstString: <span class="string">"hello"</span>, secondString: <span class="string">"Kate"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>函数参数默认为let类型的<br>如果你想更改参数副本，那么你要显示使用var修饰<br>当然也可以不需要参数的函数<br>如果你像更改参数作为输入输出用inout,调用时候要用取地址符号&amp;</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">GetName</span><span class="params">(<span class="keyword">inout</span> strName:String)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    strName += <span class="string">" hello"</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> strTest = <span class="string">"oo"</span></span><br><span class="line"><span class="type">GetName</span>(&amp;strTest)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"<span class="subst">\(strTest)</span>"</span>)</span><br></pre></td></tr></table></figure><h1 id="Function-Argument-Labels-and-Parameter-Names"><a href="#Function-Argument-Labels-and-Parameter-Names" class="headerlink" title="Function Argument Labels and Parameter Names"></a>Function Argument Labels and Parameter Names</h1><blockquote><p>在函数定义时候，参数列表中使用的fristString和secondString称为参数(Parameter).但是参数包含了两个东西</p></blockquote><blockquote><p>1是Argument Label，它是在方法调用的时候写在参数值前面的参数标记，比如下面调用中的firstString和secondString</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">printTwoString(firstString: <span class="string">"hello"</span>, </span><br><span class="line">               secondString: <span class="string">"Kate"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>2是Parameter Names，它只的是在方法体里面使用到的参数标志<br> printTwoString方法体里面print种使用到的firstString,secondString</p></blockquote><blockquote><p>默认情况下，Argument Label和Parameter Names是一样的。但是你也可以自定义Argument Label，方法是在Parameter Names前面加上另外一个字符串，并用空格相隔，如下，begin是自定义的Argument Label，然后调用的时候就需要使用begin来指定参数</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printTwoString</span><span class="params">(begin firstString: String, secondString: String)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(firstString,secondString)</span><br><span class="line">&#125;</span><br><span class="line">printTwoString(begin: <span class="string">"hello"</span>, secondString: <span class="string">"Kate"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>使用print的时候没有加上任何的Argument Label。如果你不想要Argument Label，那么在定义方法的时候，将Argument Label的字符串写为下划线 _ </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printTwoString</span><span class="params">(firstString: String, <span class="number">_</span> secondString: String)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(firstString,secondString)</span><br><span class="line">&#125;</span><br><span class="line">printTwoString(firstString: <span class="string">"hello"</span>,  <span class="string">"Kate"</span>)  <span class="comment">//忽略了第二参数的外部参数名之后，这里就不能加上外部参数名了</span></span><br></pre></td></tr></table></figure><h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><blockquote><p>可以给参数赋值默认值。具有默认值的参数，在调用的时候，可以不用给它赋值。好比print方法，它的原型是</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">_</span>:separator:terminator:)</span><br></pre></td></tr></table></figure><blockquote><p>但是一般使用的时候都只传了一个字符串，原因就在于它后面的两个参数都是具有默认值的。<br>给参数设置默认值的方法是在方法定义的时候，在参数的后面用 = 加上默认值。<br>如下代码。官方文档建议我们把带默认值的参数放在参数列表的末尾，这样在调用的时候不至于混淆。但是其实可以对每个参数都赋值默认值。比如下面的例子</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printTwoString</span><span class="params">(firstString: String = <span class="string">"hello"</span>, secondString: String = <span class="string">"Lucy"</span>, thirdString: String = <span class="string">"end"</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(firstString,secondString,thirdString)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printTwoString( secondString:<span class="string">"two"</span>) </span><br><span class="line"> <span class="comment">//使用外部参数名指定要赋值的参数，其他参数使用默认值，输出 hello two end</span></span><br></pre></td></tr></table></figure><blockquote><p>值得注意的是，如果没有默认值的参数在调用的时候也没有给其赋值，那么会在编译的时候报错。<br>如果你又把参数列表的Argument Label都去掉的话，那么在调用的时候，你给的参数将会从头开始匹配。如果参数类型不匹配的话，就会报错。当然，不建议大家这样做，因为会导致程序的可读性变差</p></blockquote><h1 id="可变参数列表"><a href="#可变参数列表" class="headerlink" title="可变参数列表"></a>可变参数列表</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printStrings</span><span class="params">(strings: String...)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(strings)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printStrings(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>)  <span class="comment">//输出 ["1", "2", "3"]</span></span><br></pre></td></tr></table></figure><blockquote><p>通过输出我们可以看到，可变参数在函数体内是以数组的类型存在的。这点在官方文档上有说明</p></blockquote><h1 id="In-Out-参数"><a href="#In-Out-参数" class="headerlink" title="In-Out 参数"></a>In-Out 参数</h1><blockquote><p>在默认的情况下，参数传递给方法后都是常量，也就是说不能在函数体里面对参数进行修改。这个常量是个形参，不是之前的实参</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(first: Int, <span class="number">_</span> second: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    first = <span class="number">2</span>  <span class="comment">//这句报错</span></span><br><span class="line">    <span class="keyword">return</span> first + second</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有一种情况，我们希望在方法里面改变实参的值，所以有了inout关键字，这个关键字不能对可变参数添加，同时加上了这个keyword之后，不能再添加 var let，也不能有默认值。<br>然后调用的时候，这个参数必须传递一个变量，而不能是常量，并且在变量前加&amp;</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(first: <span class="keyword">inout</span> Int, <span class="number">_</span> second: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    first = <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> first + second</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"result = <span class="subst">\(add(first: &amp;a, <span class="number">3</span>)</span>), a = <span class="subst">\(a)</span> "</span> )<span class="comment">//输出 result = 5, a = 2</span></span><br></pre></td></tr></table></figure><blockquote><p>关于In-Out，这个实现原理是先将实参copy，然后在方法体内处理，方法结束的时候，再把copy覆盖回原来的实参。所以如果你在方法体里面去改变实参（通过某些方法获得），那么在方法结束的时候，你对实参的改变会被形参覆盖。建议不要在方法体里面操作InOut参数的实参。</p></blockquote><p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID545" target="_blank" rel="noopener">关于InOut参数的捕获问题请参见官方文档</a></p><h1 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h1><blockquote><p>函数也是一种类型。函数类型由函数定义决定</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(first: <span class="keyword">inout</span> Int, <span class="number">_</span> second: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    first = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> first + second</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>它的函数类型为 (inout Int, Int) -&gt; Int<br>如果没有参数也没有返回值的函数，函数类型为 () -&gt; void，也可以写为 () -&gt; ()<br>函数类型可以和基本类型一样，用来定义变量。继续利用上面定义的add函数</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mathFunc : (<span class="keyword">inout</span> <span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span> = add</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> s = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> result = mathFunc(&amp;f,s)  <span class="comment">//使用函数类型</span></span><br></pre></td></tr></table></figure><blockquote><p>函数类型可以用做参数或返回值，利用上面定义的mathFunc变量，可以有</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(first: <span class="keyword">inout</span> Int, <span class="number">_</span> second: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    first = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> first + second</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mathFunc : (<span class="keyword">inout</span> <span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span> = add</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doMath</span><span class="params">(mathFunc: <span class="params">(<span class="keyword">inout</span> Int, Int)</span></span></span> -&gt; <span class="type">Int</span>, first: <span class="keyword">inout</span> <span class="type">Int</span>, second: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"mathFunc = <span class="subst">\(mathFunc(&amp;first,second)</span>)"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"first = <span class="subst">\(first)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> s = <span class="number">2</span>;</span><br><span class="line">doMath(mathFunc: mathFunc, first: &amp;f, second: <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"f = <span class="subst">\(f)</span>"</span>)</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//mathFunc = 4</span></span><br><span class="line"><span class="comment">//first=2</span></span><br><span class="line"><span class="comment">//f=2</span></span><br></pre></td></tr></table></figure><h1 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h1><blockquote><p>在函数里面再定义函数。这个嵌套函数可以在函数内部调用，也可以作为返回值返回，使得它可以在其他范围内进行使用。例子如下<br>//定义了add 和 sub 两个嵌套函数，然后用于返回。如果输入的不是”+“或”-“，那么返回一个nil。注意giveMeFunc返回的是一个函数类型的可选类型</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">giveMeFunc</span><span class="params">(opt: Character)</span></span> -&gt; ((<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>)? &#123;</span><br><span class="line">    <span class="keyword">var</span> method : ((<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>)?</span><br><span class="line">    <span class="keyword">switch</span> opt &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"+"</span> :</span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(one: Int, <span class="number">_</span> two: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> one + two &#125;</span><br><span class="line">        method = add</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"-"</span> :</span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(one: Int, <span class="number">_</span> two: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> one - two &#125;</span><br><span class="line">        method = sub</span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">        method = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> method</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> m = giveMeFunc(opt:<span class="string">"-"</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(m(<span class="number">1</span>, <span class="number">2</span>))  <span class="comment">// 打印  -1, 留意一下，这里没有Argument Label。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="操作符方法（Operator-Methods）"><a href="#操作符方法（Operator-Methods）" class="headerlink" title="操作符方法（Operator Methods）"></a>操作符方法（Operator Methods）</h1><blockquote><p>swift和C++一样，可以定义操作符函数。操作符指的是+，-，/，%，+=等等。一般我们这些操作符是给数字类型使用的。但是有了操作符函数之后，我们可以自定义这类符号的运算规则。下面是官方的示例</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector2D</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Vector2D</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> + <span class="params">(<span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Vector2D</span>(x: <span class="keyword">left</span>.x + <span class="keyword">right</span>.x, y: <span class="keyword">left</span>.y + <span class="keyword">right</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的例子定义了一个操作符函数 + ，这个操作符函数的参数列表里面有两个参数left和right。分别代表着+号左右两边的两个参数。通过这个函数，我们可以直接将两个Vector示例进行相加。如下：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vector = <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">let</span> anotherVector = <span class="type">Vector2D</span>(x: <span class="number">2.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> combinedVector = vector + anotherVector</span><br><span class="line"><span class="comment">// combinedVector is a Vector2D instance with values of (5.0, 5.0)</span></span><br></pre></td></tr></table></figure><blockquote><p>除了这种要接受两个参数的操作符之外，还要一些只有一个参数的操作符，比如 -，++，–等等。但是这类操作符有两类：前缀（Prefix）和后缀（Postfix），比如–a，i++；<br>这类操作符的定义要加上prefix或postfix关键字。语法如下</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Vector2D</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">prefix</span> <span class="function"><span class="keyword">func</span> - <span class="params">(vector: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Vector2D</span>(x: -vector.x, y: -vector.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面定义了一个前缀的 - 操作符函数。用来将一个向量取反。后置操作符的关键字是postfix，中间操作符的关键字是infix</p></blockquote><blockquote><p>另外还有一种计算并赋值的操作符，比如++，+=等等。这类的操作符会对其中的一个操作对象进行操作后的赋值。所以必须将参数设置为inout</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Vector2D</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> += <span class="params">(<span class="keyword">left</span>: <span class="keyword">inout</span> Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> &#123;</span><br><span class="line">        <span class="keyword">left</span> = <span class="keyword">left</span> + <span class="keyword">right</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>除了Swift已经定义的操作符之外，还可以自己定义操作符。比如下面定义了一个+++操作符</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">prefix</span> <span class="keyword">operator</span> +++ </span><br><span class="line"> </span><br><span class="line"> 上面的只是定义，我们还需要实现这个操作符所做的</span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">extension</span> <span class="title">Vector2D</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">prefix</span> <span class="function"><span class="keyword">func</span> +++ <span class="params">(vector: <span class="keyword">inout</span> Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">        vector += vector</span><br><span class="line">        <span class="keyword">return</span> vector</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是这个自定义的操作符有一些规定。<br>自定义的操作符可以由/, =, -, +, !, *, %, &lt;, &gt;, &amp;, |, ^, ?,~，和某些Unicode 字符开始，至于是哪些字符可以参考官网。点击网页，在网页最下面<br>在这些字符之后，可以接上unicode字符。<br>另外有一些禁止的规定：<br>1.不能重写一个单单的 ? 号。（可以在字符里面加入?号）<br>2.不能重写这些操作符 =, -&gt;, //, /, /, ., 但是可以重写两个或更多个点的操作符。</p><ol start="3"><li>不能以这些字符开头 ?, &lt;， &amp;<br>4.不能以这些字符结尾 ?， &gt;， !</li></ol></blockquote><p>在定义的操作符的时候末尾的那对大括号是有用的。在数学上，加减乘除是有优先级和结合规则的。同样的，这里的操作符也是。我们可以在定义操作符的大括号里面定义这个操作符的优先级和结合规律</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> +-: <span class="type">AdditionPrecedence</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Vector2D</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> +- <span class="params">(<span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Vector2D</span>(x: <span class="keyword">left</span>.x + <span class="keyword">right</span>.x, y: <span class="keyword">left</span>.y - <span class="keyword">right</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子定义的是一个中间的操作符，它的结合规则是向左结合。优先级是AdditionPrecedence组，这个参考下面的Precedence Group Declaration链接。<br>前置操作符和后置操作符不能指定优先级，它们作用在同一个操作数，那么先执行后置操作符。</p><p><a href="http://blog.csdn.net/a709314090/article/details/74007109" target="_blank" rel="noopener">wen</a></p><p><a href="http://www.cnblogs.com/zhidao-chen/p/3868411.html" target="_blank" rel="noopener"></a></p>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-Grammar-类和结构体</title>
      <link href="/2017/02/02/Swift/Swift/Grammar/Struct%20&amp;&amp;%20Class%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB/"/>
      <url>/2017/02/02/Swift/Swift/Grammar/Struct%20&amp;&amp;%20Class%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h1 id="①定义"><a href="#①定义" class="headerlink" title="①定义"></a>①定义</h1><blockquote><p>结构体struct</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SForm</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> iXX:<span class="type">Int</span> = <span class="number">99</span></span><br><span class="line">    <span class="keyword">var</span> strHello:<span class="type">String</span> = <span class="string">"dsf"</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testFunc</span><span class="params">(iXX:Int)</span></span>-&gt;<span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iXX+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类class</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTset</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> iAge:<span class="type">Int</span> = <span class="number">9</span></span><br><span class="line">    <span class="keyword">var</span> strName:<span class="type">String</span> = <span class="string">"xx"</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testFunction</span><span class="params">(iAge:Int)</span></span>-&gt;<span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iAge+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testFunctionName</span><span class="params">(strName:String)</span></span>-&gt;<span class="type">String</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"oo"</span>+strName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="②实例"><a href="#②实例" class="headerlink" title="②实例"></a>②实例</h1><blockquote><p>结构体struct</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> structObj = <span class="type">SForm</span>()</span><br><span class="line">structObj.iXX = <span class="number">988</span></span><br><span class="line"><span class="keyword">let</span> iRes = structObj.testFunc(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><blockquote><p>类class</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> clsObj = <span class="type">CTset</span>()</span><br><span class="line">clsObj.iAge = <span class="number">987</span></span><br><span class="line"><span class="keyword">let</span> iRe:<span class="type">Int</span> = clsObj.testFunction(<span class="number">32</span>)</span><br><span class="line"><span class="keyword">let</span> iStr:<span class="type">String</span> = clsObj.testFunctionName(<span class="string">"sdf"</span>)</span><br></pre></td></tr></table></figure><h1 id="③初始化"><a href="#③初始化" class="headerlink" title="③初始化"></a>③初始化</h1><blockquote><p>结构体有一个自动生成的初始化器<br>新实例中各个属性的初始值可以通过属性的名称传递到成员逐一初始化器之中</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">var objFirst = SForm(iXX:983, strHello:&quot;hel&quot;)</span><br><span class="line">objFirst.iXX = 87</span><br><span class="line"></span><br><span class="line">let objSecond = SForm(iXX:94, strHello:&quot;hwxel&quot;)</span><br><span class="line">//objSecond.iXX = 876 error</span><br></pre></td></tr></table></figure><h1 id="④类型"><a href="#④类型" class="headerlink" title="④类型"></a>④类型</h1><blockquote><p>结构体是值类型</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> objFirst = <span class="type">SForm</span>(iXX:<span class="number">983</span>, strHello:<span class="string">"hel"</span>)</span><br><span class="line"><span class="keyword">var</span> objSecond = objFirst</span><br><span class="line">objSecond.iXX = <span class="number">5775</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"objFirst: <span class="subst">\(objFirst.iXX)</span>  objSecond:<span class="subst">\(objSecond.iXX)</span>"</span>)</span><br><span class="line"></span><br><span class="line">输出：objFirst: <span class="number">983</span>  objSecond:<span class="number">5775</span></span><br></pre></td></tr></table></figure><blockquote><p>类是引用类型</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> clsObj = <span class="type">CTset</span>()</span><br><span class="line">clsObj.iAge = <span class="number">987</span></span><br><span class="line"><span class="keyword">var</span> clsObjEx:<span class="type">CTset</span> = clsObj</span><br><span class="line">clsObjEx.iAge = <span class="number">874</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"<span class="subst">\(clsObj.iAge)</span>  <span class="subst">\(clsObjEx.iAge)</span>"</span>)</span><br><span class="line">输出：clsObj: <span class="number">874</span> clsObjEx: <span class="number">874</span></span><br></pre></td></tr></table></figure><h1 id="⑤运算"><a href="#⑤运算" class="headerlink" title="⑤运算"></a>⑤运算</h1><blockquote><p>类的等价于运算  === 与 不等价于 !== 运算<br>表示是否是引用到同一个类对象</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> clsObj = <span class="type">CTset</span>()</span><br><span class="line">clsObj.iAge = <span class="number">987</span></span><br><span class="line"><span class="keyword">var</span> clsObjEx:<span class="type">CTset</span> = clsObj</span><br><span class="line">clsObjEx.iAge = <span class="number">874</span></span><br><span class="line"><span class="keyword">if</span> clsObj === clsObjEx &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"obj same"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类和结构体区别"><a href="#类和结构体区别" class="headerlink" title="类和结构体区别"></a>类和结构体区别</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">结构体是值类型，结构体的赋值意味着拷贝行为的发生</span><br><span class="line">而类是引用类型</span><br></pre></td></tr></table></figure><h1 id="集合类型的赋值和拷贝行为"><a href="#集合类型的赋值和拷贝行为" class="headerlink" title="集合类型的赋值和拷贝行为"></a>集合类型的赋值和拷贝行为</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">swift的 数组 和 字典 都是以 值类型 传递的</span><br></pre></td></tr></table></figure><blockquote><p>字典的拷贝</p></blockquote><ul><li>当有字典实例的赋值或者是字典做参数的函数调用时候，字典即发生拷贝行为</li><li>字典的key和value的拷贝行为是依赖于她自身到底是引用属性还是值类型</li></ul><blockquote><p>dicSecond的值被更新，而dicFirst的值依然保持不变<br>dicFirst和dicSecond是两个独立的字典<br>它的key和value在赋值时候发生了拷贝，因为都是String类型。</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> dicFirst:<span class="type">Dictionary</span> = [<span class="string">"key1"</span>:<span class="string">"value1"</span>, <span class="string">"key2"</span>:<span class="string">"value2"</span>]</span><br><span class="line"><span class="keyword">var</span> dicSecond:<span class="type">Dictionary</span> = dicFirst</span><br><span class="line">dicSecond[<span class="string">"key1"</span>] = <span class="string">"value1Update"</span></span><br></pre></td></tr></table></figure><blockquote><p>两个字典dicFirst 和 dicSecond分别为不同的字典，但它的值 clsObjFirst的地址却是同一个<br>因为它是类类型，是引用传递</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">lass <span class="type">CTset</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> iAge:<span class="type">Int</span> = <span class="number">9</span></span><br><span class="line">    <span class="keyword">var</span> strName:<span class="type">String</span> = <span class="string">"xx"</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testFunction</span><span class="params">(iAge:Int)</span></span>-&gt;<span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iAge+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testFunctionName</span><span class="params">(strName:String)</span></span>-&gt;<span class="type">String</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"oo"</span>+strName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> clsObjFirst = <span class="type">CTset</span>()</span><br><span class="line">clsObjFirst.iAge = <span class="number">443</span></span><br><span class="line"><span class="keyword">var</span> dicFirst:<span class="type">Dictionary</span> = [<span class="string">"key1"</span>:clsObjFirst]</span><br><span class="line"><span class="keyword">var</span> dicSecond:<span class="type">Dictionary</span> = dicFirst</span><br></pre></td></tr></table></figure><h2 id="数组的赋值与拷贝"><a href="#数组的赋值与拷贝" class="headerlink" title="数组的赋值与拷贝"></a>数组的赋值与拷贝</h2><ul><li>数组的拷贝行为只有在数组的长度发生变化的时候才会拷贝</li><li>当然数组里面的内容，是要遵循引用类型还是值类型的。</li></ul><blockquote><p>arrayFirst[0]和arraySecond[0] 都会被修改成 89<br>因为数组长度没变化，所以没发生拷贝</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayFirst = [<span class="number">1</span>, <span class="number">33</span>]</span><br><span class="line"><span class="keyword">var</span> arraySecond = arrayFirst</span><br><span class="line">arraySecond[<span class="number">0</span>] = <span class="number">89</span></span><br></pre></td></tr></table></figure><blockquote><p>长度变化，arrayFirst拷贝，独立另外一个数组</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayFirst = [<span class="number">1</span>, <span class="number">33</span>]</span><br><span class="line"><span class="keyword">var</span> arraySecond = arrayFirst</span><br><span class="line">arrayFirst.append(<span class="number">222</span>)<span class="comment">//长度变化，arrayFirst拷贝，独立另外一个数组</span></span><br><span class="line">arrayFirst[<span class="number">0</span>] = <span class="number">99</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"first:<span class="subst">\(arrayFirst)</span>\nsecond:<span class="subst">\(arraySecond)</span>"</span>)</span><br><span class="line">输出：</span><br><span class="line">first:[<span class="number">99</span>, <span class="number">33</span>, <span class="number">222</span>]</span><br><span class="line">second:[<span class="number">1</span>, <span class="number">33</span>]</span><br></pre></td></tr></table></figure><blockquote><p>在用多个变量(var)引用一个数组时候，可以用unshare()方法，强制拷贝数组</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrayFirst = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">var</span> arraySecond = arrayFirst</span><br><span class="line"><span class="keyword">var</span> arrayThird = arrayFirst</span><br><span class="line">arraySecond.unshare()<span class="comment">//拷贝独立成另外个数组</span></span><br><span class="line">arrayThird.unshare()<span class="comment">//拷贝独立成另外个数组</span></span><br><span class="line">arrayFirst[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">arraySecond[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">arrayThird[<span class="number">0</span>]=<span class="number">5</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"first:<span class="subst">\(arrayFirst)</span>\nsecond:<span class="subst">\(arraySecond)</span> \nthird:<span class="subst">\(arrayThird)</span>"</span>)</span><br><span class="line">输出：</span><br><span class="line">first:[<span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">second:[<span class="number">4</span>, <span class="number">2</span>] </span><br><span class="line">third:[<span class="number">5</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><h2 id="数组等价于-和不等价于"><a href="#数组等价于-和不等价于" class="headerlink" title="数组等价于(===)和不等价于(!==)"></a>数组等价于(===)和不等价于(!==)</h2><h2 id="强制复制数组"><a href="#强制复制数组" class="headerlink" title="强制复制数组"></a>强制复制数组</h2><blockquote><p>通过copy强制复制数组，进行的是数组类容浅拷贝，并返回个新的数组引用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> arraySource = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> arrayCopy = arraySource.copy()</span><br><span class="line">arraySource[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">arrayCopy[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"source:<span class="subst">\(arraySource)</span>\n copy:<span class="subst">\(arrayCopy)</span>"</span>)</span><br><span class="line">输出：</span><br><span class="line">source:[<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>] </span><br><span class="line">copy:[<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/zhidao-chen/p/3881410.html" target="_blank" rel="noopener">more</a></p><p>===========================================</p><h1 id="类和结构体对比"><a href="#类和结构体对比" class="headerlink" title="类和结构体对比"></a>类和结构体对比</h1><h2 id="类和结构体的共同点在于"><a href="#类和结构体的共同点在于" class="headerlink" title="类和结构体的共同点在于"></a>类和结构体的共同点在于</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">定义属性用于存储值</span><br><span class="line">定义方法用于提供功能</span><br><span class="line">定义附属脚本用于访问值</span><br><span class="line">定义构造器用于生成初始化值</span><br><span class="line">通过扩展以增加默认实现的功能</span><br><span class="line">实现协议以提供某种标准功能</span><br></pre></td></tr></table></figure><h2 id="与结构体相比，类有如下的附加功能"><a href="#与结构体相比，类有如下的附加功能" class="headerlink" title="与结构体相比，类有如下的附加功能"></a>与结构体相比，类有如下的附加功能</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">继承允许一个类继承另一个类的特征</span><br><span class="line">类型转换允许在运行时检查和解释一个类实例的类型</span><br><span class="line">析构器允许一个类实例释放任何其所被分配的资源</span><br><span class="line">引用计数允许对一个类的多次引用</span><br></pre></td></tr></table></figure><blockquote><p>结构体总是通过被复制的方式在代码中传递，不使用引用计数</p></blockquote><h1 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h1><h2 id="使用关键字class和struct表示类和结构体"><a href="#使用关键字class和struct表示类和结构体" class="headerlink" title="使用关键字class和struct表示类和结构体"></a>使用关键字class和struct表示类和结构体</h2><blockquote><p>每次定义一个新类或者结构体的时候，实际上你是定义了一个新的Swift类型<br>因此使用UpperCamelCase这种方式来命名（如SomeClass和SomeStructure等），以便符合标准Swift类型的大写命名风格（如String，Int和Bool）<br>相反的，请使用lowerCamelCase这种方式为属性和方法命名（如framerate和incrementCount），以便和类型名区分</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Resolution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> height = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoMode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resolution = <span class="type">Resolution</span>()</span><br><span class="line">    <span class="keyword">var</span> interlaced = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> frameRate = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?       <span class="comment">// 可选类型，自动赋值为nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类和结构实例"><a href="#类和结构实例" class="headerlink" title="类和结构实例"></a>类和结构实例</h1><blockquote><p>结构体和类都使用构造器语法来生成新的实例<br>构造器语法的最简单形式是在结构体或者类的类型名称后跟随一对空括号，如Resolution()或VideoMode()<br>通过这种方式所创建的类或者结构体实例，其属性均会被初始化为默认值<br>属性都必须赋初值！否则编译报错，可选类型可不赋值，实际上默认赋值为nil</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Resolution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> height = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoMode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resolution = <span class="type">Resolution</span>()</span><br><span class="line">    <span class="keyword">var</span> interlaced = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> frameRate = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?       <span class="comment">// 可选类型，自动赋值为nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r = <span class="type">Resolution</span>()</span><br><span class="line"><span class="keyword">let</span> v = <span class="type">VideoMode</span>()</span><br><span class="line"><span class="built_in">print</span>(r)    <span class="comment">// Resolution(width: 0, height: 0)</span></span><br><span class="line"><span class="built_in">print</span>(v)    <span class="comment">// VideoMode</span></span><br><span class="line"><span class="built_in">print</span>(v.resolution)     <span class="comment">// Resolution(width: 0, height: 0)</span></span><br><span class="line"><span class="built_in">print</span>(v.interlaced)     <span class="comment">// false</span></span><br><span class="line"><span class="built_in">print</span>(v.frameRate)      <span class="comment">// 0.0</span></span><br><span class="line"><span class="built_in">print</span>(v.name)           <span class="comment">// nil</span></span><br></pre></td></tr></table></figure><h1 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h1><blockquote><p>通过使用点语法（dot syntax），你可以访问实例的属性<br>其语法规则是，实例名后面紧跟属性名，两者通过点号(.)连接<br>也可以使用点语法访问子属性。也可以使用点语法为变量属性赋值</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">&gt;与<span class="type">Objective</span>-<span class="type">C</span>语言不同的是，<span class="type">Swift</span>允许直接设置结构体属性的子属性，并不需要重新为整个resolution属性设置新值</span><br></pre></td></tr></table></figure><p>struct Resolution {<br>    var width = 0<br>    var height = 0<br>}</p><p>class VideoMode {<br>    var resolution = Resolution()<br>    var interlaced = false<br>    var frameRate = 0.0<br>    var name: String?       // 可选类型，自动赋值为nil<br>}</p><p>let v = VideoMode()<br>print(v.resolution)    // Resolution(width: 0, height: 0)<br>v.resolution.width = 1920<br>v.resolution.height = 1080<br>print(v.resolution.width)   // 1920<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 结构体类型的成员逐一构造器</span><br><span class="line">&gt; 所有结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性</span><br><span class="line">&gt; 新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器之中</span><br><span class="line">&gt; 与结构体不同，类实例没有默认的成员逐一构造器</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line">struct Resolution &#123;</span><br><span class="line">    var width = 0</span><br><span class="line">    var height = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var r = Resolution(width: 1920, height: 1080)</span><br><span class="line">print(r)    // Resolution(width: 1920, height: 1080)</span><br></pre></td></tr></table></figure></p><h1 id="结构体和枚举是值类型"><a href="#结构体和枚举是值类型" class="headerlink" title="结构体和枚举是值类型"></a>结构体和枚举是值类型</h1><blockquote><p>值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝<br>面我们已经大量使用了值类型。实际上，在 Swift中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是以结构体的形式所实现。<br>在Swift中，所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Resolution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> height = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r = <span class="type">Resolution</span>(width: <span class="number">1920</span>, height: <span class="number">1080</span>)</span><br><span class="line"><span class="built_in">print</span>(r)    <span class="comment">// Resolution(width: 1920, height: 1080)</span></span><br><span class="line"><span class="keyword">var</span> rr = r</span><br><span class="line"><span class="built_in">print</span>(rr)   <span class="comment">// Resolution(width: 1920, height: 1080)，两个完全独立的实例碰巧包含有相同的数值</span></span><br><span class="line">rr.width = <span class="number">2048</span></span><br><span class="line"><span class="built_in">print</span>(r)    <span class="comment">// Resolution(width: 1920, height: 1080)，由于r和rr相互独立，所以值不改变</span></span><br><span class="line"><span class="built_in">print</span>(rr)   <span class="comment">// Resolution(width: 2048, height: 1080)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">North</span>, <span class="type">South</span>, <span class="type">East</span>, <span class="type">West</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="type">CompassPoint</span>.<span class="type">North</span></span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line"><span class="built_in">print</span>(b)    <span class="comment">// South</span></span><br><span class="line">b = <span class="type">CompassPoint</span>.<span class="type">South</span></span><br><span class="line"><span class="built_in">print</span>(a)    <span class="comment">// North</span></span><br><span class="line"><span class="built_in">print</span>(b)    <span class="comment">// South</span></span><br></pre></td></tr></table></figure><h1 id="类是引用类型"><a href="#类是引用类型" class="headerlink" title="类是引用类型"></a>类是引用类型</h1><blockquote><p>与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Resolution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> height = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoMode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resolution = <span class="type">Resolution</span>()</span><br><span class="line">    <span class="keyword">var</span> interlaced = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> frameRate = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?       <span class="comment">// 可选类型，自动赋值为nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="type">VideoMode</span>()</span><br><span class="line">a.frameRate = <span class="number">25</span>    <span class="comment">// a是常量，但是可以修改属性，因为a本身没有改变</span></span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">b.frameRate = <span class="number">30</span></span><br><span class="line"><span class="built_in">print</span>(a.frameRate)  <span class="comment">// 30.0</span></span><br><span class="line"><span class="comment">// a = VideoMode()     // error: cannot assign to value: 'a' is a 'let' constant</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，a和b被声明为常量而不是变量。然而你依然可以改变a.frameRate和b.frameRate，因为a和b这两个常量的值并未改变。它们并不“存储”这个VideoMode实例，而仅仅是对VideoMode实例的引用。所以，改变的是被引用的VideoMode的frameRate属性，而不是引用VideoMode的常量的值</p></blockquote><h1 id="恒等运算符"><a href="#恒等运算符" class="headerlink" title="恒等运算符"></a>恒等运算符</h1><blockquote><p>因为类是引用类型，有可能有多个常量和变量在幕后同时引用同一个类实例。（对于结构体和枚举来说，这并不成立。因为它们作为值类型，在被赋予到常量、变量或者传递到函数时，其值总是会被拷贝。）<br>如果能够判定两个常量或者变量是否引用同一个类实例将会很有帮助。为了达到这个目的，Swift内建了两个恒等运算符运用这两个运算符检测两个常量或者变量是否引用同一个实例</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">等价于（===）</span><br><span class="line">不等价于（!==）</span><br></pre></td></tr></table></figure><h2 id="等价于”（用三个等号表示，-）与“等于”（用两个等号表示，-）的不同"><a href="#等价于”（用三个等号表示，-）与“等于”（用两个等号表示，-）的不同" class="headerlink" title="等价于”（用三个等号表示，===）与“等于”（用两个等号表示，==）的不同"></a>等价于”（用三个等号表示，===）与“等于”（用两个等号表示，==）的不同</h2><blockquote><p>等价于”表示两个类类型（class type）的常量或者变量引用同一个类实例。<br>“等于”表示两个实例的值“相等”或“相同”，判定时要遵照设计者定义的评判标准，因此相对于“相等”来说，这是一种更加合适的叫法<br>当你在定义你的自定义类和结构体的时候，你有义务来决定判定两个实例“相等”的标准</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Resolution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> height = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoMode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resolution = <span class="type">Resolution</span>()</span><br><span class="line">    <span class="keyword">var</span> interlaced = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> frameRate = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?       <span class="comment">// 可选类型，自动赋值为nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="type">VideoMode</span>()</span><br><span class="line">a.frameRate = <span class="number">25</span>    <span class="comment">// a是常量，但是可以修改属性，因为a本身没有改变</span></span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">b.frameRate = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if a == b &#123;     // 两个引用类型之间使用“==”运算符，会出现编译错误：error: binary operator '==' cannot be applied to two 'VideoMode' operands</span></span><br><span class="line"><span class="keyword">if</span> a === b &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"a === b"</span>)    <span class="comment">// a === b</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"a !== b"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">如果你有<span class="type">C</span>、<span class="type">C</span>++或者<span class="type">Objective</span>-<span class="type">C</span>语言的经验，那么你也许会知道这些语言使用指针来引用内存中的地址。一个引用某个引用类型实例的<span class="type">Swift</span>常量或者变量，与<span class="type">C</span>语言中的指针类似，但是并不直接指向某个内存地址，也不要求你使用星号（*）来表明你在创建一个引用。<span class="type">Swift</span>中的这些引用与其它的常量或变量的定义方式相同</span><br></pre></td></tr></table></figure><h1 id="类和结构体的选择"><a href="#类和结构体的选择" class="headerlink" title="类和结构体的选择"></a>类和结构体的选择</h1><p>可以使用类和结构体来定义你的自定义数据类型。然而，结构体实例总是通过值传递，类实例总是通过引用传递。这意味两者适用不同的任务。当你在考虑一个工程项目的数据结构和功能的时候，你需要决定每个数据结构是定义成类还是结构体。按照通用的准则，当符合一条或多条以下条件时，请考虑构建结构体：</p><pre><code>该数据结构的主要目的是用来封装少量相关简单数据值。有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。该数据结构不需要去继承另一个既有类型的属性或者行为。</code></pre><p>举例来说，以下情境中适合使用结构体：</p><pre><code>几何形状的大小，封装一个width属性和height属性，两者均为Double类型。一定范围内的路径，封装一个start属性和length属性，两者均为Int类型。三维坐标系内一点，封装x，y和z属性，三者均为Double类型。</code></pre><p>在所有其它案例中，定义一个类，生成一个它的实例，并通过引用来管理和传递。实际中，这意味着绝大部分的自定义数据构造都应该是类，而非结构体</p><h1 id="字符串、数组和字典类型的赋值与赋值行为"><a href="#字符串、数组和字典类型的赋值与赋值行为" class="headerlink" title="字符串、数组和字典类型的赋值与赋值行为"></a>字符串、数组和字典类型的赋值与赋值行为</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Swift中，许多基本类型，诸如String，Array和Dictionary类型均以结构体的形式实现。这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。</span><br><span class="line"></span><br><span class="line">Objective-C中NSString，NSArray和NSDictionary类型均以类的形式实现，而并非结构体。它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。</span><br><span class="line"></span><br><span class="line">注意，以上是对字符串、数组、字典的“拷贝”行为的描述。在你的代码中，拷贝行为看起来似乎总会发生。然而，Swift在幕后只在绝对必要时才执行实际的拷贝。Swift管理所有的值拷贝以确保性能最优化，所以你没必要去回避赋值来保证性能最优化</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swift-Grammar--基本类型与运算</title>
      <link href="/2016/11/24/Swift/Swift/Grammar/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BF%90%E7%AE%97/"/>
      <url>/2016/11/24/Swift/Swift/Grammar/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BF%90%E7%AE%97/</url>
      <content type="html"><![CDATA[<p>1.<a href="#基本类型">基本类型</a><br>  1.1<a href="#数字类型">数字类型</a><br>  1.2<a href="#Double">Double</a><br>  1.3<a href="#布尔">布尔</a><br>2.<a href="#不同进制的前缀">不同进制的前缀</a><br>3.<a href="#元组（Tuple）">元组（Tuple）</a><br>4.<a href="#可选类型(Optionals">可选类型(Optionals)</a>)<br>5.<a href="#基本运算">基本运算</a><br>6.<a href="#类型安全">类型安全</a><br>7.<a href="#断言">断言</a></p><h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><p><span id="基本类型"></span></p><blockquote><p>多出来的是 <strong>Tuple*8 和 </strong>可选类型**<br>常量定义</p><ul><li>let 常量名</li><li>常量名可以死任意文字，文字长度</li><li>给常量一个值，叫赋值</li><li>形式： let 常量名 = 值</li></ul></blockquote><blockquote><p>变量</p></blockquote><ul><li>可主动变更或可预期时间内自耦东有规律或无规律的量</li></ul><blockquote><p>常量和变量的关系</p><ul><li>变化才是永恒不变的，无论如何，总有规律可循</li><li>变量与常量在一定条件下可以相互转换</li><li>常量局势变量的一种</li></ul></blockquote><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p><span id="数字类型"></span></p><blockquote><p><strong>Int 整型</strong></p><blockquote><p>类型可以不写，swift有类型推算功能</p></blockquote></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a:<span class="type">Int</span> = <span class="number">101</span>    <span class="comment">//定义一个整型 初始化为101</span></span><br><span class="line"><span class="keyword">var</span> aa:<span class="type">UInt</span> = <span class="number">201</span>  <span class="comment">//无符号的整型 （不能为负数）</span></span><br></pre></td></tr></table></figure><ul><li>在32位机器上是Int32 </li><li>在64位机器上是Int64</li><li>除了Int之外，还有Int，Int8，Int16，Int32，Int64.</li></ul><blockquote><p>各个取值范围</p><blockquote><p>其实取值范围就是 负2的n-1次方 ~ 2的n-1次方-1</p></blockquote></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="type">UInt8</span>.<span class="built_in">max</span>)  <span class="comment">//255</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">UInt8</span>.<span class="built_in">min</span>)  <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="type">Int8</span>.<span class="built_in">max</span>) <span class="comment">//127</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">Int8</span>.<span class="built_in">min</span>) <span class="comment">//-128</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="type">Int16</span>.<span class="built_in">max</span>)    <span class="comment">//32767</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">Int16</span>.<span class="built_in">min</span>)    <span class="comment">//-32768</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="type">Int32</span>.<span class="built_in">max</span>)    <span class="comment">//2147483647</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">Int32</span>.<span class="built_in">min</span>)    <span class="comment">//-2147483648</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="type">Int64</span>.<span class="built_in">max</span>)    <span class="comment">//9223372036854775807</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">Int64</span>.<span class="built_in">min</span>)    <span class="comment">//-9223372036854775808</span></span><br></pre></td></tr></table></figure><h2 id="Double"><a href="#Double" class="headerlink" title="Double"></a>Double</h2><p><span id="Double"></span></p><ul><li>swift 默认 浮点型是 Double（双精度）</li><li>64位浮点数</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  yue = <span class="number">3.5</span></span><br><span class="line">或</span><br><span class="line"><span class="keyword">var</span>  yue : <span class="type">Double</span> = <span class="number">3.5</span></span><br></pre></td></tr></table></figure><blockquote><p>Float </p></blockquote><ul><li>32位浮点数</li></ul><blockquote><p>Swift不支持数字类型之间的自动转换。必须显式手动转换<br>数值类字面量可以包括额外的格式来增强可读性。整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i: <span class="type">Int</span> = <span class="number">2_000</span>   <span class="comment">//这个表示2000  </span></span><br><span class="line"><span class="keyword">var</span> d: <span class="type">Double</span> = <span class="number">5.3</span>  </span><br><span class="line"><span class="keyword">var</span> e = d * <span class="type">Double</span>(i)</span><br></pre></td></tr></table></figure><h2 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h2><p><span id="布尔"></span></p><blockquote><p>Bool 表示逻辑上的真假： true、false<br>Swift和java一样，对boolean类型是强要求的，不能在if里面传一个整形用于判断</p></blockquote><h1 id="不同进制的前缀"><a href="#不同进制的前缀" class="headerlink" title="不同进制的前缀"></a>不同进制的前缀</h1><p><span id="不同进制的前缀"></span><br>|||<br>|—|—|<br>|十进制|没有|<br>|二进制   |     0b|<br>|八进制  |      0o|<br>|十六进制 |     0x|<br>|科学计数|<br>|1.25e2 |代表   1.25乘上10的2次方|<br>|0xFp2  |代表   15乘上2的2次方|<br>|typealias|    关键字，用来个类型起别名|</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">typealias</span> ii = <span class="type">Int8</span>  </span><br><span class="line">  <span class="keyword">var</span> mm = ii.<span class="built_in">min</span> <span class="comment">//这里的ii代表了Int8 </span></span><br><span class="line">  <span class="keyword">var</span> data1 = <span class="number">17</span>     <span class="comment">//17</span></span><br><span class="line"><span class="keyword">var</span> data2 = <span class="number">0b1010111</span>   <span class="comment">//87</span></span><br><span class="line"><span class="keyword">var</span> data3 = <span class="number">0o713</span>   <span class="comment">//459</span></span><br><span class="line"><span class="keyword">var</span> data4 = <span class="number">0xaf7</span>   <span class="comment">//2807</span></span><br></pre></td></tr></table></figure><h1 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组(Tuple)"></a>元组(Tuple)</h1><p><span id="元组(Tuple)"></span></p><blockquote><p>Tuple:定义变量组合<br>其实就是一群数据组合，可以将其解出来输出<br>注意的是tuple不只是两个元素，你可以自己扩展成多个元素</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> var x= 1</span><br><span class="line"> var y = 2</span><br><span class="line"> var z = 3</span><br><span class="line"> </span><br><span class="line">var 向量 = （1，2，3）</span><br><span class="line">print (向量.0 ,向量.1 ,向量.2)</span><br><span class="line"></span><br><span class="line">var (x,y,z) = (1,2,3)</span><br><span class="line">print (x,y,z)</span><br><span class="line"></span><br><span class="line">// 值前加前缀</span><br><span class="line">var 课程 = (day:100,unit:&quot;天&quot;,lanage:&quot;swift&quot;,version:&quot;3.0&quot;);</span><br><span class="line">print课程. day)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> menu = (<span class="string">"apple"</span>, <span class="number">20</span>)  <span class="comment">//定义一个Tuple  </span></span><br><span class="line"><span class="keyword">var</span> menu2 = (name: <span class="string">"banana"</span>, price:<span class="number">10</span>)  <span class="comment">//可以在定义的时候指定元素名字  </span></span><br><span class="line"><span class="keyword">let</span> (name,price) = menu   <span class="comment">//解Tuple，如果某个元素不想要的话，用 _ 代替  </span></span><br><span class="line"><span class="built_in">print</span>(name, price)   <span class="comment">//输出  apple 20  </span></span><br><span class="line"><span class="built_in">print</span>(menu.<span class="number">0</span>,menu.<span class="number">1</span>)  <span class="comment">//不解Tuple直接输出  </span></span><br><span class="line"><span class="built_in">print</span>(menu2.name,menu2.price)  <span class="comment">//利用元素名字解Tuple</span></span><br></pre></td></tr></table></figure><h2 id="可选类型-Optionals"><a href="#可选类型-Optionals" class="headerlink" title="可选类型(Optionals)"></a>可选类型(Optionals)</h2><p><span id="可选类型(Optionals)"></span></p><blockquote><p>当一个方法可以返回一个对象的时候，它有可能返回一个空值<br>比如将字符串转换为数字的方法。为了处理这种情况，有了可选类型。<br>可选类型表示一个数据，它可能有值，也可能为空。基本语法是在类型的后面加上问号 ？</p></blockquote><blockquote><p>定义形式</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">形式: var 变量：类型?,默认无值（nil）</span><br><span class="line"> </span><br><span class="line">var addressStr:String  </span><br><span class="line">print(addressStr)  //这里报错说str没初始化  </span><br><span class="line"></span><br><span class="line">var addressStr:String?</span><br><span class="line">addressStr = &quot;杭州&quot;</span><br></pre></td></tr></table></figure><blockquote><p>但是如果将str改为可选类型，那么这就可以输出</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str:<span class="type">String</span>?  </span><br><span class="line"><span class="built_in">print</span>(str)  <span class="comment">//输出 nil</span></span><br></pre></td></tr></table></figure><blockquote><p>可选类型转换为对应的类型 –&gt;对可选类型解包<br>强制解包有个注意点，就是如果这个可选类型是nil的话，那么强制解包的语句会在运行时报错</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str:<span class="type">String</span>? = <span class="string">"fe"</span>  </span><br><span class="line"><span class="keyword">var</span> s = str! <span class="comment">//将str解包为s，但是如果str没有赋值的话，那么这句会在运行时报错  </span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><blockquote><p>解决强制解包的时候，可选类型可能为nil的问题。if语句里面多了一个 Optional Binding 的概念。就是将可选类型解包后判断是否为nil，然后执行不同的分支代码 </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因为没给str赋值，所以输出  str为空  </span></span><br><span class="line"><span class="keyword">var</span> str:<span class="type">String</span>?  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> s = str &#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"str有值"</span>)  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"str为空"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在编程中，我们可以确保可选类型一定不为nil的，那么每次要将可选类型解包都要加个 !，很麻烦。所以有了隐式可选类型，它是用 ! 代替了 ? 号。然后在需要将可选类型转换为对应类型的时候就不用加 ! 了</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str:<span class="type">String</span>! = <span class="string">"string"</span>  </span><br><span class="line"><span class="keyword">var</span> s = str</span><br></pre></td></tr></table></figure><h1 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h1><p><span id="基本运算"></span></p><h2 id="一些和C完全一样的基本运算"><a href="#一些和C完全一样的基本运算" class="headerlink" title="一些和C完全一样的基本运算"></a>一些和C完全一样的基本运算</h2><blockquote><p>加减乘除，负号，自增（++）自减（–），+=等， 判断大小之类（==，!=，&gt;=…），三元运算符，逻辑运算（!，&amp;&amp;，||）</p></blockquote><h2 id="不一样的运算符"><a href="#不一样的运算符" class="headerlink" title="不一样的运算符"></a>不一样的运算符</h2><p><span id="不一样的运算符"></span></p><h3 id="取模"><a href="#取模" class="headerlink" title="取模%"></a>取模%</h3><blockquote><p>在C中，只能对整形进行运算<br>Swift中可以对浮点数进行运算。结果就是多出来的那部分</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">比如 <span class="number">7.1</span>%<span class="number">2.5</span>  得到<span class="number">2.1</span>，因为<span class="number">7.1</span>可以最多减去<span class="number">2</span>个<span class="number">2.5</span>，然后剩下<span class="number">2.1</span></span><br></pre></td></tr></table></figure><h3 id="范围运算符"><a href="#范围运算符" class="headerlink" title="范围运算符"></a>范围运算符</h3><blockquote><p> … 和 ..&lt;两个运算符可以用在for里面</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出 1 2 3    包含最后一个元素3  </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">3</span> &#123;  </span><br><span class="line">    <span class="built_in">print</span>(i)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//输出 1 2  不包含最后一个元素3  </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">3</span> &#123;  </span><br><span class="line">    <span class="built_in">print</span>(i)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单范围运算符"><a href="#单范围运算符" class="headerlink" title="单范围运算符"></a>单范围运算符</h3><blockquote><p>对于下标运算可以这样用</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">"Anna"</span>, <span class="string">"Alex"</span>, <span class="string">"Brian"</span>, <span class="string">"Jack"</span>]  </span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[<span class="number">2</span>...] &#123;  </span><br><span class="line">    <span class="built_in">print</span>(name)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// Brian  </span></span><br><span class="line"><span class="comment">// Jack  </span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[...<span class="number">2</span>] &#123;  </span><br><span class="line">    <span class="built_in">print</span>(name)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// Anna  </span></span><br><span class="line"><span class="comment">// Alex  </span></span><br><span class="line"><span class="comment">// Brian  </span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[..&lt;<span class="number">2</span>] &#123;  </span><br><span class="line">    <span class="built_in">print</span>(name)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// Anna  </span></span><br><span class="line"><span class="comment">// Alex</span></span><br></pre></td></tr></table></figure><h3 id="几元操作符"><a href="#几元操作符" class="headerlink" title="几元操作符"></a>几元操作符</h3><ul><li><p>操作几个对象 ，被称之为几元操作符</p><blockquote><p>一元运算符</p><ul><li>操作一个目标，是一元操作符 </li></ul></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-6    // 符号 紧跟 6，是一元运算符</span><br><span class="line">let b = -a</span><br></pre></td></tr></table></figure></li></ul><blockquote><p> 二元运算符</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">3</span> + <span class="number">4</span> <span class="comment">//两个目标之间，操作2个对象，习惯左右留空格</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a ?? b</span><br><span class="line"></span><br><span class="line">它的意思是：如果可选类型a不是<span class="literal">nil</span>，那么解包a并返回解包值，如果a为<span class="literal">nil</span>，那么返回b</span><br><span class="line"></span><br><span class="line">相当于 a != <span class="literal">nil</span> ? a! : b</span><br></pre></td></tr></table></figure><blockquote><p>赋值操作符</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> yue = <span class="number">3</span>  <span class="comment">// 用等号右边的值来更新左边变量的值</span></span><br><span class="line">yue = <span class="number">5</span></span><br></pre></td></tr></table></figure><blockquote><p>数学操作符(+ - * /)</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h1><p><span id="类型安全"></span></p><blockquote><p>变量（包含let）一旦定义，其类型不可改变，不能给一个变量一个类型不同的值</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  电费 = <span class="number">3.5</span></span><br><span class="line">点费 = <span class="number">5</span> </span><br><span class="line"><span class="built_in">print</span> (电费)     打印：<span class="number">5.0</span></span><br><span class="line">电费 = “五”       <span class="type">Error</span></span><br></pre></td></tr></table></figure><p>#断言<br><span id="断言"></span></p><blockquote><p>在某些情况下，如果值缺失或者值并不满足特定的条件，你的代码可能并不需要继续执行。这时，你可以在你的代码中触发一个断言(assertion)来结束代码运行并通过调试来找到值缺失的原因。<br>如果条件判断为true，代码运行会继续进行；如果条件判断为false，代码运行停止，你的应用被终止</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = -<span class="number">10</span></span><br><span class="line"> <span class="comment">//你可以在断言加一个信息</span></span><br><span class="line"> <span class="built_in">assert</span>(age&gt;<span class="number">0</span> , <span class="string">"age can not be less than zero"</span>)</span><br><span class="line"> <span class="comment">//程序运行到这里会crash掉 后面的程序不会再执行</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
          <category> Grammar </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
